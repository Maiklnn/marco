!(function (e, t) {
  "object" == typeof exports && "undefined" != typeof module
    ? (module.exports = t())
    : "function" == typeof define && define.amd
    ? define(t)
    : ((e =
        "undefined" != typeof globalThis
          ? globalThis
          : e || self).Swiper = t());
})(this, function () {
  "use strict";
  function e(e, t) {
    for (var a = 0; a < t.length; a++) {
      var i = t[a];
      (i.enumerable = i.enumerable || !1),
        (i.configurable = !0),
        "value" in i && (i.writable = !0),
        Object.defineProperty(e, i.key, i);
    }
  }
  function t() {
    return (t =
      Object.assign ||
      function (e) {
        for (var t = 1; t < arguments.length; t++) {
          var a = arguments[t];
          for (var i in a)
            Object.prototype.hasOwnProperty.call(a, i) && (e[i] = a[i]);
        }
        return e;
      }).apply(this, arguments);
  }
  function a(e) {
    return (
      null !== e &&
      "object" == typeof e &&
      "constructor" in e &&
      e.constructor === Object
    );
  }
  function i(e, t) {
    void 0 === e && (e = {}),
      void 0 === t && (t = {}),
      Object.keys(t).forEach(function (s) {
        void 0 === e[s]
          ? (e[s] = t[s])
          : a(t[s]) && a(e[s]) && Object.keys(t[s]).length > 0 && i(e[s], t[s]);
      });
  }
  var s = {
    body: {},
    addEventListener: function () {},
    removeEventListener: function () {},
    activeElement: { blur: function () {}, nodeName: "" },
    querySelector: function () {
      return null;
    },
    querySelectorAll: function () {
      return [];
    },
    getElementById: function () {
      return null;
    },
    createEvent: function () {
      return { initEvent: function () {} };
    },
    createElement: function () {
      return {
        children: [],
        childNodes: [],
        style: {},
        setAttribute: function () {},
        getElementsByTagName: function () {
          return [];
        },
      };
    },
    createElementNS: function () {
      return {};
    },
    importNode: function () {
      return null;
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: "",
    },
  };
  function r() {
    var e = "undefined" != typeof document ? document : {};
    return i(e, s), e;
  }
  var n = {
    document: s,
    navigator: { userAgent: "" },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: "",
    },
    history: {
      replaceState: function () {},
      pushState: function () {},
      go: function () {},
      back: function () {},
    },
    CustomEvent: function () {
      return this;
    },
    addEventListener: function () {},
    removeEventListener: function () {},
    getComputedStyle: function () {
      return {
        getPropertyValue: function () {
          return "";
        },
      };
    },
    Image: function () {},
    Date: function () {},
    screen: {},
    setTimeout: function () {},
    clearTimeout: function () {},
    matchMedia: function () {
      return {};
    },
    requestAnimationFrame: function (e) {
      return "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0);
    },
    cancelAnimationFrame: function (e) {
      "undefined" != typeof setTimeout && clearTimeout(e);
    },
  };
  function l() {
    var e = "undefined" != typeof window ? window : {};
    return i(e, n), e;
  }
  function o(e) {
    return (o = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e);
        })(e);
  }
  function d(e, t) {
    return (d =
      Object.setPrototypeOf ||
      function (e, t) {
        return (e.__proto__ = t), e;
      })(e, t);
  }
  function p() {
    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
    if (Reflect.construct.sham) return !1;
    if ("function" == typeof Proxy) return !0;
    try {
      return (
        Date.prototype.toString.call(
          Reflect.construct(Date, [], function () {})
        ),
        !0
      );
    } catch (e) {
      return !1;
    }
  }
  function u(e, t, a) {
    return (u = p()
      ? Reflect.construct
      : function (e, t, a) {
          var i = [null];
          i.push.apply(i, t);
          var s = new (Function.bind.apply(e, i))();
          return a && d(s, a.prototype), s;
        }).apply(null, arguments);
  }
  function c(e) {
    var t = "function" == typeof Map ? new Map() : void 0;
    return (c = function (e) {
      if (
        null === e ||
        ((a = e), -1 === Function.toString.call(a).indexOf("[native code]"))
      )
        return e;
      var a;
      if ("function" != typeof e)
        throw new TypeError(
          "Super expression must either be null or a function"
        );
      if (void 0 !== t) {
        if (t.has(e)) return t.get(e);
        t.set(e, i);
      }
      function i() {
        return u(e, arguments, o(this).constructor);
      }
      return (
        (i.prototype = Object.create(e.prototype, {
          constructor: {
            value: i,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })),
        d(i, e)
      );
    })(e);
  }
  var h = (function (e) {
    var t, a;
    function i(t) {
      var a, i, s;
      return (
        (a = e.call.apply(e, [this].concat(t)) || this),
        (i = (function (e) {
          if (void 0 === e)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return e;
        })(a)),
        (s = i.__proto__),
        Object.defineProperty(i, "__proto__", {
          get: function () {
            return s;
          },
          set: function (e) {
            s.__proto__ = e;
          },
        }),
        a
      );
    }
    return (
      (a = e),
      ((t = i).prototype = Object.create(a.prototype)),
      (t.prototype.constructor = t),
      (t.__proto__ = a),
      i
    );
  })(c(Array));
  function v(e) {
    void 0 === e && (e = []);
    var t = [];
    return (
      e.forEach(function (e) {
        Array.isArray(e) ? t.push.apply(t, v(e)) : t.push(e);
      }),
      t
    );
  }
  function f(e, t) {
    return Array.prototype.filter.call(e, t);
  }
  function m(e, t) {
    var a = l(),
      i = r(),
      s = [];
    if (!t && e instanceof h) return e;
    if (!e) return new h(s);
    if ("string" == typeof e) {
      var n = e.trim();
      if (n.indexOf("<") >= 0 && n.indexOf(">") >= 0) {
        var o = "div";
        0 === n.indexOf("<li") && (o = "ul"),
          0 === n.indexOf("<tr") && (o = "tbody"),
          (0 !== n.indexOf("<td") && 0 !== n.indexOf("<th")) || (o = "tr"),
          0 === n.indexOf("<tbody") && (o = "table"),
          0 === n.indexOf("<option") && (o = "select");
        var d = i.createElement(o);
        d.innerHTML = n;
        for (var p = 0; p < d.childNodes.length; p += 1)
          s.push(d.childNodes[p]);
      } else
        s = (function (e, t) {
          if ("string" != typeof e) return [e];
          for (
            var a = [], i = t.querySelectorAll(e), s = 0;
            s < i.length;
            s += 1
          )
            a.push(i[s]);
          return a;
        })(e.trim(), t || i);
    } else if (e.nodeType || e === a || e === i) s.push(e);
    else if (Array.isArray(e)) {
      if (e instanceof h) return e;
      s = e;
    }
    return new h(
      (function (e) {
        for (var t = [], a = 0; a < e.length; a += 1)
          -1 === t.indexOf(e[a]) && t.push(e[a]);
        return t;
      })(s)
    );
  }
  m.fn = h.prototype;
  var g,
    y,
    w,
    b = {
      addClass: function () {
        for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++)
          t[a] = arguments[a];
        var i = v(
          t.map(function (e) {
            return e.split(" ");
          })
        );
        return (
          this.forEach(function (e) {
            var t;
            (t = e.classList).add.apply(t, i);
          }),
          this
        );
      },
      removeClass: function () {
        for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++)
          t[a] = arguments[a];
        var i = v(
          t.map(function (e) {
            return e.split(" ");
          })
        );
        return (
          this.forEach(function (e) {
            var t;
            (t = e.classList).remove.apply(t, i);
          }),
          this
        );
      },
      hasClass: function () {
        for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++)
          t[a] = arguments[a];
        var i = v(
          t.map(function (e) {
            return e.split(" ");
          })
        );
        return (
          f(this, function (e) {
            return (
              i.filter(function (t) {
                return e.classList.contains(t);
              }).length > 0
            );
          }).length > 0
        );
      },
      toggleClass: function () {
        for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++)
          t[a] = arguments[a];
        var i = v(
          t.map(function (e) {
            return e.split(" ");
          })
        );
        this.forEach(function (e) {
          i.forEach(function (t) {
            e.classList.toggle(t);
          });
        });
      },
      attr: function (e, t) {
        if (1 === arguments.length && "string" == typeof e)
          return this[0] ? this[0].getAttribute(e) : void 0;
        for (var a = 0; a < this.length; a += 1)
          if (2 === arguments.length) this[a].setAttribute(e, t);
          else
            for (var i in e) (this[a][i] = e[i]), this[a].setAttribute(i, e[i]);
        return this;
      },
      removeAttr: function (e) {
        for (var t = 0; t < this.length; t += 1) this[t].removeAttribute(e);
        return this;
      },
      transform: function (e) {
        for (var t = 0; t < this.length; t += 1) this[t].style.transform = e;
        return this;
      },
      transition: function (e) {
        for (var t = 0; t < this.length; t += 1)
          this[t].style.transitionDuration =
            "string" != typeof e ? e + "ms" : e;
        return this;
      },
      on: function () {
        for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++)
          t[a] = arguments[a];
        var i = t[0],
          s = t[1],
          r = t[2],
          n = t[3];
        function l(e) {
          var t = e.target;
          if (t) {
            var a = e.target.dom7EventData || [];
            if ((a.indexOf(e) < 0 && a.unshift(e), m(t).is(s))) r.apply(t, a);
            else
              for (var i = m(t).parents(), n = 0; n < i.length; n += 1)
                m(i[n]).is(s) && r.apply(i[n], a);
          }
        }
        function o(e) {
          var t = (e && e.target && e.target.dom7EventData) || [];
          t.indexOf(e) < 0 && t.unshift(e), r.apply(this, t);
        }
        "function" == typeof t[1] &&
          ((i = t[0]), (r = t[1]), (n = t[2]), (s = void 0)),
          n || (n = !1);
        for (var d, p = i.split(" "), u = 0; u < this.length; u += 1) {
          var c = this[u];
          if (s)
            for (d = 0; d < p.length; d += 1) {
              var h = p[d];
              c.dom7LiveListeners || (c.dom7LiveListeners = {}),
                c.dom7LiveListeners[h] || (c.dom7LiveListeners[h] = []),
                c.dom7LiveListeners[h].push({ listener: r, proxyListener: l }),
                c.addEventListener(h, l, n);
            }
          else
            for (d = 0; d < p.length; d += 1) {
              var v = p[d];
              c.dom7Listeners || (c.dom7Listeners = {}),
                c.dom7Listeners[v] || (c.dom7Listeners[v] = []),
                c.dom7Listeners[v].push({ listener: r, proxyListener: o }),
                c.addEventListener(v, o, n);
            }
        }
        return this;
      },
      off: function () {
        for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++)
          t[a] = arguments[a];
        var i = t[0],
          s = t[1],
          r = t[2],
          n = t[3];
        "function" == typeof t[1] &&
          ((i = t[0]), (r = t[1]), (n = t[2]), (s = void 0)),
          n || (n = !1);
        for (var l = i.split(" "), o = 0; o < l.length; o += 1)
          for (var d = l[o], p = 0; p < this.length; p += 1) {
            var u = this[p],
              c = void 0;
            if (
              (!s && u.dom7Listeners
                ? (c = u.dom7Listeners[d])
                : s && u.dom7LiveListeners && (c = u.dom7LiveListeners[d]),
              c && c.length)
            )
              for (var h = c.length - 1; h >= 0; h -= 1) {
                var v = c[h];
                (r && v.listener === r) ||
                (r &&
                  v.listener &&
                  v.listener.dom7proxy &&
                  v.listener.dom7proxy === r)
                  ? (u.removeEventListener(d, v.proxyListener, n),
                    c.splice(h, 1))
                  : r ||
                    (u.removeEventListener(d, v.proxyListener, n),
                    c.splice(h, 1));
              }
          }
        return this;
      },
      trigger: function () {
        for (
          var e = l(), t = arguments.length, a = new Array(t), i = 0;
          i < t;
          i++
        )
          a[i] = arguments[i];
        for (var s = a[0].split(" "), r = a[1], n = 0; n < s.length; n += 1)
          for (var o = s[n], d = 0; d < this.length; d += 1) {
            var p = this[d];
            if (e.CustomEvent) {
              var u = new e.CustomEvent(o, {
                detail: r,
                bubbles: !0,
                cancelable: !0,
              });
              (p.dom7EventData = a.filter(function (e, t) {
                return t > 0;
              })),
                p.dispatchEvent(u),
                (p.dom7EventData = []),
                delete p.dom7EventData;
            }
          }
        return this;
      },
      transitionEnd: function (e) {
        var t = this;
        return (
          e &&
            t.on("transitionend", function a(i) {
              i.target === this && (e.call(this, i), t.off("transitionend", a));
            }),
          this
        );
      },
      outerWidth: function (e) {
        if (this.length > 0) {
          if (e) {
            var t = this.styles();
            return (
              this[0].offsetWidth +
              parseFloat(t.getPropertyValue("margin-right")) +
              parseFloat(t.getPropertyValue("margin-left"))
            );
          }
          return this[0].offsetWidth;
        }
        return null;
      },
      outerHeight: function (e) {
        if (this.length > 0) {
          if (e) {
            var t = this.styles();
            return (
              this[0].offsetHeight +
              parseFloat(t.getPropertyValue("margin-top")) +
              parseFloat(t.getPropertyValue("margin-bottom"))
            );
          }
          return this[0].offsetHeight;
        }
        return null;
      },
      styles: function () {
        var e = l();
        return this[0] ? e.getComputedStyle(this[0], null) : {};
      },
      offset: function () {
        if (this.length > 0) {
          var e = l(),
            t = r(),
            a = this[0],
            i = a.getBoundingClientRect(),
            s = t.body,
            n = a.clientTop || s.clientTop || 0,
            o = a.clientLeft || s.clientLeft || 0,
            d = a === e ? e.scrollY : a.scrollTop,
            p = a === e ? e.scrollX : a.scrollLeft;
          return { top: i.top + d - n, left: i.left + p - o };
        }
        return null;
      },
      css: function (e, t) {
        var a,
          i = l();
        if (1 === arguments.length) {
          if ("string" != typeof e) {
            for (a = 0; a < this.length; a += 1)
              for (var s in e) this[a].style[s] = e[s];
            return this;
          }
          if (this[0])
            return i.getComputedStyle(this[0], null).getPropertyValue(e);
        }
        if (2 === arguments.length && "string" == typeof e) {
          for (a = 0; a < this.length; a += 1) this[a].style[e] = t;
          return this;
        }
        return this;
      },
      each: function (e) {
        return e
          ? (this.forEach(function (t, a) {
              e.apply(t, [t, a]);
            }),
            this)
          : this;
      },
      html: function (e) {
        if (void 0 === e) return this[0] ? this[0].innerHTML : null;
        for (var t = 0; t < this.length; t += 1) this[t].innerHTML = e;
        return this;
      },
      text: function (e) {
        if (void 0 === e) return this[0] ? this[0].textContent.trim() : null;
        for (var t = 0; t < this.length; t += 1) this[t].textContent = e;
        return this;
      },
      is: function (e) {
        var t,
          a,
          i = l(),
          s = r(),
          n = this[0];
        if (!n || void 0 === e) return !1;
        if ("string" == typeof e) {
          if (n.matches) return n.matches(e);
          if (n.webkitMatchesSelector) return n.webkitMatchesSelector(e);
          if (n.msMatchesSelector) return n.msMatchesSelector(e);
          for (t = m(e), a = 0; a < t.length; a += 1) if (t[a] === n) return !0;
          return !1;
        }
        if (e === s) return n === s;
        if (e === i) return n === i;
        if (e.nodeType || e instanceof h) {
          for (t = e.nodeType ? [e] : e, a = 0; a < t.length; a += 1)
            if (t[a] === n) return !0;
          return !1;
        }
        return !1;
      },
      index: function () {
        var e,
          t = this[0];
        if (t) {
          for (e = 0; null !== (t = t.previousSibling); )
            1 === t.nodeType && (e += 1);
          return e;
        }
      },
      eq: function (e) {
        if (void 0 === e) return this;
        var t = this.length;
        if (e > t - 1) return m([]);
        if (e < 0) {
          var a = t + e;
          return m(a < 0 ? [] : [this[a]]);
        }
        return m([this[e]]);
      },
      append: function () {
        for (var e, t = r(), a = 0; a < arguments.length; a += 1) {
          e = a < 0 || arguments.length <= a ? void 0 : arguments[a];
          for (var i = 0; i < this.length; i += 1)
            if ("string" == typeof e) {
              var s = t.createElement("div");
              for (s.innerHTML = e; s.firstChild; )
                this[i].appendChild(s.firstChild);
            } else if (e instanceof h)
              for (var n = 0; n < e.length; n += 1) this[i].appendChild(e[n]);
            else this[i].appendChild(e);
        }
        return this;
      },
      prepend: function (e) {
        var t,
          a,
          i = r();
        for (t = 0; t < this.length; t += 1)
          if ("string" == typeof e) {
            var s = i.createElement("div");
            for (s.innerHTML = e, a = s.childNodes.length - 1; a >= 0; a -= 1)
              this[t].insertBefore(s.childNodes[a], this[t].childNodes[0]);
          } else if (e instanceof h)
            for (a = 0; a < e.length; a += 1)
              this[t].insertBefore(e[a], this[t].childNodes[0]);
          else this[t].insertBefore(e, this[t].childNodes[0]);
        return this;
      },
      next: function (e) {
        return this.length > 0
          ? e
            ? this[0].nextElementSibling && m(this[0].nextElementSibling).is(e)
              ? m([this[0].nextElementSibling])
              : m([])
            : this[0].nextElementSibling
            ? m([this[0].nextElementSibling])
            : m([])
          : m([]);
      },
      nextAll: function (e) {
        var t = [],
          a = this[0];
        if (!a) return m([]);
        for (; a.nextElementSibling; ) {
          var i = a.nextElementSibling;
          e ? m(i).is(e) && t.push(i) : t.push(i), (a = i);
        }
        return m(t);
      },
      prev: function (e) {
        if (this.length > 0) {
          var t = this[0];
          return e
            ? t.previousElementSibling && m(t.previousElementSibling).is(e)
              ? m([t.previousElementSibling])
              : m([])
            : t.previousElementSibling
            ? m([t.previousElementSibling])
            : m([]);
        }
        return m([]);
      },
      prevAll: function (e) {
        var t = [],
          a = this[0];
        if (!a) return m([]);
        for (; a.previousElementSibling; ) {
          var i = a.previousElementSibling;
          e ? m(i).is(e) && t.push(i) : t.push(i), (a = i);
        }
        return m(t);
      },
      parent: function (e) {
        for (var t = [], a = 0; a < this.length; a += 1)
          null !== this[a].parentNode &&
            (e
              ? m(this[a].parentNode).is(e) && t.push(this[a].parentNode)
              : t.push(this[a].parentNode));
        return m(t);
      },
      parents: function (e) {
        for (var t = [], a = 0; a < this.length; a += 1)
          for (var i = this[a].parentNode; i; )
            e ? m(i).is(e) && t.push(i) : t.push(i), (i = i.parentNode);
        return m(t);
      },
      closest: function (e) {
        var t = this;
        return void 0 === e ? m([]) : (t.is(e) || (t = t.parents(e).eq(0)), t);
      },
      find: function (e) {
        for (var t = [], a = 0; a < this.length; a += 1)
          for (var i = this[a].querySelectorAll(e), s = 0; s < i.length; s += 1)
            t.push(i[s]);
        return m(t);
      },
      children: function (e) {
        for (var t = [], a = 0; a < this.length; a += 1)
          for (var i = this[a].children, s = 0; s < i.length; s += 1)
            (e && !m(i[s]).is(e)) || t.push(i[s]);
        return m(t);
      },
      filter: function (e) {
        return m(f(this, e));
      },
      remove: function () {
        for (var e = 0; e < this.length; e += 1)
          this[e].parentNode && this[e].parentNode.removeChild(this[e]);
        return this;
      },
    };
  function E(e, t) {
    return void 0 === t && (t = 0), setTimeout(e, t);
  }
  function x() {
    return Date.now();
  }
  function T(e, t) {
    void 0 === t && (t = "x");
    var a,
      i,
      s,
      r = l(),
      n = r.getComputedStyle(e, null);
    return (
      r.WebKitCSSMatrix
        ? ((i = n.transform || n.webkitTransform).split(",").length > 6 &&
            (i = i
              .split(", ")
              .map(function (e) {
                return e.replace(",", ".");
              })
              .join(", ")),
          (s = new r.WebKitCSSMatrix("none" === i ? "" : i)))
        : (a = (s =
            n.MozTransform ||
            n.OTransform ||
            n.MsTransform ||
            n.msTransform ||
            n.transform ||
            n
              .getPropertyValue("transform")
              .replace("translate(", "matrix(1, 0, 0, 1,"))
            .toString()
            .split(",")),
      "x" === t &&
        (i = r.WebKitCSSMatrix
          ? s.m41
          : 16 === a.length
          ? parseFloat(a[12])
          : parseFloat(a[4])),
      "y" === t &&
        (i = r.WebKitCSSMatrix
          ? s.m42
          : 16 === a.length
          ? parseFloat(a[13])
          : parseFloat(a[5])),
      i || 0
    );
  }
  function C(e) {
    return (
      "object" == typeof e &&
      null !== e &&
      e.constructor &&
      e.constructor === Object
    );
  }
  function S() {
    for (
      var e = Object(arguments.length <= 0 ? void 0 : arguments[0]), t = 1;
      t < arguments.length;
      t += 1
    ) {
      var a = t < 0 || arguments.length <= t ? void 0 : arguments[t];
      if (null != a)
        for (
          var i = Object.keys(Object(a)), s = 0, r = i.length;
          s < r;
          s += 1
        ) {
          var n = i[s],
            l = Object.getOwnPropertyDescriptor(a, n);
          void 0 !== l &&
            l.enumerable &&
            (C(e[n]) && C(a[n])
              ? S(e[n], a[n])
              : !C(e[n]) && C(a[n])
              ? ((e[n] = {}), S(e[n], a[n]))
              : (e[n] = a[n]));
        }
    }
    return e;
  }
  function M(e, t) {
    Object.keys(t).forEach(function (a) {
      C(t[a]) &&
        Object.keys(t[a]).forEach(function (i) {
          "function" == typeof t[a][i] && (t[a][i] = t[a][i].bind(e));
        }),
        (e[a] = t[a]);
    });
  }
  function z() {
    return (
      g ||
        (g = (function () {
          var e = l(),
            t = r();
          return {
            touch: !!(
              "ontouchstart" in e ||
              (e.DocumentTouch && t instanceof e.DocumentTouch)
            ),
            pointerEvents:
              !!e.PointerEvent &&
              "maxTouchPoints" in e.navigator &&
              e.navigator.maxTouchPoints >= 0,
            observer: "MutationObserver" in e || "WebkitMutationObserver" in e,
            passiveListener: (function () {
              var t = !1;
              try {
                var a = Object.defineProperty({}, "passive", {
                  get: function () {
                    t = !0;
                  },
                });
                e.addEventListener("testPassiveListener", null, a);
              } catch (e) {}
              return t;
            })(),
            gestures: "ongesturestart" in e,
          };
        })()),
      g
    );
  }
  function P(e) {
    return (
      void 0 === e && (e = {}),
      y ||
        (y = (function (e) {
          var t = (void 0 === e ? {} : e).userAgent,
            a = z(),
            i = l(),
            s = i.navigator.platform,
            r = t || i.navigator.userAgent,
            n = { ios: !1, android: !1 },
            o = i.screen.width,
            d = i.screen.height,
            p = r.match(/(Android);?[\s\/]+([\d.]+)?/),
            u = r.match(/(iPad).*OS\s([\d_]+)/),
            c = r.match(/(iPod)(.*OS\s([\d_]+))?/),
            h = !u && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
            v = "Win32" === s,
            f = "MacIntel" === s;
          return (
            !u &&
              f &&
              a.touch &&
              [
                "1024x1366",
                "1366x1024",
                "834x1194",
                "1194x834",
                "834x1112",
                "1112x834",
                "768x1024",
                "1024x768",
                "820x1180",
                "1180x820",
                "810x1080",
                "1080x810",
              ].indexOf(o + "x" + d) >= 0 &&
              ((u = r.match(/(Version)\/([\d.]+)/)) || (u = [0, 1, "13_0_0"]),
              (f = !1)),
            p && !v && ((n.os = "android"), (n.android = !0)),
            (u || h || c) && ((n.os = "ios"), (n.ios = !0)),
            n
          );
        })(e)),
      y
    );
  }
  function k() {
    return (
      w ||
        (w = (function () {
          var e,
            t = l();
          return {
            isEdge: !!t.navigator.userAgent.match(/Edge/g),
            isSafari:
              ((e = t.navigator.userAgent.toLowerCase()),
              e.indexOf("safari") >= 0 &&
                e.indexOf("chrome") < 0 &&
                e.indexOf("android") < 0),
            isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
              t.navigator.userAgent
            ),
          };
        })()),
      w
    );
  }
  Object.keys(b).forEach(function (e) {
    m.fn[e] = b[e];
  });
  var L = {
      name: "resize",
      create: function () {
        var e = this;
        S(e, {
          resize: {
            resizeHandler: function () {
              e &&
                !e.destroyed &&
                e.initialized &&
                (e.emit("beforeResize"), e.emit("resize"));
            },
            orientationChangeHandler: function () {
              e && !e.destroyed && e.initialized && e.emit("orientationchange");
            },
          },
        });
      },
      on: {
        init: function (e) {
          var t = l();
          t.addEventListener("resize", e.resize.resizeHandler),
            t.addEventListener(
              "orientationchange",
              e.resize.orientationChangeHandler
            );
        },
        destroy: function (e) {
          var t = l();
          t.removeEventListener("resize", e.resize.resizeHandler),
            t.removeEventListener(
              "orientationchange",
              e.resize.orientationChangeHandler
            );
        },
      },
    },
    $ = {
      attach: function (e, t) {
        void 0 === t && (t = {});
        var a = l(),
          i = this,
          s = new (a.MutationObserver || a.WebkitMutationObserver)(function (
            e
          ) {
            if (1 !== e.length) {
              var t = function () {
                i.emit("observerUpdate", e[0]);
              };
              a.requestAnimationFrame
                ? a.requestAnimationFrame(t)
                : a.setTimeout(t, 0);
            } else i.emit("observerUpdate", e[0]);
          });
        s.observe(e, {
          attributes: void 0 === t.attributes || t.attributes,
          childList: void 0 === t.childList || t.childList,
          characterData: void 0 === t.characterData || t.characterData,
        }),
          i.observer.observers.push(s);
      },
      init: function () {
        var e = this;
        if (e.support.observer && e.params.observer) {
          if (e.params.observeParents)
            for (var t = e.$el.parents(), a = 0; a < t.length; a += 1)
              e.observer.attach(t[a]);
          e.observer.attach(e.$el[0], {
            childList: e.params.observeSlideChildren,
          }),
            e.observer.attach(e.$wrapperEl[0], { attributes: !1 });
        }
      },
      destroy: function () {
        this.observer.observers.forEach(function (e) {
          e.disconnect();
        }),
          (this.observer.observers = []);
      },
    },
    I = {
      name: "observer",
      params: { observer: !1, observeParents: !1, observeSlideChildren: !1 },
      create: function () {
        M(this, { observer: t({}, $, { observers: [] }) });
      },
      on: {
        init: function (e) {
          e.observer.init();
        },
        destroy: function (e) {
          e.observer.destroy();
        },
      },
    };
  function O(e) {
    var t = this,
      a = r(),
      i = l(),
      s = t.touchEventsData,
      n = t.params,
      o = t.touches;
    if (!t.animating || !n.preventInteractionOnTransition) {
      var d = e;
      d.originalEvent && (d = d.originalEvent);
      var p = m(d.target);
      if ("wrapper" !== n.touchEventsTarget || p.closest(t.wrapperEl).length)
        if (
          ((s.isTouchEvent = "touchstart" === d.type),
          s.isTouchEvent || !("which" in d) || 3 !== d.which)
        )
          if (!(!s.isTouchEvent && "button" in d && d.button > 0))
            if (!s.isTouched || !s.isMoved)
              if (
                (!!n.noSwipingClass &&
                  "" !== n.noSwipingClass &&
                  d.target &&
                  d.target.shadowRoot &&
                  e.path &&
                  e.path[0] &&
                  (p = m(e.path[0])),
                n.noSwiping &&
                  p.closest(
                    n.noSwipingSelector
                      ? n.noSwipingSelector
                      : "." + n.noSwipingClass
                  )[0])
              )
                t.allowClick = !0;
              else if (!n.swipeHandler || p.closest(n.swipeHandler)[0]) {
                (o.currentX =
                  "touchstart" === d.type ? d.targetTouches[0].pageX : d.pageX),
                  (o.currentY =
                    "touchstart" === d.type
                      ? d.targetTouches[0].pageY
                      : d.pageY);
                var u = o.currentX,
                  c = o.currentY,
                  h = n.edgeSwipeDetection || n.iOSEdgeSwipeDetection,
                  v = n.edgeSwipeThreshold || n.iOSEdgeSwipeThreshold;
                if (!h || !(u <= v || u >= i.innerWidth - v)) {
                  if (
                    (S(s, {
                      isTouched: !0,
                      isMoved: !1,
                      allowTouchCallbacks: !0,
                      isScrolling: void 0,
                      startMoving: void 0,
                    }),
                    (o.startX = u),
                    (o.startY = c),
                    (s.touchStartTime = x()),
                    (t.allowClick = !0),
                    t.updateSize(),
                    (t.swipeDirection = void 0),
                    n.threshold > 0 && (s.allowThresholdMove = !1),
                    "touchstart" !== d.type)
                  ) {
                    var f = !0;
                    p.is(s.formElements) && (f = !1),
                      a.activeElement &&
                        m(a.activeElement).is(s.formElements) &&
                        a.activeElement !== p[0] &&
                        a.activeElement.blur();
                    var g = f && t.allowTouchMove && n.touchStartPreventDefault;
                    (!n.touchStartForcePreventDefault && !g) ||
                      p[0].isContentEditable ||
                      d.preventDefault();
                  }
                  t.emit("touchStart", d);
                }
              }
    }
  }
  function A(e) {
    var t = r(),
      a = this,
      i = a.touchEventsData,
      s = a.params,
      n = a.touches,
      l = a.rtlTranslate,
      o = e;
    if ((o.originalEvent && (o = o.originalEvent), i.isTouched)) {
      if (!i.isTouchEvent || "touchmove" === o.type) {
        var d =
            "touchmove" === o.type &&
            o.targetTouches &&
            (o.targetTouches[0] || o.changedTouches[0]),
          p = "touchmove" === o.type ? d.pageX : o.pageX,
          u = "touchmove" === o.type ? d.pageY : o.pageY;
        if (o.preventedByNestedSwiper)
          return (n.startX = p), void (n.startY = u);
        if (!a.allowTouchMove)
          return (
            (a.allowClick = !1),
            void (
              i.isTouched &&
              (S(n, { startX: p, startY: u, currentX: p, currentY: u }),
              (i.touchStartTime = x()))
            )
          );
        if (i.isTouchEvent && s.touchReleaseOnEdges && !s.loop)
          if (a.isVertical()) {
            if (
              (u < n.startY && a.translate <= a.maxTranslate()) ||
              (u > n.startY && a.translate >= a.minTranslate())
            )
              return (i.isTouched = !1), void (i.isMoved = !1);
          } else if (
            (p < n.startX && a.translate <= a.maxTranslate()) ||
            (p > n.startX && a.translate >= a.minTranslate())
          )
            return;
        if (
          i.isTouchEvent &&
          t.activeElement &&
          o.target === t.activeElement &&
          m(o.target).is(i.formElements)
        )
          return (i.isMoved = !0), void (a.allowClick = !1);
        if (
          (i.allowTouchCallbacks && a.emit("touchMove", o),
          !(o.targetTouches && o.targetTouches.length > 1))
        ) {
          (n.currentX = p), (n.currentY = u);
          var c = n.currentX - n.startX,
            h = n.currentY - n.startY;
          if (
            !(
              a.params.threshold &&
              Math.sqrt(Math.pow(c, 2) + Math.pow(h, 2)) < a.params.threshold
            )
          ) {
            var v;
            if (void 0 === i.isScrolling)
              (a.isHorizontal() && n.currentY === n.startY) ||
              (a.isVertical() && n.currentX === n.startX)
                ? (i.isScrolling = !1)
                : c * c + h * h >= 25 &&
                  ((v = (180 * Math.atan2(Math.abs(h), Math.abs(c))) / Math.PI),
                  (i.isScrolling = a.isHorizontal()
                    ? v > s.touchAngle
                    : 90 - v > s.touchAngle));
            if (
              (i.isScrolling && a.emit("touchMoveOpposite", o),
              void 0 === i.startMoving &&
                ((n.currentX === n.startX && n.currentY === n.startY) ||
                  (i.startMoving = !0)),
              i.isScrolling)
            )
              i.isTouched = !1;
            else if (i.startMoving) {
              (a.allowClick = !1),
                !s.cssMode && o.cancelable && o.preventDefault(),
                s.touchMoveStopPropagation && !s.nested && o.stopPropagation(),
                i.isMoved ||
                  (s.loop && a.loopFix(),
                  (i.startTranslate = a.getTranslate()),
                  a.setTransition(0),
                  a.animating &&
                    a.$wrapperEl.trigger("webkitTransitionEnd transitionend"),
                  (i.allowMomentumBounce = !1),
                  !s.grabCursor ||
                    (!0 !== a.allowSlideNext && !0 !== a.allowSlidePrev) ||
                    a.setGrabCursor(!0),
                  a.emit("sliderFirstMove", o)),
                a.emit("sliderMove", o),
                (i.isMoved = !0);
              var f = a.isHorizontal() ? c : h;
              (n.diff = f),
                (f *= s.touchRatio),
                l && (f = -f),
                (a.swipeDirection = f > 0 ? "prev" : "next"),
                (i.currentTranslate = f + i.startTranslate);
              var g = !0,
                y = s.resistanceRatio;
              if (
                (s.touchReleaseOnEdges && (y = 0),
                f > 0 && i.currentTranslate > a.minTranslate()
                  ? ((g = !1),
                    s.resistance &&
                      (i.currentTranslate =
                        a.minTranslate() -
                        1 +
                        Math.pow(-a.minTranslate() + i.startTranslate + f, y)))
                  : f < 0 &&
                    i.currentTranslate < a.maxTranslate() &&
                    ((g = !1),
                    s.resistance &&
                      (i.currentTranslate =
                        a.maxTranslate() +
                        1 -
                        Math.pow(a.maxTranslate() - i.startTranslate - f, y))),
                g && (o.preventedByNestedSwiper = !0),
                !a.allowSlideNext &&
                  "next" === a.swipeDirection &&
                  i.currentTranslate < i.startTranslate &&
                  (i.currentTranslate = i.startTranslate),
                !a.allowSlidePrev &&
                  "prev" === a.swipeDirection &&
                  i.currentTranslate > i.startTranslate &&
                  (i.currentTranslate = i.startTranslate),
                s.threshold > 0)
              ) {
                if (!(Math.abs(f) > s.threshold || i.allowThresholdMove))
                  return void (i.currentTranslate = i.startTranslate);
                if (!i.allowThresholdMove)
                  return (
                    (i.allowThresholdMove = !0),
                    (n.startX = n.currentX),
                    (n.startY = n.currentY),
                    (i.currentTranslate = i.startTranslate),
                    void (n.diff = a.isHorizontal()
                      ? n.currentX - n.startX
                      : n.currentY - n.startY)
                  );
              }
              s.followFinger &&
                !s.cssMode &&
                ((s.freeMode ||
                  s.watchSlidesProgress ||
                  s.watchSlidesVisibility) &&
                  (a.updateActiveIndex(), a.updateSlidesClasses()),
                s.freeMode &&
                  (0 === i.velocities.length &&
                    i.velocities.push({
                      position: n[a.isHorizontal() ? "startX" : "startY"],
                      time: i.touchStartTime,
                    }),
                  i.velocities.push({
                    position: n[a.isHorizontal() ? "currentX" : "currentY"],
                    time: x(),
                  })),
                a.updateProgress(i.currentTranslate),
                a.setTranslate(i.currentTranslate));
            }
          }
        }
      }
    } else i.startMoving && i.isScrolling && a.emit("touchMoveOpposite", o);
  }
  function D(e) {
    var t = this,
      a = t.touchEventsData,
      i = t.params,
      s = t.touches,
      r = t.rtlTranslate,
      n = t.$wrapperEl,
      l = t.slidesGrid,
      o = t.snapGrid,
      d = e;
    if (
      (d.originalEvent && (d = d.originalEvent),
      a.allowTouchCallbacks && t.emit("touchEnd", d),
      (a.allowTouchCallbacks = !1),
      !a.isTouched)
    )
      return (
        a.isMoved && i.grabCursor && t.setGrabCursor(!1),
        (a.isMoved = !1),
        void (a.startMoving = !1)
      );
    i.grabCursor &&
      a.isMoved &&
      a.isTouched &&
      (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) &&
      t.setGrabCursor(!1);
    var p,
      u = x(),
      c = u - a.touchStartTime;
    if (
      (t.allowClick &&
        (t.updateClickedSlide(d),
        t.emit("tap click", d),
        c < 300 &&
          u - a.lastClickTime < 300 &&
          t.emit("doubleTap doubleClick", d)),
      (a.lastClickTime = x()),
      E(function () {
        t.destroyed || (t.allowClick = !0);
      }),
      !a.isTouched ||
        !a.isMoved ||
        !t.swipeDirection ||
        0 === s.diff ||
        a.currentTranslate === a.startTranslate)
    )
      return (a.isTouched = !1), (a.isMoved = !1), void (a.startMoving = !1);
    if (
      ((a.isTouched = !1),
      (a.isMoved = !1),
      (a.startMoving = !1),
      (p = i.followFinger
        ? r
          ? t.translate
          : -t.translate
        : -a.currentTranslate),
      !i.cssMode)
    )
      if (i.freeMode) {
        if (p < -t.minTranslate()) return void t.slideTo(t.activeIndex);
        if (p > -t.maxTranslate())
          return void (t.slides.length < o.length
            ? t.slideTo(o.length - 1)
            : t.slideTo(t.slides.length - 1));
        if (i.freeModeMomentum) {
          if (a.velocities.length > 1) {
            var h = a.velocities.pop(),
              v = a.velocities.pop(),
              f = h.position - v.position,
              m = h.time - v.time;
            (t.velocity = f / m),
              (t.velocity /= 2),
              Math.abs(t.velocity) < i.freeModeMinimumVelocity &&
                (t.velocity = 0),
              (m > 150 || x() - h.time > 300) && (t.velocity = 0);
          } else t.velocity = 0;
          (t.velocity *= i.freeModeMomentumVelocityRatio),
            (a.velocities.length = 0);
          var g = 1e3 * i.freeModeMomentumRatio,
            y = t.velocity * g,
            w = t.translate + y;
          r && (w = -w);
          var b,
            T,
            C = !1,
            S = 20 * Math.abs(t.velocity) * i.freeModeMomentumBounceRatio;
          if (w < t.maxTranslate())
            i.freeModeMomentumBounce
              ? (w + t.maxTranslate() < -S && (w = t.maxTranslate() - S),
                (b = t.maxTranslate()),
                (C = !0),
                (a.allowMomentumBounce = !0))
              : (w = t.maxTranslate()),
              i.loop && i.centeredSlides && (T = !0);
          else if (w > t.minTranslate())
            i.freeModeMomentumBounce
              ? (w - t.minTranslate() > S && (w = t.minTranslate() + S),
                (b = t.minTranslate()),
                (C = !0),
                (a.allowMomentumBounce = !0))
              : (w = t.minTranslate()),
              i.loop && i.centeredSlides && (T = !0);
          else if (i.freeModeSticky) {
            for (var M, z = 0; z < o.length; z += 1)
              if (o[z] > -w) {
                M = z;
                break;
              }
            w = -(w =
              Math.abs(o[M] - w) < Math.abs(o[M - 1] - w) ||
              "next" === t.swipeDirection
                ? o[M]
                : o[M - 1]);
          }
          if (
            (T &&
              t.once("transitionEnd", function () {
                t.loopFix();
              }),
            0 !== t.velocity)
          ) {
            if (
              ((g = r
                ? Math.abs((-w - t.translate) / t.velocity)
                : Math.abs((w - t.translate) / t.velocity)),
              i.freeModeSticky)
            ) {
              var P = Math.abs((r ? -w : w) - t.translate),
                k = t.slidesSizesGrid[t.activeIndex];
              g = P < k ? i.speed : P < 2 * k ? 1.5 * i.speed : 2.5 * i.speed;
            }
          } else if (i.freeModeSticky) return void t.slideToClosest();
          i.freeModeMomentumBounce && C
            ? (t.updateProgress(b),
              t.setTransition(g),
              t.setTranslate(w),
              t.transitionStart(!0, t.swipeDirection),
              (t.animating = !0),
              n.transitionEnd(function () {
                t &&
                  !t.destroyed &&
                  a.allowMomentumBounce &&
                  (t.emit("momentumBounce"),
                  t.setTransition(i.speed),
                  setTimeout(function () {
                    t.setTranslate(b),
                      n.transitionEnd(function () {
                        t && !t.destroyed && t.transitionEnd();
                      });
                  }, 0));
              }))
            : t.velocity
            ? (t.updateProgress(w),
              t.setTransition(g),
              t.setTranslate(w),
              t.transitionStart(!0, t.swipeDirection),
              t.animating ||
                ((t.animating = !0),
                n.transitionEnd(function () {
                  t && !t.destroyed && t.transitionEnd();
                })))
            : t.updateProgress(w),
            t.updateActiveIndex(),
            t.updateSlidesClasses();
        } else if (i.freeModeSticky) return void t.slideToClosest();
        (!i.freeModeMomentum || c >= i.longSwipesMs) &&
          (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses());
      } else {
        for (
          var L = 0, $ = t.slidesSizesGrid[0], I = 0;
          I < l.length;
          I += I < i.slidesPerGroupSkip ? 1 : i.slidesPerGroup
        ) {
          var O = I < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
          void 0 !== l[I + O]
            ? p >= l[I] && p < l[I + O] && ((L = I), ($ = l[I + O] - l[I]))
            : p >= l[I] && ((L = I), ($ = l[l.length - 1] - l[l.length - 2]));
        }
        var A = (p - l[L]) / $,
          D = L < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
        if (c > i.longSwipesMs) {
          if (!i.longSwipes) return void t.slideTo(t.activeIndex);
          "next" === t.swipeDirection &&
            (A >= i.longSwipesRatio ? t.slideTo(L + D) : t.slideTo(L)),
            "prev" === t.swipeDirection &&
              (A > 1 - i.longSwipesRatio ? t.slideTo(L + D) : t.slideTo(L));
        } else {
          if (!i.shortSwipes) return void t.slideTo(t.activeIndex);
          t.navigation &&
          (d.target === t.navigation.nextEl || d.target === t.navigation.prevEl)
            ? d.target === t.navigation.nextEl
              ? t.slideTo(L + D)
              : t.slideTo(L)
            : ("next" === t.swipeDirection && t.slideTo(L + D),
              "prev" === t.swipeDirection && t.slideTo(L));
        }
      }
  }
  function G() {
    var e = this,
      t = e.params,
      a = e.el;
    if (!a || 0 !== a.offsetWidth) {
      t.breakpoints && e.setBreakpoint();
      var i = e.allowSlideNext,
        s = e.allowSlidePrev,
        r = e.snapGrid;
      (e.allowSlideNext = !0),
        (e.allowSlidePrev = !0),
        e.updateSize(),
        e.updateSlides(),
        e.updateSlidesClasses(),
        ("auto" === t.slidesPerView || t.slidesPerView > 1) &&
        e.isEnd &&
        !e.isBeginning &&
        !e.params.centeredSlides
          ? e.slideTo(e.slides.length - 1, 0, !1, !0)
          : e.slideTo(e.activeIndex, 0, !1, !0),
        e.autoplay &&
          e.autoplay.running &&
          e.autoplay.paused &&
          e.autoplay.run(),
        (e.allowSlidePrev = s),
        (e.allowSlideNext = i),
        e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow();
    }
  }
  function N(e) {
    var t = this;
    t.allowClick ||
      (t.params.preventClicks && e.preventDefault(),
      t.params.preventClicksPropagation &&
        t.animating &&
        (e.stopPropagation(), e.stopImmediatePropagation()));
  }
  function B() {
    var e = this,
      t = e.wrapperEl,
      a = e.rtlTranslate;
    (e.previousTranslate = e.translate),
      e.isHorizontal()
        ? (e.translate = a
            ? t.scrollWidth - t.offsetWidth - t.scrollLeft
            : -t.scrollLeft)
        : (e.translate = -t.scrollTop),
      -0 === e.translate && (e.translate = 0),
      e.updateActiveIndex(),
      e.updateSlidesClasses();
    var i = e.maxTranslate() - e.minTranslate();
    (0 === i ? 0 : (e.translate - e.minTranslate()) / i) !== e.progress &&
      e.updateProgress(a ? -e.translate : e.translate),
      e.emit("setTranslate", e.translate, !1);
  }
  var H = !1;
  function X() {}
  var Y = {
      init: !0,
      direction: "horizontal",
      touchEventsTarget: "container",
      initialSlide: 0,
      speed: 300,
      cssMode: !1,
      updateOnWindowResize: !0,
      nested: !1,
      width: null,
      height: null,
      preventInteractionOnTransition: !1,
      userAgent: null,
      url: null,
      edgeSwipeDetection: !1,
      edgeSwipeThreshold: 20,
      freeMode: !1,
      freeModeMomentum: !0,
      freeModeMomentumRatio: 1,
      freeModeMomentumBounce: !0,
      freeModeMomentumBounceRatio: 1,
      freeModeMomentumVelocityRatio: 1,
      freeModeSticky: !1,
      freeModeMinimumVelocity: 0.02,
      autoHeight: !1,
      setWrapperSize: !1,
      virtualTranslate: !1,
      effect: "slide",
      breakpoints: void 0,
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerColumn: 1,
      slidesPerColumnFill: "column",
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      centeredSlides: !1,
      centeredSlidesBounds: !1,
      slidesOffsetBefore: 0,
      slidesOffsetAfter: 0,
      normalizeSlideIndex: !0,
      centerInsufficientSlides: !1,
      watchOverflow: !1,
      roundLengths: !1,
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: !0,
      shortSwipes: !0,
      longSwipes: !0,
      longSwipesRatio: 0.5,
      longSwipesMs: 300,
      followFinger: !0,
      allowTouchMove: !0,
      threshold: 0,
      touchMoveStopPropagation: !1,
      touchStartPreventDefault: !0,
      touchStartForcePreventDefault: !1,
      touchReleaseOnEdges: !1,
      uniqueNavElements: !0,
      resistance: !0,
      resistanceRatio: 0.85,
      watchSlidesProgress: !1,
      watchSlidesVisibility: !1,
      grabCursor: !1,
      preventClicks: !0,
      preventClicksPropagation: !0,
      slideToClickedSlide: !1,
      preloadImages: !0,
      updateOnImagesReady: !0,
      loop: !1,
      loopAdditionalSlides: 0,
      loopedSlides: null,
      loopFillGroupWithBlank: !1,
      loopPreventsSlide: !0,
      allowSlidePrev: !0,
      allowSlideNext: !0,
      swipeHandler: null,
      noSwiping: !0,
      noSwipingClass: "swiper-no-swiping",
      noSwipingSelector: null,
      passiveListeners: !0,
      containerModifierClass: "swiper-container-",
      slideClass: "swiper-slide",
      slideBlankClass: "swiper-slide-invisible-blank",
      slideActiveClass: "swiper-slide-active",
      slideDuplicateActiveClass: "swiper-slide-duplicate-active",
      slideVisibleClass: "swiper-slide-visible",
      slideDuplicateClass: "swiper-slide-duplicate",
      slideNextClass: "swiper-slide-next",
      slideDuplicateNextClass: "swiper-slide-duplicate-next",
      slidePrevClass: "swiper-slide-prev",
      slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
      wrapperClass: "swiper-wrapper",
      runCallbacksOnInit: !0,
      _emitClasses: !1,
    },
    V = {
      modular: {
        useParams: function (e) {
          var t = this;
          t.modules &&
            Object.keys(t.modules).forEach(function (a) {
              var i = t.modules[a];
              i.params && S(e, i.params);
            });
        },
        useModules: function (e) {
          void 0 === e && (e = {});
          var t = this;
          t.modules &&
            Object.keys(t.modules).forEach(function (a) {
              var i = t.modules[a],
                s = e[a] || {};
              i.on &&
                t.on &&
                Object.keys(i.on).forEach(function (e) {
                  t.on(e, i.on[e]);
                }),
                i.create && i.create.bind(t)(s);
            });
        },
      },
      eventsEmitter: {
        on: function (e, t, a) {
          var i = this;
          if ("function" != typeof t) return i;
          var s = a ? "unshift" : "push";
          return (
            e.split(" ").forEach(function (e) {
              i.eventsListeners[e] || (i.eventsListeners[e] = []),
                i.eventsListeners[e][s](t);
            }),
            i
          );
        },
        once: function (e, t, a) {
          var i = this;
          if ("function" != typeof t) return i;
          function s() {
            i.off(e, s), s.__emitterProxy && delete s.__emitterProxy;
            for (var a = arguments.length, r = new Array(a), n = 0; n < a; n++)
              r[n] = arguments[n];
            t.apply(i, r);
          }
          return (s.__emitterProxy = t), i.on(e, s, a);
        },
        onAny: function (e, t) {
          var a = this;
          if ("function" != typeof e) return a;
          var i = t ? "unshift" : "push";
          return (
            a.eventsAnyListeners.indexOf(e) < 0 && a.eventsAnyListeners[i](e), a
          );
        },
        offAny: function (e) {
          var t = this;
          if (!t.eventsAnyListeners) return t;
          var a = t.eventsAnyListeners.indexOf(e);
          return a >= 0 && t.eventsAnyListeners.splice(a, 1), t;
        },
        off: function (e, t) {
          var a = this;
          return a.eventsListeners
            ? (e.split(" ").forEach(function (e) {
                void 0 === t
                  ? (a.eventsListeners[e] = [])
                  : a.eventsListeners[e] &&
                    a.eventsListeners[e].forEach(function (i, s) {
                      (i === t ||
                        (i.__emitterProxy && i.__emitterProxy === t)) &&
                        a.eventsListeners[e].splice(s, 1);
                    });
              }),
              a)
            : a;
        },
        emit: function () {
          var e,
            t,
            a,
            i = this;
          if (!i.eventsListeners) return i;
          for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++)
            r[n] = arguments[n];
          "string" == typeof r[0] || Array.isArray(r[0])
            ? ((e = r[0]), (t = r.slice(1, r.length)), (a = i))
            : ((e = r[0].events), (t = r[0].data), (a = r[0].context || i)),
            t.unshift(a);
          var l = Array.isArray(e) ? e : e.split(" ");
          return (
            l.forEach(function (e) {
              i.eventsAnyListeners &&
                i.eventsAnyListeners.length &&
                i.eventsAnyListeners.forEach(function (i) {
                  i.apply(a, [e].concat(t));
                }),
                i.eventsListeners &&
                  i.eventsListeners[e] &&
                  i.eventsListeners[e].forEach(function (e) {
                    e.apply(a, t);
                  });
            }),
            i
          );
        },
      },
      update: {
        updateSize: function () {
          var e,
            t,
            a = this,
            i = a.$el;
          (e =
            void 0 !== a.params.width && null !== a.params.width
              ? a.params.width
              : i[0].clientWidth),
            (t =
              void 0 !== a.params.height && null !== a.params.height
                ? a.params.height
                : i[0].clientHeight),
            (0 === e && a.isHorizontal()) ||
              (0 === t && a.isVertical()) ||
              ((e =
                e -
                parseInt(i.css("padding-left") || 0, 10) -
                parseInt(i.css("padding-right") || 0, 10)),
              (t =
                t -
                parseInt(i.css("padding-top") || 0, 10) -
                parseInt(i.css("padding-bottom") || 0, 10)),
              Number.isNaN(e) && (e = 0),
              Number.isNaN(t) && (t = 0),
              S(a, { width: e, height: t, size: a.isHorizontal() ? e : t }));
        },
        updateSlides: function () {
          var e = this,
            t = l(),
            a = e.params,
            i = e.$wrapperEl,
            s = e.size,
            r = e.rtlTranslate,
            n = e.wrongRTL,
            o = e.virtual && a.virtual.enabled,
            d = o ? e.virtual.slides.length : e.slides.length,
            p = i.children("." + e.params.slideClass),
            u = o ? e.virtual.slides.length : p.length,
            c = [],
            h = [],
            v = [];
          function f(e, t) {
            return !a.cssMode || t !== p.length - 1;
          }
          var m = a.slidesOffsetBefore;
          "function" == typeof m && (m = a.slidesOffsetBefore.call(e));
          var g = a.slidesOffsetAfter;
          "function" == typeof g && (g = a.slidesOffsetAfter.call(e));
          var y = e.snapGrid.length,
            w = e.slidesGrid.length,
            b = a.spaceBetween,
            E = -m,
            x = 0,
            T = 0;
          if (void 0 !== s) {
            var C, M;
            "string" == typeof b &&
              b.indexOf("%") >= 0 &&
              (b = (parseFloat(b.replace("%", "")) / 100) * s),
              (e.virtualSize = -b),
              r
                ? p.css({ marginLeft: "", marginTop: "" })
                : p.css({ marginRight: "", marginBottom: "" }),
              a.slidesPerColumn > 1 &&
                ((C =
                  Math.floor(u / a.slidesPerColumn) ===
                  u / e.params.slidesPerColumn
                    ? u
                    : Math.ceil(u / a.slidesPerColumn) * a.slidesPerColumn),
                "auto" !== a.slidesPerView &&
                  "row" === a.slidesPerColumnFill &&
                  (C = Math.max(C, a.slidesPerView * a.slidesPerColumn)));
            for (
              var z,
                P = a.slidesPerColumn,
                k = C / P,
                L = Math.floor(u / a.slidesPerColumn),
                $ = 0;
              $ < u;
              $ += 1
            ) {
              M = 0;
              var I = p.eq($);
              if (a.slidesPerColumn > 1) {
                var O = void 0,
                  A = void 0,
                  D = void 0;
                if ("row" === a.slidesPerColumnFill && a.slidesPerGroup > 1) {
                  var G = Math.floor(
                      $ / (a.slidesPerGroup * a.slidesPerColumn)
                    ),
                    N = $ - a.slidesPerColumn * a.slidesPerGroup * G,
                    B =
                      0 === G
                        ? a.slidesPerGroup
                        : Math.min(
                            Math.ceil((u - G * P * a.slidesPerGroup) / P),
                            a.slidesPerGroup
                          );
                  (O =
                    (A =
                      N - (D = Math.floor(N / B)) * B + G * a.slidesPerGroup) +
                    (D * C) / P),
                    I.css({
                      "-webkit-box-ordinal-group": O,
                      "-moz-box-ordinal-group": O,
                      "-ms-flex-order": O,
                      "-webkit-order": O,
                      order: O,
                    });
                } else
                  "column" === a.slidesPerColumnFill
                    ? ((D = $ - (A = Math.floor($ / P)) * P),
                      (A > L || (A === L && D === P - 1)) &&
                        (D += 1) >= P &&
                        ((D = 0), (A += 1)))
                    : (A = $ - (D = Math.floor($ / k)) * k);
                I.css(
                  "margin-" + (e.isHorizontal() ? "top" : "left"),
                  0 !== D && a.spaceBetween && a.spaceBetween + "px"
                );
              }
              if ("none" !== I.css("display")) {
                if ("auto" === a.slidesPerView) {
                  var H = t.getComputedStyle(I[0], null),
                    X = I[0].style.transform,
                    Y = I[0].style.webkitTransform;
                  if (
                    (X && (I[0].style.transform = "none"),
                    Y && (I[0].style.webkitTransform = "none"),
                    a.roundLengths)
                  )
                    M = e.isHorizontal() ? I.outerWidth(!0) : I.outerHeight(!0);
                  else if (e.isHorizontal()) {
                    var V = parseFloat(H.getPropertyValue("width") || 0),
                      F = parseFloat(H.getPropertyValue("padding-left") || 0),
                      R = parseFloat(H.getPropertyValue("padding-right") || 0),
                      W = parseFloat(H.getPropertyValue("margin-left") || 0),
                      q = parseFloat(H.getPropertyValue("margin-right") || 0),
                      j = H.getPropertyValue("box-sizing");
                    if (j && "border-box" === j) M = V + W + q;
                    else {
                      var _ = I[0],
                        U = _.clientWidth;
                      M = V + F + R + W + q + (_.offsetWidth - U);
                    }
                  } else {
                    var K = parseFloat(H.getPropertyValue("height") || 0),
                      Z = parseFloat(H.getPropertyValue("padding-top") || 0),
                      J = parseFloat(H.getPropertyValue("padding-bottom") || 0),
                      Q = parseFloat(H.getPropertyValue("margin-top") || 0),
                      ee = parseFloat(H.getPropertyValue("margin-bottom") || 0),
                      te = H.getPropertyValue("box-sizing");
                    if (te && "border-box" === te) M = K + Q + ee;
                    else {
                      var ae = I[0],
                        ie = ae.clientHeight;
                      M = K + Z + J + Q + ee + (ae.offsetHeight - ie);
                    }
                  }
                  X && (I[0].style.transform = X),
                    Y && (I[0].style.webkitTransform = Y),
                    a.roundLengths && (M = Math.floor(M));
                } else
                  (M = (s - (a.slidesPerView - 1) * b) / a.slidesPerView),
                    a.roundLengths && (M = Math.floor(M)),
                    p[$] &&
                      (e.isHorizontal()
                        ? (p[$].style.width = M + "px")
                        : (p[$].style.height = M + "px"));
                p[$] && (p[$].swiperSlideSize = M),
                  v.push(M),
                  a.centeredSlides
                    ? ((E = E + M / 2 + x / 2 + b),
                      0 === x && 0 !== $ && (E = E - s / 2 - b),
                      0 === $ && (E = E - s / 2 - b),
                      Math.abs(E) < 0.001 && (E = 0),
                      a.roundLengths && (E = Math.floor(E)),
                      T % a.slidesPerGroup == 0 && c.push(E),
                      h.push(E))
                    : (a.roundLengths && (E = Math.floor(E)),
                      (T - Math.min(e.params.slidesPerGroupSkip, T)) %
                        e.params.slidesPerGroup ==
                        0 && c.push(E),
                      h.push(E),
                      (E = E + M + b)),
                  (e.virtualSize += M + b),
                  (x = M),
                  (T += 1);
              }
            }
            if (
              ((e.virtualSize = Math.max(e.virtualSize, s) + g),
              r &&
                n &&
                ("slide" === a.effect || "coverflow" === a.effect) &&
                i.css({ width: e.virtualSize + a.spaceBetween + "px" }),
              a.setWrapperSize &&
                (e.isHorizontal()
                  ? i.css({ width: e.virtualSize + a.spaceBetween + "px" })
                  : i.css({ height: e.virtualSize + a.spaceBetween + "px" })),
              a.slidesPerColumn > 1 &&
                ((e.virtualSize = (M + a.spaceBetween) * C),
                (e.virtualSize =
                  Math.ceil(e.virtualSize / a.slidesPerColumn) -
                  a.spaceBetween),
                e.isHorizontal()
                  ? i.css({ width: e.virtualSize + a.spaceBetween + "px" })
                  : i.css({ height: e.virtualSize + a.spaceBetween + "px" }),
                a.centeredSlides))
            ) {
              z = [];
              for (var se = 0; se < c.length; se += 1) {
                var re = c[se];
                a.roundLengths && (re = Math.floor(re)),
                  c[se] < e.virtualSize + c[0] && z.push(re);
              }
              c = z;
            }
            if (!a.centeredSlides) {
              z = [];
              for (var ne = 0; ne < c.length; ne += 1) {
                var le = c[ne];
                a.roundLengths && (le = Math.floor(le)),
                  c[ne] <= e.virtualSize - s && z.push(le);
              }
              (c = z),
                Math.floor(e.virtualSize - s) - Math.floor(c[c.length - 1]) >
                  1 && c.push(e.virtualSize - s);
            }
            if (
              (0 === c.length && (c = [0]),
              0 !== a.spaceBetween &&
                (e.isHorizontal()
                  ? r
                    ? p.filter(f).css({ marginLeft: b + "px" })
                    : p.filter(f).css({ marginRight: b + "px" })
                  : p.filter(f).css({ marginBottom: b + "px" })),
              a.centeredSlides && a.centeredSlidesBounds)
            ) {
              var oe = 0;
              v.forEach(function (e) {
                oe += e + (a.spaceBetween ? a.spaceBetween : 0);
              });
              var de = (oe -= a.spaceBetween) - s;
              c = c.map(function (e) {
                return e < 0 ? -m : e > de ? de + g : e;
              });
            }
            if (a.centerInsufficientSlides) {
              var pe = 0;
              if (
                (v.forEach(function (e) {
                  pe += e + (a.spaceBetween ? a.spaceBetween : 0);
                }),
                (pe -= a.spaceBetween) < s)
              ) {
                var ue = (s - pe) / 2;
                c.forEach(function (e, t) {
                  c[t] = e - ue;
                }),
                  h.forEach(function (e, t) {
                    h[t] = e + ue;
                  });
              }
            }
            S(e, { slides: p, snapGrid: c, slidesGrid: h, slidesSizesGrid: v }),
              u !== d && e.emit("slidesLengthChange"),
              c.length !== y &&
                (e.params.watchOverflow && e.checkOverflow(),
                e.emit("snapGridLengthChange")),
              h.length !== w && e.emit("slidesGridLengthChange"),
              (a.watchSlidesProgress || a.watchSlidesVisibility) &&
                e.updateSlidesOffset();
          }
        },
        updateAutoHeight: function (e) {
          var t,
            a = this,
            i = [],
            s = 0;
          if (
            ("number" == typeof e
              ? a.setTransition(e)
              : !0 === e && a.setTransition(a.params.speed),
            "auto" !== a.params.slidesPerView && a.params.slidesPerView > 1)
          )
            if (a.params.centeredSlides)
              a.visibleSlides.each(function (e) {
                i.push(e);
              });
            else
              for (t = 0; t < Math.ceil(a.params.slidesPerView); t += 1) {
                var r = a.activeIndex + t;
                if (r > a.slides.length) break;
                i.push(a.slides.eq(r)[0]);
              }
          else i.push(a.slides.eq(a.activeIndex)[0]);
          for (t = 0; t < i.length; t += 1)
            if (void 0 !== i[t]) {
              var n = i[t].offsetHeight;
              s = n > s ? n : s;
            }
          s && a.$wrapperEl.css("height", s + "px");
        },
        updateSlidesOffset: function () {
          for (var e = this.slides, t = 0; t < e.length; t += 1)
            e[t].swiperSlideOffset = this.isHorizontal()
              ? e[t].offsetLeft
              : e[t].offsetTop;
        },
        updateSlidesProgress: function (e) {
          void 0 === e && (e = (this && this.translate) || 0);
          var t = this,
            a = t.params,
            i = t.slides,
            s = t.rtlTranslate;
          if (0 !== i.length) {
            void 0 === i[0].swiperSlideOffset && t.updateSlidesOffset();
            var r = -e;
            s && (r = e),
              i.removeClass(a.slideVisibleClass),
              (t.visibleSlidesIndexes = []),
              (t.visibleSlides = []);
            for (var n = 0; n < i.length; n += 1) {
              var l = i[n],
                o =
                  (r +
                    (a.centeredSlides ? t.minTranslate() : 0) -
                    l.swiperSlideOffset) /
                  (l.swiperSlideSize + a.spaceBetween);
              if (
                a.watchSlidesVisibility ||
                (a.centeredSlides && a.autoHeight)
              ) {
                var d = -(r - l.swiperSlideOffset),
                  p = d + t.slidesSizesGrid[n];
                ((d >= 0 && d < t.size - 1) ||
                  (p > 1 && p <= t.size) ||
                  (d <= 0 && p >= t.size)) &&
                  (t.visibleSlides.push(l),
                  t.visibleSlidesIndexes.push(n),
                  i.eq(n).addClass(a.slideVisibleClass));
              }
              l.progress = s ? -o : o;
            }
            t.visibleSlides = m(t.visibleSlides);
          }
        },
        updateProgress: function (e) {
          var t = this;
          if (void 0 === e) {
            var a = t.rtlTranslate ? -1 : 1;
            e = (t && t.translate && t.translate * a) || 0;
          }
          var i = t.params,
            s = t.maxTranslate() - t.minTranslate(),
            r = t.progress,
            n = t.isBeginning,
            l = t.isEnd,
            o = n,
            d = l;
          0 === s
            ? ((r = 0), (n = !0), (l = !0))
            : ((n = (r = (e - t.minTranslate()) / s) <= 0), (l = r >= 1)),
            S(t, { progress: r, isBeginning: n, isEnd: l }),
            (i.watchSlidesProgress ||
              i.watchSlidesVisibility ||
              (i.centeredSlides && i.autoHeight)) &&
              t.updateSlidesProgress(e),
            n && !o && t.emit("reachBeginning toEdge"),
            l && !d && t.emit("reachEnd toEdge"),
            ((o && !n) || (d && !l)) && t.emit("fromEdge"),
            t.emit("progress", r);
        },
        updateSlidesClasses: function () {
          var e,
            t = this,
            a = t.slides,
            i = t.params,
            s = t.$wrapperEl,
            r = t.activeIndex,
            n = t.realIndex,
            l = t.virtual && i.virtual.enabled;
          a.removeClass(
            i.slideActiveClass +
              " " +
              i.slideNextClass +
              " " +
              i.slidePrevClass +
              " " +
              i.slideDuplicateActiveClass +
              " " +
              i.slideDuplicateNextClass +
              " " +
              i.slideDuplicatePrevClass
          ),
            (e = l
              ? t.$wrapperEl.find(
                  "." + i.slideClass + '[data-swiper-slide-index="' + r + '"]'
                )
              : a.eq(r)).addClass(i.slideActiveClass),
            i.loop &&
              (e.hasClass(i.slideDuplicateClass)
                ? s
                    .children(
                      "." +
                        i.slideClass +
                        ":not(." +
                        i.slideDuplicateClass +
                        ')[data-swiper-slide-index="' +
                        n +
                        '"]'
                    )
                    .addClass(i.slideDuplicateActiveClass)
                : s
                    .children(
                      "." +
                        i.slideClass +
                        "." +
                        i.slideDuplicateClass +
                        '[data-swiper-slide-index="' +
                        n +
                        '"]'
                    )
                    .addClass(i.slideDuplicateActiveClass));
          var o = e
            .nextAll("." + i.slideClass)
            .eq(0)
            .addClass(i.slideNextClass);
          i.loop && 0 === o.length && (o = a.eq(0)).addClass(i.slideNextClass);
          var d = e
            .prevAll("." + i.slideClass)
            .eq(0)
            .addClass(i.slidePrevClass);
          i.loop && 0 === d.length && (d = a.eq(-1)).addClass(i.slidePrevClass),
            i.loop &&
              (o.hasClass(i.slideDuplicateClass)
                ? s
                    .children(
                      "." +
                        i.slideClass +
                        ":not(." +
                        i.slideDuplicateClass +
                        ')[data-swiper-slide-index="' +
                        o.attr("data-swiper-slide-index") +
                        '"]'
                    )
                    .addClass(i.slideDuplicateNextClass)
                : s
                    .children(
                      "." +
                        i.slideClass +
                        "." +
                        i.slideDuplicateClass +
                        '[data-swiper-slide-index="' +
                        o.attr("data-swiper-slide-index") +
                        '"]'
                    )
                    .addClass(i.slideDuplicateNextClass),
              d.hasClass(i.slideDuplicateClass)
                ? s
                    .children(
                      "." +
                        i.slideClass +
                        ":not(." +
                        i.slideDuplicateClass +
                        ')[data-swiper-slide-index="' +
                        d.attr("data-swiper-slide-index") +
                        '"]'
                    )
                    .addClass(i.slideDuplicatePrevClass)
                : s
                    .children(
                      "." +
                        i.slideClass +
                        "." +
                        i.slideDuplicateClass +
                        '[data-swiper-slide-index="' +
                        d.attr("data-swiper-slide-index") +
                        '"]'
                    )
                    .addClass(i.slideDuplicatePrevClass)),
            t.emitSlidesClasses();
        },
        updateActiveIndex: function (e) {
          var t,
            a = this,
            i = a.rtlTranslate ? a.translate : -a.translate,
            s = a.slidesGrid,
            r = a.snapGrid,
            n = a.params,
            l = a.activeIndex,
            o = a.realIndex,
            d = a.snapIndex,
            p = e;
          if (void 0 === p) {
            for (var u = 0; u < s.length; u += 1)
              void 0 !== s[u + 1]
                ? i >= s[u] && i < s[u + 1] - (s[u + 1] - s[u]) / 2
                  ? (p = u)
                  : i >= s[u] && i < s[u + 1] && (p = u + 1)
                : i >= s[u] && (p = u);
            n.normalizeSlideIndex && (p < 0 || void 0 === p) && (p = 0);
          }
          if (r.indexOf(i) >= 0) t = r.indexOf(i);
          else {
            var c = Math.min(n.slidesPerGroupSkip, p);
            t = c + Math.floor((p - c) / n.slidesPerGroup);
          }
          if ((t >= r.length && (t = r.length - 1), p !== l)) {
            var h = parseInt(
              a.slides.eq(p).attr("data-swiper-slide-index") || p,
              10
            );
            S(a, {
              snapIndex: t,
              realIndex: h,
              previousIndex: l,
              activeIndex: p,
            }),
              a.emit("activeIndexChange"),
              a.emit("snapIndexChange"),
              o !== h && a.emit("realIndexChange"),
              (a.initialized || a.params.runCallbacksOnInit) &&
                a.emit("slideChange");
          } else t !== d && ((a.snapIndex = t), a.emit("snapIndexChange"));
        },
        updateClickedSlide: function (e) {
          var t = this,
            a = t.params,
            i = m(e.target).closest("." + a.slideClass)[0],
            s = !1;
          if (i)
            for (var r = 0; r < t.slides.length; r += 1)
              t.slides[r] === i && (s = !0);
          if (!i || !s)
            return (t.clickedSlide = void 0), void (t.clickedIndex = void 0);
          (t.clickedSlide = i),
            t.virtual && t.params.virtual.enabled
              ? (t.clickedIndex = parseInt(
                  m(i).attr("data-swiper-slide-index"),
                  10
                ))
              : (t.clickedIndex = m(i).index()),
            a.slideToClickedSlide &&
              void 0 !== t.clickedIndex &&
              t.clickedIndex !== t.activeIndex &&
              t.slideToClickedSlide();
        },
      },
      translate: {
        getTranslate: function (e) {
          void 0 === e && (e = this.isHorizontal() ? "x" : "y");
          var t = this,
            a = t.params,
            i = t.rtlTranslate,
            s = t.translate,
            r = t.$wrapperEl;
          if (a.virtualTranslate) return i ? -s : s;
          if (a.cssMode) return s;
          var n = T(r[0], e);
          return i && (n = -n), n || 0;
        },
        setTranslate: function (e, t) {
          var a = this,
            i = a.rtlTranslate,
            s = a.params,
            r = a.$wrapperEl,
            n = a.wrapperEl,
            l = a.progress,
            o = 0,
            d = 0;
          a.isHorizontal() ? (o = i ? -e : e) : (d = e),
            s.roundLengths && ((o = Math.floor(o)), (d = Math.floor(d))),
            s.cssMode
              ? (n[
                  a.isHorizontal() ? "scrollLeft" : "scrollTop"
                ] = a.isHorizontal() ? -o : -d)
              : s.virtualTranslate ||
                r.transform("translate3d(" + o + "px, " + d + "px, 0px)"),
            (a.previousTranslate = a.translate),
            (a.translate = a.isHorizontal() ? o : d);
          var p = a.maxTranslate() - a.minTranslate();
          (0 === p ? 0 : (e - a.minTranslate()) / p) !== l &&
            a.updateProgress(e),
            a.emit("setTranslate", a.translate, t);
        },
        minTranslate: function () {
          return -this.snapGrid[0];
        },
        maxTranslate: function () {
          return -this.snapGrid[this.snapGrid.length - 1];
        },
        translateTo: function (e, t, a, i, s) {
          void 0 === e && (e = 0),
            void 0 === t && (t = this.params.speed),
            void 0 === a && (a = !0),
            void 0 === i && (i = !0);
          var r = this,
            n = r.params,
            l = r.wrapperEl;
          if (r.animating && n.preventInteractionOnTransition) return !1;
          var o,
            d = r.minTranslate(),
            p = r.maxTranslate();
          if (
            ((o = i && e > d ? d : i && e < p ? p : e),
            r.updateProgress(o),
            n.cssMode)
          ) {
            var u,
              c = r.isHorizontal();
            if (0 === t) l[c ? "scrollLeft" : "scrollTop"] = -o;
            else if (l.scrollTo)
              l.scrollTo(
                (((u = {})[c ? "left" : "top"] = -o),
                (u.behavior = "smooth"),
                u)
              );
            else l[c ? "scrollLeft" : "scrollTop"] = -o;
            return !0;
          }
          return (
            0 === t
              ? (r.setTransition(0),
                r.setTranslate(o),
                a &&
                  (r.emit("beforeTransitionStart", t, s),
                  r.emit("transitionEnd")))
              : (r.setTransition(t),
                r.setTranslate(o),
                a &&
                  (r.emit("beforeTransitionStart", t, s),
                  r.emit("transitionStart")),
                r.animating ||
                  ((r.animating = !0),
                  r.onTranslateToWrapperTransitionEnd ||
                    (r.onTranslateToWrapperTransitionEnd = function (e) {
                      r &&
                        !r.destroyed &&
                        e.target === this &&
                        (r.$wrapperEl[0].removeEventListener(
                          "transitionend",
                          r.onTranslateToWrapperTransitionEnd
                        ),
                        r.$wrapperEl[0].removeEventListener(
                          "webkitTransitionEnd",
                          r.onTranslateToWrapperTransitionEnd
                        ),
                        (r.onTranslateToWrapperTransitionEnd = null),
                        delete r.onTranslateToWrapperTransitionEnd,
                        a && r.emit("transitionEnd"));
                    }),
                  r.$wrapperEl[0].addEventListener(
                    "transitionend",
                    r.onTranslateToWrapperTransitionEnd
                  ),
                  r.$wrapperEl[0].addEventListener(
                    "webkitTransitionEnd",
                    r.onTranslateToWrapperTransitionEnd
                  ))),
            !0
          );
        },
      },
      transition: {
        setTransition: function (e, t) {
          var a = this;
          a.params.cssMode || a.$wrapperEl.transition(e),
            a.emit("setTransition", e, t);
        },
        transitionStart: function (e, t) {
          void 0 === e && (e = !0);
          var a = this,
            i = a.activeIndex,
            s = a.params,
            r = a.previousIndex;
          if (!s.cssMode) {
            s.autoHeight && a.updateAutoHeight();
            var n = t;
            if (
              (n || (n = i > r ? "next" : i < r ? "prev" : "reset"),
              a.emit("transitionStart"),
              e && i !== r)
            ) {
              if ("reset" === n)
                return void a.emit("slideResetTransitionStart");
              a.emit("slideChangeTransitionStart"),
                "next" === n
                  ? a.emit("slideNextTransitionStart")
                  : a.emit("slidePrevTransitionStart");
            }
          }
        },
        transitionEnd: function (e, t) {
          void 0 === e && (e = !0);
          var a = this,
            i = a.activeIndex,
            s = a.previousIndex,
            r = a.params;
          if (((a.animating = !1), !r.cssMode)) {
            a.setTransition(0);
            var n = t;
            if (
              (n || (n = i > s ? "next" : i < s ? "prev" : "reset"),
              a.emit("transitionEnd"),
              e && i !== s)
            ) {
              if ("reset" === n) return void a.emit("slideResetTransitionEnd");
              a.emit("slideChangeTransitionEnd"),
                "next" === n
                  ? a.emit("slideNextTransitionEnd")
                  : a.emit("slidePrevTransitionEnd");
            }
          }
        },
      },
      slide: {
        slideTo: function (e, t, a, i) {
          if (
            (void 0 === e && (e = 0),
            void 0 === t && (t = this.params.speed),
            void 0 === a && (a = !0),
            "number" != typeof e && "string" != typeof e)
          )
            throw new Error(
              "The 'index' argument cannot have type other than 'number' or 'string'. [" +
                typeof e +
                "] given."
            );
          if ("string" == typeof e) {
            var s = parseInt(e, 10);
            if (!isFinite(s))
              throw new Error(
                "The passed-in 'index' (string) couldn't be converted to 'number'. [" +
                  e +
                  "] given."
              );
            e = s;
          }
          var r = this,
            n = e;
          n < 0 && (n = 0);
          var l = r.params,
            o = r.snapGrid,
            d = r.slidesGrid,
            p = r.previousIndex,
            u = r.activeIndex,
            c = r.rtlTranslate,
            h = r.wrapperEl;
          if (r.animating && l.preventInteractionOnTransition) return !1;
          var v = Math.min(r.params.slidesPerGroupSkip, n),
            f = v + Math.floor((n - v) / r.params.slidesPerGroup);
          f >= o.length && (f = o.length - 1),
            (u || l.initialSlide || 0) === (p || 0) &&
              a &&
              r.emit("beforeSlideChangeStart");
          var m,
            g = -o[f];
          if ((r.updateProgress(g), l.normalizeSlideIndex))
            for (var y = 0; y < d.length; y += 1)
              -Math.floor(100 * g) >= Math.floor(100 * d[y]) && (n = y);
          if (r.initialized && n !== u) {
            if (!r.allowSlideNext && g < r.translate && g < r.minTranslate())
              return !1;
            if (
              !r.allowSlidePrev &&
              g > r.translate &&
              g > r.maxTranslate() &&
              (u || 0) !== n
            )
              return !1;
          }
          if (
            ((m = n > u ? "next" : n < u ? "prev" : "reset"),
            (c && -g === r.translate) || (!c && g === r.translate))
          )
            return (
              r.updateActiveIndex(n),
              l.autoHeight && r.updateAutoHeight(),
              r.updateSlidesClasses(),
              "slide" !== l.effect && r.setTranslate(g),
              "reset" !== m && (r.transitionStart(a, m), r.transitionEnd(a, m)),
              !1
            );
          if (l.cssMode) {
            var w,
              b = r.isHorizontal(),
              E = -g;
            if ((c && (E = h.scrollWidth - h.offsetWidth - E), 0 === t))
              h[b ? "scrollLeft" : "scrollTop"] = E;
            else if (h.scrollTo)
              h.scrollTo(
                (((w = {})[b ? "left" : "top"] = E), (w.behavior = "smooth"), w)
              );
            else h[b ? "scrollLeft" : "scrollTop"] = E;
            return !0;
          }
          return (
            0 === t
              ? (r.setTransition(0),
                r.setTranslate(g),
                r.updateActiveIndex(n),
                r.updateSlidesClasses(),
                r.emit("beforeTransitionStart", t, i),
                r.transitionStart(a, m),
                r.transitionEnd(a, m))
              : (r.setTransition(t),
                r.setTranslate(g),
                r.updateActiveIndex(n),
                r.updateSlidesClasses(),
                r.emit("beforeTransitionStart", t, i),
                r.transitionStart(a, m),
                r.animating ||
                  ((r.animating = !0),
                  r.onSlideToWrapperTransitionEnd ||
                    (r.onSlideToWrapperTransitionEnd = function (e) {
                      r &&
                        !r.destroyed &&
                        e.target === this &&
                        (r.$wrapperEl[0].removeEventListener(
                          "transitionend",
                          r.onSlideToWrapperTransitionEnd
                        ),
                        r.$wrapperEl[0].removeEventListener(
                          "webkitTransitionEnd",
                          r.onSlideToWrapperTransitionEnd
                        ),
                        (r.onSlideToWrapperTransitionEnd = null),
                        delete r.onSlideToWrapperTransitionEnd,
                        r.transitionEnd(a, m));
                    }),
                  r.$wrapperEl[0].addEventListener(
                    "transitionend",
                    r.onSlideToWrapperTransitionEnd
                  ),
                  r.$wrapperEl[0].addEventListener(
                    "webkitTransitionEnd",
                    r.onSlideToWrapperTransitionEnd
                  ))),
            !0
          );
        },
        slideToLoop: function (e, t, a, i) {
          void 0 === e && (e = 0),
            void 0 === t && (t = this.params.speed),
            void 0 === a && (a = !0);
          var s = this,
            r = e;
          return s.params.loop && (r += s.loopedSlides), s.slideTo(r, t, a, i);
        },
        slideNext: function (e, t, a) {
          void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);
          var i = this,
            s = i.params,
            r = i.animating,
            n = i.activeIndex < s.slidesPerGroupSkip ? 1 : s.slidesPerGroup;
          if (s.loop) {
            if (r && s.loopPreventsSlide) return !1;
            i.loopFix(), (i._clientLeft = i.$wrapperEl[0].clientLeft);
          }
          return i.slideTo(i.activeIndex + n, e, t, a);
        },
        slidePrev: function (e, t, a) {
          void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);
          var i = this,
            s = i.params,
            r = i.animating,
            n = i.snapGrid,
            l = i.slidesGrid,
            o = i.rtlTranslate;
          if (s.loop) {
            if (r && s.loopPreventsSlide) return !1;
            i.loopFix(), (i._clientLeft = i.$wrapperEl[0].clientLeft);
          }
          function d(e) {
            return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e);
          }
          var p,
            u = d(o ? i.translate : -i.translate),
            c = n.map(function (e) {
              return d(e);
            }),
            h = (n[c.indexOf(u)], n[c.indexOf(u) - 1]);
          return (
            void 0 === h &&
              s.cssMode &&
              n.forEach(function (e) {
                !h && u >= e && (h = e);
              }),
            void 0 !== h && (p = l.indexOf(h)) < 0 && (p = i.activeIndex - 1),
            i.slideTo(p, e, t, a)
          );
        },
        slideReset: function (e, t, a) {
          return (
            void 0 === e && (e = this.params.speed),
            void 0 === t && (t = !0),
            this.slideTo(this.activeIndex, e, t, a)
          );
        },
        slideToClosest: function (e, t, a, i) {
          void 0 === e && (e = this.params.speed),
            void 0 === t && (t = !0),
            void 0 === i && (i = 0.5);
          var s = this,
            r = s.activeIndex,
            n = Math.min(s.params.slidesPerGroupSkip, r),
            l = n + Math.floor((r - n) / s.params.slidesPerGroup),
            o = s.rtlTranslate ? s.translate : -s.translate;
          if (o >= s.snapGrid[l]) {
            var d = s.snapGrid[l];
            o - d > (s.snapGrid[l + 1] - d) * i &&
              (r += s.params.slidesPerGroup);
          } else {
            var p = s.snapGrid[l - 1];
            o - p <= (s.snapGrid[l] - p) * i && (r -= s.params.slidesPerGroup);
          }
          return (
            (r = Math.max(r, 0)),
            (r = Math.min(r, s.slidesGrid.length - 1)),
            s.slideTo(r, e, t, a)
          );
        },
        slideToClickedSlide: function () {
          var e,
            t = this,
            a = t.params,
            i = t.$wrapperEl,
            s =
              "auto" === a.slidesPerView
                ? t.slidesPerViewDynamic()
                : a.slidesPerView,
            r = t.clickedIndex;
          if (a.loop) {
            if (t.animating) return;
            (e = parseInt(
              m(t.clickedSlide).attr("data-swiper-slide-index"),
              10
            )),
              a.centeredSlides
                ? r < t.loopedSlides - s / 2 ||
                  r > t.slides.length - t.loopedSlides + s / 2
                  ? (t.loopFix(),
                    (r = i
                      .children(
                        "." +
                          a.slideClass +
                          '[data-swiper-slide-index="' +
                          e +
                          '"]:not(.' +
                          a.slideDuplicateClass +
                          ")"
                      )
                      .eq(0)
                      .index()),
                    E(function () {
                      t.slideTo(r);
                    }))
                  : t.slideTo(r)
                : r > t.slides.length - s
                ? (t.loopFix(),
                  (r = i
                    .children(
                      "." +
                        a.slideClass +
                        '[data-swiper-slide-index="' +
                        e +
                        '"]:not(.' +
                        a.slideDuplicateClass +
                        ")"
                    )
                    .eq(0)
                    .index()),
                  E(function () {
                    t.slideTo(r);
                  }))
                : t.slideTo(r);
          } else t.slideTo(r);
        },
      },
      loop: {
        loopCreate: function () {
          var e = this,
            t = r(),
            a = e.params,
            i = e.$wrapperEl;
          i.children("." + a.slideClass + "." + a.slideDuplicateClass).remove();
          var s = i.children("." + a.slideClass);
          if (a.loopFillGroupWithBlank) {
            var n = a.slidesPerGroup - (s.length % a.slidesPerGroup);
            if (n !== a.slidesPerGroup) {
              for (var l = 0; l < n; l += 1) {
                var o = m(t.createElement("div")).addClass(
                  a.slideClass + " " + a.slideBlankClass
                );
                i.append(o);
              }
              s = i.children("." + a.slideClass);
            }
          }
          "auto" !== a.slidesPerView ||
            a.loopedSlides ||
            (a.loopedSlides = s.length),
            (e.loopedSlides = Math.ceil(
              parseFloat(a.loopedSlides || a.slidesPerView, 10)
            )),
            (e.loopedSlides += a.loopAdditionalSlides),
            e.loopedSlides > s.length && (e.loopedSlides = s.length);
          var d = [],
            p = [];
          s.each(function (t, a) {
            var i = m(t);
            a < e.loopedSlides && p.push(t),
              a < s.length && a >= s.length - e.loopedSlides && d.push(t),
              i.attr("data-swiper-slide-index", a);
          });
          for (var u = 0; u < p.length; u += 1)
            i.append(m(p[u].cloneNode(!0)).addClass(a.slideDuplicateClass));
          for (var c = d.length - 1; c >= 0; c -= 1)
            i.prepend(m(d[c].cloneNode(!0)).addClass(a.slideDuplicateClass));
        },
        loopFix: function () {
          var e = this;
          e.emit("beforeLoopFix");
          var t,
            a = e.activeIndex,
            i = e.slides,
            s = e.loopedSlides,
            r = e.allowSlidePrev,
            n = e.allowSlideNext,
            l = e.snapGrid,
            o = e.rtlTranslate;
          (e.allowSlidePrev = !0), (e.allowSlideNext = !0);
          var d = -l[a] - e.getTranslate();
          if (a < s)
            (t = i.length - 3 * s + a),
              (t += s),
              e.slideTo(t, 0, !1, !0) &&
                0 !== d &&
                e.setTranslate((o ? -e.translate : e.translate) - d);
          else if (a >= i.length - s) {
            (t = -i.length + a + s),
              (t += s),
              e.slideTo(t, 0, !1, !0) &&
                0 !== d &&
                e.setTranslate((o ? -e.translate : e.translate) - d);
          }
          (e.allowSlidePrev = r), (e.allowSlideNext = n), e.emit("loopFix");
        },
        loopDestroy: function () {
          var e = this,
            t = e.$wrapperEl,
            a = e.params,
            i = e.slides;
          t
            .children(
              "." +
                a.slideClass +
                "." +
                a.slideDuplicateClass +
                ",." +
                a.slideClass +
                "." +
                a.slideBlankClass
            )
            .remove(),
            i.removeAttr("data-swiper-slide-index");
        },
      },
      grabCursor: {
        setGrabCursor: function (e) {
          var t = this;
          if (
            !(
              t.support.touch ||
              !t.params.simulateTouch ||
              (t.params.watchOverflow && t.isLocked) ||
              t.params.cssMode
            )
          ) {
            var a = t.el;
            (a.style.cursor = "move"),
              (a.style.cursor = e ? "-webkit-grabbing" : "-webkit-grab"),
              (a.style.cursor = e ? "-moz-grabbin" : "-moz-grab"),
              (a.style.cursor = e ? "grabbing" : "grab");
          }
        },
        unsetGrabCursor: function () {
          var e = this;
          e.support.touch ||
            (e.params.watchOverflow && e.isLocked) ||
            e.params.cssMode ||
            (e.el.style.cursor = "");
        },
      },
      manipulation: {
        appendSlide: function (e) {
          var t = this,
            a = t.$wrapperEl,
            i = t.params;
          if (
            (i.loop && t.loopDestroy(), "object" == typeof e && "length" in e)
          )
            for (var s = 0; s < e.length; s += 1) e[s] && a.append(e[s]);
          else a.append(e);
          i.loop && t.loopCreate(),
            (i.observer && t.support.observer) || t.update();
        },
        prependSlide: function (e) {
          var t = this,
            a = t.params,
            i = t.$wrapperEl,
            s = t.activeIndex;
          a.loop && t.loopDestroy();
          var r = s + 1;
          if ("object" == typeof e && "length" in e) {
            for (var n = 0; n < e.length; n += 1) e[n] && i.prepend(e[n]);
            r = s + e.length;
          } else i.prepend(e);
          a.loop && t.loopCreate(),
            (a.observer && t.support.observer) || t.update(),
            t.slideTo(r, 0, !1);
        },
        addSlide: function (e, t) {
          var a = this,
            i = a.$wrapperEl,
            s = a.params,
            r = a.activeIndex;
          s.loop &&
            ((r -= a.loopedSlides),
            a.loopDestroy(),
            (a.slides = i.children("." + s.slideClass)));
          var n = a.slides.length;
          if (e <= 0) a.prependSlide(t);
          else if (e >= n) a.appendSlide(t);
          else {
            for (var l = r > e ? r + 1 : r, o = [], d = n - 1; d >= e; d -= 1) {
              var p = a.slides.eq(d);
              p.remove(), o.unshift(p);
            }
            if ("object" == typeof t && "length" in t) {
              for (var u = 0; u < t.length; u += 1) t[u] && i.append(t[u]);
              l = r > e ? r + t.length : r;
            } else i.append(t);
            for (var c = 0; c < o.length; c += 1) i.append(o[c]);
            s.loop && a.loopCreate(),
              (s.observer && a.support.observer) || a.update(),
              s.loop
                ? a.slideTo(l + a.loopedSlides, 0, !1)
                : a.slideTo(l, 0, !1);
          }
        },
        removeSlide: function (e) {
          var t = this,
            a = t.params,
            i = t.$wrapperEl,
            s = t.activeIndex;
          a.loop &&
            ((s -= t.loopedSlides),
            t.loopDestroy(),
            (t.slides = i.children("." + a.slideClass)));
          var r,
            n = s;
          if ("object" == typeof e && "length" in e) {
            for (var l = 0; l < e.length; l += 1)
              (r = e[l]),
                t.slides[r] && t.slides.eq(r).remove(),
                r < n && (n -= 1);
            n = Math.max(n, 0);
          } else
            (r = e),
              t.slides[r] && t.slides.eq(r).remove(),
              r < n && (n -= 1),
              (n = Math.max(n, 0));
          a.loop && t.loopCreate(),
            (a.observer && t.support.observer) || t.update(),
            a.loop ? t.slideTo(n + t.loopedSlides, 0, !1) : t.slideTo(n, 0, !1);
        },
        removeAllSlides: function () {
          for (var e = [], t = 0; t < this.slides.length; t += 1) e.push(t);
          this.removeSlide(e);
        },
      },
      events: {
        attachEvents: function () {
          var e = this,
            t = r(),
            a = e.params,
            i = e.touchEvents,
            s = e.el,
            n = e.wrapperEl,
            l = e.device,
            o = e.support;
          (e.onTouchStart = O.bind(e)),
            (e.onTouchMove = A.bind(e)),
            (e.onTouchEnd = D.bind(e)),
            a.cssMode && (e.onScroll = B.bind(e)),
            (e.onClick = N.bind(e));
          var d = !!a.nested;
          if (!o.touch && o.pointerEvents)
            s.addEventListener(i.start, e.onTouchStart, !1),
              t.addEventListener(i.move, e.onTouchMove, d),
              t.addEventListener(i.end, e.onTouchEnd, !1);
          else {
            if (o.touch) {
              var p = !(
                "touchstart" !== i.start ||
                !o.passiveListener ||
                !a.passiveListeners
              ) && { passive: !0, capture: !1 };
              s.addEventListener(i.start, e.onTouchStart, p),
                s.addEventListener(
                  i.move,
                  e.onTouchMove,
                  o.passiveListener ? { passive: !1, capture: d } : d
                ),
                s.addEventListener(i.end, e.onTouchEnd, p),
                i.cancel && s.addEventListener(i.cancel, e.onTouchEnd, p),
                H || (t.addEventListener("touchstart", X), (H = !0));
            }
            ((a.simulateTouch && !l.ios && !l.android) ||
              (a.simulateTouch && !o.touch && l.ios)) &&
              (s.addEventListener("mousedown", e.onTouchStart, !1),
              t.addEventListener("mousemove", e.onTouchMove, d),
              t.addEventListener("mouseup", e.onTouchEnd, !1));
          }
          (a.preventClicks || a.preventClicksPropagation) &&
            s.addEventListener("click", e.onClick, !0),
            a.cssMode && n.addEventListener("scroll", e.onScroll),
            a.updateOnWindowResize
              ? e.on(
                  l.ios || l.android
                    ? "resize orientationchange observerUpdate"
                    : "resize observerUpdate",
                  G,
                  !0
                )
              : e.on("observerUpdate", G, !0);
        },
        detachEvents: function () {
          var e = this,
            t = r(),
            a = e.params,
            i = e.touchEvents,
            s = e.el,
            n = e.wrapperEl,
            l = e.device,
            o = e.support,
            d = !!a.nested;
          if (!o.touch && o.pointerEvents)
            s.removeEventListener(i.start, e.onTouchStart, !1),
              t.removeEventListener(i.move, e.onTouchMove, d),
              t.removeEventListener(i.end, e.onTouchEnd, !1);
          else {
            if (o.touch) {
              var p = !(
                "onTouchStart" !== i.start ||
                !o.passiveListener ||
                !a.passiveListeners
              ) && { passive: !0, capture: !1 };
              s.removeEventListener(i.start, e.onTouchStart, p),
                s.removeEventListener(i.move, e.onTouchMove, d),
                s.removeEventListener(i.end, e.onTouchEnd, p),
                i.cancel && s.removeEventListener(i.cancel, e.onTouchEnd, p);
            }
            ((a.simulateTouch && !l.ios && !l.android) ||
              (a.simulateTouch && !o.touch && l.ios)) &&
              (s.removeEventListener("mousedown", e.onTouchStart, !1),
              t.removeEventListener("mousemove", e.onTouchMove, d),
              t.removeEventListener("mouseup", e.onTouchEnd, !1));
          }
          (a.preventClicks || a.preventClicksPropagation) &&
            s.removeEventListener("click", e.onClick, !0),
            a.cssMode && n.removeEventListener("scroll", e.onScroll),
            e.off(
              l.ios || l.android
                ? "resize orientationchange observerUpdate"
                : "resize observerUpdate",
              G
            );
        },
      },
      breakpoints: {
        setBreakpoint: function () {
          var e = this,
            t = e.activeIndex,
            a = e.initialized,
            i = e.loopedSlides,
            s = void 0 === i ? 0 : i,
            r = e.params,
            n = e.$el,
            l = r.breakpoints;
          if (l && (!l || 0 !== Object.keys(l).length)) {
            var o = e.getBreakpoint(l);
            if (o && e.currentBreakpoint !== o) {
              var d = o in l ? l[o] : void 0;
              d &&
                [
                  "slidesPerView",
                  "spaceBetween",
                  "slidesPerGroup",
                  "slidesPerGroupSkip",
                  "slidesPerColumn",
                ].forEach(function (e) {
                  var t = d[e];
                  void 0 !== t &&
                    (d[e] =
                      "slidesPerView" !== e || ("AUTO" !== t && "auto" !== t)
                        ? "slidesPerView" === e
                          ? parseFloat(t)
                          : parseInt(t, 10)
                        : "auto");
                });
              var p = d || e.originalParams,
                u = r.slidesPerColumn > 1,
                c = p.slidesPerColumn > 1;
              u && !c
                ? (n.removeClass(
                    r.containerModifierClass +
                      "multirow " +
                      r.containerModifierClass +
                      "multirow-column"
                  ),
                  e.emitContainerClasses())
                : !u &&
                  c &&
                  (n.addClass(r.containerModifierClass + "multirow"),
                  "column" === p.slidesPerColumnFill &&
                    n.addClass(r.containerModifierClass + "multirow-column"),
                  e.emitContainerClasses());
              var h = p.direction && p.direction !== r.direction,
                v = r.loop && (p.slidesPerView !== r.slidesPerView || h);
              h && a && e.changeDirection(),
                S(e.params, p),
                S(e, {
                  allowTouchMove: e.params.allowTouchMove,
                  allowSlideNext: e.params.allowSlideNext,
                  allowSlidePrev: e.params.allowSlidePrev,
                }),
                (e.currentBreakpoint = o),
                e.emit("_beforeBreakpoint", p),
                v &&
                  a &&
                  (e.loopDestroy(),
                  e.loopCreate(),
                  e.updateSlides(),
                  e.slideTo(t - s + e.loopedSlides, 0, !1)),
                e.emit("breakpoint", p);
            }
          }
        },
        getBreakpoint: function (e) {
          var t = l();
          if (e) {
            var a = !1,
              i = Object.keys(e).map(function (e) {
                if ("string" == typeof e && 0 === e.indexOf("@")) {
                  var a = parseFloat(e.substr(1));
                  return { value: t.innerHeight * a, point: e };
                }
                return { value: e, point: e };
              });
            i.sort(function (e, t) {
              return parseInt(e.value, 10) - parseInt(t.value, 10);
            });
            for (var s = 0; s < i.length; s += 1) {
              var r = i[s],
                n = r.point;
              r.value <= t.innerWidth && (a = n);
            }
            return a || "max";
          }
        },
      },
      checkOverflow: {
        checkOverflow: function () {
          var e = this,
            t = e.params,
            a = e.isLocked,
            i =
              e.slides.length > 0 &&
              t.slidesOffsetBefore +
                t.spaceBetween * (e.slides.length - 1) +
                e.slides[0].offsetWidth * e.slides.length;
          t.slidesOffsetBefore && t.slidesOffsetAfter && i
            ? (e.isLocked = i <= e.size)
            : (e.isLocked = 1 === e.snapGrid.length),
            (e.allowSlideNext = !e.isLocked),
            (e.allowSlidePrev = !e.isLocked),
            a !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock"),
            a &&
              a !== e.isLocked &&
              ((e.isEnd = !1), e.navigation && e.navigation.update());
        },
      },
      classes: {
        addClasses: function () {
          var e = this,
            t = e.classNames,
            a = e.params,
            i = e.rtl,
            s = e.$el,
            r = e.device,
            n = [];
          n.push("initialized"),
            n.push(a.direction),
            a.freeMode && n.push("free-mode"),
            a.autoHeight && n.push("autoheight"),
            i && n.push("rtl"),
            a.slidesPerColumn > 1 &&
              (n.push("multirow"),
              "column" === a.slidesPerColumnFill && n.push("multirow-column")),
            r.android && n.push("android"),
            r.ios && n.push("ios"),
            a.cssMode && n.push("css-mode"),
            n.forEach(function (e) {
              t.push(a.containerModifierClass + e);
            }),
            s.addClass(t.join(" ")),
            e.emitContainerClasses();
        },
        removeClasses: function () {
          var e = this,
            t = e.$el,
            a = e.classNames;
          t.removeClass(a.join(" ")), e.emitContainerClasses();
        },
      },
      images: {
        loadImage: function (e, t, a, i, s, r) {
          var n,
            o = l();
          function d() {
            r && r();
          }
          m(e).parent("picture")[0] || (e.complete && s)
            ? d()
            : t
            ? (((n = new o.Image()).onload = d),
              (n.onerror = d),
              i && (n.sizes = i),
              a && (n.srcset = a),
              t && (n.src = t))
            : d();
        },
        preloadImages: function () {
          var e = this;
          function t() {
            null != e &&
              e &&
              !e.destroyed &&
              (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1),
              e.imagesLoaded === e.imagesToLoad.length &&
                (e.params.updateOnImagesReady && e.update(),
                e.emit("imagesReady")));
          }
          e.imagesToLoad = e.$el.find("img");
          for (var a = 0; a < e.imagesToLoad.length; a += 1) {
            var i = e.imagesToLoad[a];
            e.loadImage(
              i,
              i.currentSrc || i.getAttribute("src"),
              i.srcset || i.getAttribute("srcset"),
              i.sizes || i.getAttribute("sizes"),
              !0,
              t
            );
          }
        },
      },
    },
    F = {},
    R = (function () {
      function t() {
        for (
          var e, a, i = arguments.length, s = new Array(i), r = 0;
          r < i;
          r++
        )
          s[r] = arguments[r];
        1 === s.length && s[0].constructor && s[0].constructor === Object
          ? (a = s[0])
          : ((e = s[0]), (a = s[1])),
          a || (a = {}),
          (a = S({}, a)),
          e && !a.el && (a.el = e);
        var n = this;
        (n.support = z()),
          (n.device = P({ userAgent: a.userAgent })),
          (n.browser = k()),
          (n.eventsListeners = {}),
          (n.eventsAnyListeners = []),
          void 0 === n.modules && (n.modules = {}),
          Object.keys(n.modules).forEach(function (e) {
            var t = n.modules[e];
            if (t.params) {
              var i = Object.keys(t.params)[0],
                s = t.params[i];
              if ("object" != typeof s || null === s) return;
              if (!(i in a) || !("enabled" in s)) return;
              !0 === a[i] && (a[i] = { enabled: !0 }),
                "object" != typeof a[i] ||
                  "enabled" in a[i] ||
                  (a[i].enabled = !0),
                a[i] || (a[i] = { enabled: !1 });
            }
          });
        var l = S({}, Y);
        n.useParams(l),
          (n.params = S({}, l, F, a)),
          (n.originalParams = S({}, n.params)),
          (n.passedParams = S({}, a)),
          n.params &&
            n.params.on &&
            Object.keys(n.params.on).forEach(function (e) {
              n.on(e, n.params.on[e]);
            }),
          n.params && n.params.onAny && n.onAny(n.params.onAny),
          (n.$ = m);
        var o = m(n.params.el);
        if ((e = o[0])) {
          if (o.length > 1) {
            var d = [];
            return (
              o.each(function (e) {
                var i = S({}, a, { el: e });
                d.push(new t(i));
              }),
              d
            );
          }
          var p, u, c;
          return (
            (e.swiper = n),
            e && e.shadowRoot && e.shadowRoot.querySelector
              ? ((p = m(
                  e.shadowRoot.querySelector("." + n.params.wrapperClass)
                )).children = function (e) {
                  return o.children(e);
                })
              : (p = o.children("." + n.params.wrapperClass)),
            S(n, {
              $el: o,
              el: e,
              $wrapperEl: p,
              wrapperEl: p[0],
              classNames: [],
              slides: m(),
              slidesGrid: [],
              snapGrid: [],
              slidesSizesGrid: [],
              isHorizontal: function () {
                return "horizontal" === n.params.direction;
              },
              isVertical: function () {
                return "vertical" === n.params.direction;
              },
              rtl:
                "rtl" === e.dir.toLowerCase() || "rtl" === o.css("direction"),
              rtlTranslate:
                "horizontal" === n.params.direction &&
                ("rtl" === e.dir.toLowerCase() || "rtl" === o.css("direction")),
              wrongRTL: "-webkit-box" === p.css("display"),
              activeIndex: 0,
              realIndex: 0,
              isBeginning: !0,
              isEnd: !1,
              translate: 0,
              previousTranslate: 0,
              progress: 0,
              velocity: 0,
              animating: !1,
              allowSlideNext: n.params.allowSlideNext,
              allowSlidePrev: n.params.allowSlidePrev,
              touchEvents:
                ((u = ["touchstart", "touchmove", "touchend", "touchcancel"]),
                (c = ["mousedown", "mousemove", "mouseup"]),
                n.support.pointerEvents &&
                  (c = ["pointerdown", "pointermove", "pointerup"]),
                (n.touchEventsTouch = {
                  start: u[0],
                  move: u[1],
                  end: u[2],
                  cancel: u[3],
                }),
                (n.touchEventsDesktop = { start: c[0], move: c[1], end: c[2] }),
                n.support.touch || !n.params.simulateTouch
                  ? n.touchEventsTouch
                  : n.touchEventsDesktop),
              touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                formElements:
                  "input, select, option, textarea, button, video, label",
                lastClickTime: x(),
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                isTouchEvent: void 0,
                startMoving: void 0,
              },
              allowClick: !0,
              allowTouchMove: n.params.allowTouchMove,
              touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0,
              },
              imagesToLoad: [],
              imagesLoaded: 0,
            }),
            n.useModules(),
            n.emit("_swiper"),
            n.params.init && n.init(),
            n
          );
        }
      }
      var a,
        i,
        s,
        r = t.prototype;
      return (
        (r.emitContainerClasses = function () {
          var e = this;
          if (e.params._emitClasses && e.el) {
            var t = e.el.className.split(" ").filter(function (t) {
              return (
                0 === t.indexOf("swiper-container") ||
                0 === t.indexOf(e.params.containerModifierClass)
              );
            });
            e.emit("_containerClasses", t.join(" "));
          }
        }),
        (r.getSlideClasses = function (e) {
          var t = this;
          return e.className
            .split(" ")
            .filter(function (e) {
              return (
                0 === e.indexOf("swiper-slide") ||
                0 === e.indexOf(t.params.slideClass)
              );
            })
            .join(" ");
        }),
        (r.emitSlidesClasses = function () {
          var e = this;
          e.params._emitClasses &&
            e.el &&
            e.slides.each(function (t) {
              var a = e.getSlideClasses(t);
              e.emit("_slideClass", t, a);
            });
        }),
        (r.slidesPerViewDynamic = function () {
          var e = this,
            t = e.params,
            a = e.slides,
            i = e.slidesGrid,
            s = e.size,
            r = e.activeIndex,
            n = 1;
          if (t.centeredSlides) {
            for (
              var l, o = a[r].swiperSlideSize, d = r + 1;
              d < a.length;
              d += 1
            )
              a[d] &&
                !l &&
                ((n += 1), (o += a[d].swiperSlideSize) > s && (l = !0));
            for (var p = r - 1; p >= 0; p -= 1)
              a[p] &&
                !l &&
                ((n += 1), (o += a[p].swiperSlideSize) > s && (l = !0));
          } else
            for (var u = r + 1; u < a.length; u += 1)
              i[u] - i[r] < s && (n += 1);
          return n;
        }),
        (r.update = function () {
          var e = this;
          if (e && !e.destroyed) {
            var t = e.snapGrid,
              a = e.params;
            a.breakpoints && e.setBreakpoint(),
              e.updateSize(),
              e.updateSlides(),
              e.updateProgress(),
              e.updateSlidesClasses(),
              e.params.freeMode
                ? (i(), e.params.autoHeight && e.updateAutoHeight())
                : (("auto" === e.params.slidesPerView ||
                    e.params.slidesPerView > 1) &&
                  e.isEnd &&
                  !e.params.centeredSlides
                    ? e.slideTo(e.slides.length - 1, 0, !1, !0)
                    : e.slideTo(e.activeIndex, 0, !1, !0)) || i(),
              a.watchOverflow && t !== e.snapGrid && e.checkOverflow(),
              e.emit("update");
          }
          function i() {
            var t = e.rtlTranslate ? -1 * e.translate : e.translate,
              a = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
            e.setTranslate(a), e.updateActiveIndex(), e.updateSlidesClasses();
          }
        }),
        (r.changeDirection = function (e, t) {
          void 0 === t && (t = !0);
          var a = this,
            i = a.params.direction;
          return (
            e || (e = "horizontal" === i ? "vertical" : "horizontal"),
            e === i ||
              ("horizontal" !== e && "vertical" !== e) ||
              (a.$el
                .removeClass("" + a.params.containerModifierClass + i)
                .addClass("" + a.params.containerModifierClass + e),
              a.emitContainerClasses(),
              (a.params.direction = e),
              a.slides.each(function (t) {
                "vertical" === e ? (t.style.width = "") : (t.style.height = "");
              }),
              a.emit("changeDirection"),
              t && a.update()),
            a
          );
        }),
        (r.init = function () {
          var e = this;
          e.initialized ||
            (e.emit("beforeInit"),
            e.params.breakpoints && e.setBreakpoint(),
            e.addClasses(),
            e.params.loop && e.loopCreate(),
            e.updateSize(),
            e.updateSlides(),
            e.params.watchOverflow && e.checkOverflow(),
            e.params.grabCursor && e.setGrabCursor(),
            e.params.preloadImages && e.preloadImages(),
            e.params.loop
              ? e.slideTo(
                  e.params.initialSlide + e.loopedSlides,
                  0,
                  e.params.runCallbacksOnInit
                )
              : e.slideTo(
                  e.params.initialSlide,
                  0,
                  e.params.runCallbacksOnInit
                ),
            e.attachEvents(),
            (e.initialized = !0),
            e.emit("init"),
            e.emit("afterInit"));
        }),
        (r.destroy = function (e, t) {
          void 0 === e && (e = !0), void 0 === t && (t = !0);
          var a,
            i = this,
            s = i.params,
            r = i.$el,
            n = i.$wrapperEl,
            l = i.slides;
          return (
            void 0 === i.params ||
              i.destroyed ||
              (i.emit("beforeDestroy"),
              (i.initialized = !1),
              i.detachEvents(),
              s.loop && i.loopDestroy(),
              t &&
                (i.removeClasses(),
                r.removeAttr("style"),
                n.removeAttr("style"),
                l &&
                  l.length &&
                  l
                    .removeClass(
                      [
                        s.slideVisibleClass,
                        s.slideActiveClass,
                        s.slideNextClass,
                        s.slidePrevClass,
                      ].join(" ")
                    )
                    .removeAttr("style")
                    .removeAttr("data-swiper-slide-index")),
              i.emit("destroy"),
              Object.keys(i.eventsListeners).forEach(function (e) {
                i.off(e);
              }),
              !1 !== e &&
                ((i.$el[0].swiper = null),
                (a = i),
                Object.keys(a).forEach(function (e) {
                  try {
                    a[e] = null;
                  } catch (e) {}
                  try {
                    delete a[e];
                  } catch (e) {}
                })),
              (i.destroyed = !0)),
            null
          );
        }),
        (t.extendDefaults = function (e) {
          S(F, e);
        }),
        (t.installModule = function (e) {
          t.prototype.modules || (t.prototype.modules = {});
          var a = e.name || Object.keys(t.prototype.modules).length + "_" + x();
          t.prototype.modules[a] = e;
        }),
        (t.use = function (e) {
          return Array.isArray(e)
            ? (e.forEach(function (e) {
                return t.installModule(e);
              }),
              t)
            : (t.installModule(e), t);
        }),
        (a = t),
        (s = [
          {
            key: "extendedDefaults",
            get: function () {
              return F;
            },
          },
          {
            key: "defaults",
            get: function () {
              return Y;
            },
          },
        ]),
        (i = null) && e(a.prototype, i),
        s && e(a, s),
        t
      );
    })();
  Object.keys(V).forEach(function (e) {
    Object.keys(V[e]).forEach(function (t) {
      R.prototype[t] = V[e][t];
    });
  }),
    R.use([L, I]);
  var W = {
      update: function (e) {
        var t = this,
          a = t.params,
          i = a.slidesPerView,
          s = a.slidesPerGroup,
          r = a.centeredSlides,
          n = t.params.virtual,
          l = n.addSlidesBefore,
          o = n.addSlidesAfter,
          d = t.virtual,
          p = d.from,
          u = d.to,
          c = d.slides,
          h = d.slidesGrid,
          v = d.renderSlide,
          f = d.offset;
        t.updateActiveIndex();
        var m,
          g,
          y,
          w = t.activeIndex || 0;
        (m = t.rtlTranslate ? "right" : t.isHorizontal() ? "left" : "top"),
          r
            ? ((g = Math.floor(i / 2) + s + o), (y = Math.floor(i / 2) + s + l))
            : ((g = i + (s - 1) + o), (y = s + l));
        var b = Math.max((w || 0) - y, 0),
          E = Math.min((w || 0) + g, c.length - 1),
          x = (t.slidesGrid[b] || 0) - (t.slidesGrid[0] || 0);
        function T() {
          t.updateSlides(),
            t.updateProgress(),
            t.updateSlidesClasses(),
            t.lazy && t.params.lazy.enabled && t.lazy.load();
        }
        if (
          (S(t.virtual, {
            from: b,
            to: E,
            offset: x,
            slidesGrid: t.slidesGrid,
          }),
          p === b && u === E && !e)
        )
          return (
            t.slidesGrid !== h && x !== f && t.slides.css(m, x + "px"),
            void t.updateProgress()
          );
        if (t.params.virtual.renderExternal)
          return (
            t.params.virtual.renderExternal.call(t, {
              offset: x,
              from: b,
              to: E,
              slides: (function () {
                for (var e = [], t = b; t <= E; t += 1) e.push(c[t]);
                return e;
              })(),
            }),
            void (t.params.virtual.renderExternalUpdate && T())
          );
        var C = [],
          M = [];
        if (e) t.$wrapperEl.find("." + t.params.slideClass).remove();
        else
          for (var z = p; z <= u; z += 1)
            (z < b || z > E) &&
              t.$wrapperEl
                .find(
                  "." +
                    t.params.slideClass +
                    '[data-swiper-slide-index="' +
                    z +
                    '"]'
                )
                .remove();
        for (var P = 0; P < c.length; P += 1)
          P >= b &&
            P <= E &&
            (void 0 === u || e
              ? M.push(P)
              : (P > u && M.push(P), P < p && C.push(P)));
        M.forEach(function (e) {
          t.$wrapperEl.append(v(c[e], e));
        }),
          C.sort(function (e, t) {
            return t - e;
          }).forEach(function (e) {
            t.$wrapperEl.prepend(v(c[e], e));
          }),
          t.$wrapperEl.children(".swiper-slide").css(m, x + "px"),
          T();
      },
      renderSlide: function (e, t) {
        var a = this,
          i = a.params.virtual;
        if (i.cache && a.virtual.cache[t]) return a.virtual.cache[t];
        var s = i.renderSlide
          ? m(i.renderSlide.call(a, e, t))
          : m(
              '<div class="' +
                a.params.slideClass +
                '" data-swiper-slide-index="' +
                t +
                '">' +
                e +
                "</div>"
            );
        return (
          s.attr("data-swiper-slide-index") ||
            s.attr("data-swiper-slide-index", t),
          i.cache && (a.virtual.cache[t] = s),
          s
        );
      },
      appendSlide: function (e) {
        var t = this;
        if ("object" == typeof e && "length" in e)
          for (var a = 0; a < e.length; a += 1)
            e[a] && t.virtual.slides.push(e[a]);
        else t.virtual.slides.push(e);
        t.virtual.update(!0);
      },
      prependSlide: function (e) {
        var t = this,
          a = t.activeIndex,
          i = a + 1,
          s = 1;
        if (Array.isArray(e)) {
          for (var r = 0; r < e.length; r += 1)
            e[r] && t.virtual.slides.unshift(e[r]);
          (i = a + e.length), (s = e.length);
        } else t.virtual.slides.unshift(e);
        if (t.params.virtual.cache) {
          var n = t.virtual.cache,
            l = {};
          Object.keys(n).forEach(function (e) {
            var t = n[e],
              a = t.attr("data-swiper-slide-index");
            a && t.attr("data-swiper-slide-index", parseInt(a, 10) + 1),
              (l[parseInt(e, 10) + s] = t);
          }),
            (t.virtual.cache = l);
        }
        t.virtual.update(!0), t.slideTo(i, 0);
      },
      removeSlide: function (e) {
        var t = this;
        if (null != e) {
          var a = t.activeIndex;
          if (Array.isArray(e))
            for (var i = e.length - 1; i >= 0; i -= 1)
              t.virtual.slides.splice(e[i], 1),
                t.params.virtual.cache && delete t.virtual.cache[e[i]],
                e[i] < a && (a -= 1),
                (a = Math.max(a, 0));
          else
            t.virtual.slides.splice(e, 1),
              t.params.virtual.cache && delete t.virtual.cache[e],
              e < a && (a -= 1),
              (a = Math.max(a, 0));
          t.virtual.update(!0), t.slideTo(a, 0);
        }
      },
      removeAllSlides: function () {
        var e = this;
        (e.virtual.slides = []),
          e.params.virtual.cache && (e.virtual.cache = {}),
          e.virtual.update(!0),
          e.slideTo(0, 0);
      },
    },
    q = {
      name: "virtual",
      params: {
        virtual: {
          enabled: !1,
          slides: [],
          cache: !0,
          renderSlide: null,
          renderExternal: null,
          renderExternalUpdate: !0,
          addSlidesBefore: 0,
          addSlidesAfter: 0,
        },
      },
      create: function () {
        M(this, {
          virtual: t({}, W, { slides: this.params.virtual.slides, cache: {} }),
        });
      },
      on: {
        beforeInit: function (e) {
          if (e.params.virtual.enabled) {
            e.classNames.push(e.params.containerModifierClass + "virtual");
            var t = { watchSlidesProgress: !0 };
            S(e.params, t),
              S(e.originalParams, t),
              e.params.initialSlide || e.virtual.update();
          }
        },
        setTranslate: function (e) {
          e.params.virtual.enabled && e.virtual.update();
        },
      },
    },
    j = {
      handle: function (e) {
        var t = this,
          a = l(),
          i = r(),
          s = t.rtlTranslate,
          n = e;
        n.originalEvent && (n = n.originalEvent);
        var o = n.keyCode || n.charCode,
          d = t.params.keyboard.pageUpDown,
          p = d && 33 === o,
          u = d && 34 === o,
          c = 37 === o,
          h = 39 === o,
          v = 38 === o,
          f = 40 === o;
        if (
          !t.allowSlideNext &&
          ((t.isHorizontal() && h) || (t.isVertical() && f) || u)
        )
          return !1;
        if (
          !t.allowSlidePrev &&
          ((t.isHorizontal() && c) || (t.isVertical() && v) || p)
        )
          return !1;
        if (
          !(
            n.shiftKey ||
            n.altKey ||
            n.ctrlKey ||
            n.metaKey ||
            (i.activeElement &&
              i.activeElement.nodeName &&
              ("input" === i.activeElement.nodeName.toLowerCase() ||
                "textarea" === i.activeElement.nodeName.toLowerCase()))
          )
        ) {
          if (
            t.params.keyboard.onlyInViewport &&
            (p || u || c || h || v || f)
          ) {
            var m = !1;
            if (
              t.$el.parents("." + t.params.slideClass).length > 0 &&
              0 === t.$el.parents("." + t.params.slideActiveClass).length
            )
              return;
            var g = a.innerWidth,
              y = a.innerHeight,
              w = t.$el.offset();
            s && (w.left -= t.$el[0].scrollLeft);
            for (
              var b = [
                  [w.left, w.top],
                  [w.left + t.width, w.top],
                  [w.left, w.top + t.height],
                  [w.left + t.width, w.top + t.height],
                ],
                E = 0;
              E < b.length;
              E += 1
            ) {
              var x = b[E];
              if (x[0] >= 0 && x[0] <= g && x[1] >= 0 && x[1] <= y) {
                if (0 === x[0] && 0 === x[1]) continue;
                m = !0;
              }
            }
            if (!m) return;
          }
          t.isHorizontal()
            ? ((p || u || c || h) &&
                (n.preventDefault ? n.preventDefault() : (n.returnValue = !1)),
              (((u || h) && !s) || ((p || c) && s)) && t.slideNext(),
              (((p || c) && !s) || ((u || h) && s)) && t.slidePrev())
            : ((p || u || v || f) &&
                (n.preventDefault ? n.preventDefault() : (n.returnValue = !1)),
              (u || f) && t.slideNext(),
              (p || v) && t.slidePrev()),
            t.emit("keyPress", o);
        }
      },
      enable: function () {
        var e = this,
          t = r();
        e.keyboard.enabled ||
          (m(t).on("keydown", e.keyboard.handle), (e.keyboard.enabled = !0));
      },
      disable: function () {
        var e = this,
          t = r();
        e.keyboard.enabled &&
          (m(t).off("keydown", e.keyboard.handle), (e.keyboard.enabled = !1));
      },
    },
    _ = {
      name: "keyboard",
      params: { keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } },
      create: function () {
        M(this, { keyboard: t({ enabled: !1 }, j) });
      },
      on: {
        init: function (e) {
          e.params.keyboard.enabled && e.keyboard.enable();
        },
        destroy: function (e) {
          e.keyboard.enabled && e.keyboard.disable();
        },
      },
    };
  var U = {
      lastScrollTime: x(),
      lastEventBeforeSnap: void 0,
      recentWheelEvents: [],
      event: function () {
        return l().navigator.userAgent.indexOf("firefox") > -1
          ? "DOMMouseScroll"
          : (function () {
              var e = r(),
                t = "onwheel",
                a = t in e;
              if (!a) {
                var i = e.createElement("div");
                i.setAttribute(t, "return;"),
                  (a = "function" == typeof i.onwheel);
              }
              return (
                !a &&
                  e.implementation &&
                  e.implementation.hasFeature &&
                  !0 !== e.implementation.hasFeature("", "") &&
                  (a = e.implementation.hasFeature("Events.wheel", "3.0")),
                a
              );
            })()
          ? "wheel"
          : "mousewheel";
      },
      normalize: function (e) {
        var t = 0,
          a = 0,
          i = 0,
          s = 0;
        return (
          "detail" in e && (a = e.detail),
          "wheelDelta" in e && (a = -e.wheelDelta / 120),
          "wheelDeltaY" in e && (a = -e.wheelDeltaY / 120),
          "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120),
          "axis" in e && e.axis === e.HORIZONTAL_AXIS && ((t = a), (a = 0)),
          (i = 10 * t),
          (s = 10 * a),
          "deltaY" in e && (s = e.deltaY),
          "deltaX" in e && (i = e.deltaX),
          e.shiftKey && !i && ((i = s), (s = 0)),
          (i || s) &&
            e.deltaMode &&
            (1 === e.deltaMode
              ? ((i *= 40), (s *= 40))
              : ((i *= 800), (s *= 800))),
          i && !t && (t = i < 1 ? -1 : 1),
          s && !a && (a = s < 1 ? -1 : 1),
          { spinX: t, spinY: a, pixelX: i, pixelY: s }
        );
      },
      handleMouseEnter: function () {
        this.mouseEntered = !0;
      },
      handleMouseLeave: function () {
        this.mouseEntered = !1;
      },
      handle: function (e) {
        var t = e,
          a = this,
          i = a.params.mousewheel;
        a.params.cssMode && t.preventDefault();
        var s = a.$el;
        if (
          ("container" !== a.params.mousewheel.eventsTarget &&
            (s = m(a.params.mousewheel.eventsTarget)),
          !a.mouseEntered && !s[0].contains(t.target) && !i.releaseOnEdges)
        )
          return !0;
        t.originalEvent && (t = t.originalEvent);
        var r = 0,
          n = a.rtlTranslate ? -1 : 1,
          l = U.normalize(t);
        if (i.forceToAxis)
          if (a.isHorizontal()) {
            if (!(Math.abs(l.pixelX) > Math.abs(l.pixelY))) return !0;
            r = -l.pixelX * n;
          } else {
            if (!(Math.abs(l.pixelY) > Math.abs(l.pixelX))) return !0;
            r = -l.pixelY;
          }
        else
          r =
            Math.abs(l.pixelX) > Math.abs(l.pixelY) ? -l.pixelX * n : -l.pixelY;
        if (0 === r) return !0;
        i.invert && (r = -r);
        var o = a.getTranslate() + r * i.sensitivity;
        if (
          (o >= a.minTranslate() && (o = a.minTranslate()),
          o <= a.maxTranslate() && (o = a.maxTranslate()),
          (!!a.params.loop ||
            !(o === a.minTranslate() || o === a.maxTranslate())) &&
            a.params.nested &&
            t.stopPropagation(),
          a.params.freeMode)
        ) {
          var d = { time: x(), delta: Math.abs(r), direction: Math.sign(r) },
            p = a.mousewheel.lastEventBeforeSnap,
            u =
              p &&
              d.time < p.time + 500 &&
              d.delta <= p.delta &&
              d.direction === p.direction;
          if (!u) {
            (a.mousewheel.lastEventBeforeSnap = void 0),
              a.params.loop && a.loopFix();
            var c = a.getTranslate() + r * i.sensitivity,
              h = a.isBeginning,
              v = a.isEnd;
            if (
              (c >= a.minTranslate() && (c = a.minTranslate()),
              c <= a.maxTranslate() && (c = a.maxTranslate()),
              a.setTransition(0),
              a.setTranslate(c),
              a.updateProgress(),
              a.updateActiveIndex(),
              a.updateSlidesClasses(),
              ((!h && a.isBeginning) || (!v && a.isEnd)) &&
                a.updateSlidesClasses(),
              a.params.freeModeSticky)
            ) {
              clearTimeout(a.mousewheel.timeout),
                (a.mousewheel.timeout = void 0);
              var f = a.mousewheel.recentWheelEvents;
              f.length >= 15 && f.shift();
              var g = f.length ? f[f.length - 1] : void 0,
                y = f[0];
              if (
                (f.push(d),
                g && (d.delta > g.delta || d.direction !== g.direction))
              )
                f.splice(0);
              else if (
                f.length >= 15 &&
                d.time - y.time < 500 &&
                y.delta - d.delta >= 1 &&
                d.delta <= 6
              ) {
                var w = r > 0 ? 0.8 : 0.2;
                (a.mousewheel.lastEventBeforeSnap = d),
                  f.splice(0),
                  (a.mousewheel.timeout = E(function () {
                    a.slideToClosest(a.params.speed, !0, void 0, w);
                  }, 0));
              }
              a.mousewheel.timeout ||
                (a.mousewheel.timeout = E(function () {
                  (a.mousewheel.lastEventBeforeSnap = d),
                    f.splice(0),
                    a.slideToClosest(a.params.speed, !0, void 0, 0.5);
                }, 500));
            }
            if (
              (u || a.emit("scroll", t),
              a.params.autoplay &&
                a.params.autoplayDisableOnInteraction &&
                a.autoplay.stop(),
              c === a.minTranslate() || c === a.maxTranslate())
            )
              return !0;
          }
        } else {
          var b = {
              time: x(),
              delta: Math.abs(r),
              direction: Math.sign(r),
              raw: e,
            },
            T = a.mousewheel.recentWheelEvents;
          T.length >= 2 && T.shift();
          var C = T.length ? T[T.length - 1] : void 0;
          if (
            (T.push(b),
            C
              ? (b.direction !== C.direction ||
                  b.delta > C.delta ||
                  b.time > C.time + 150) &&
                a.mousewheel.animateSlider(b)
              : a.mousewheel.animateSlider(b),
            a.mousewheel.releaseScroll(b))
          )
            return !0;
        }
        return t.preventDefault ? t.preventDefault() : (t.returnValue = !1), !1;
      },
      animateSlider: function (e) {
        var t = this,
          a = l();
        return (
          !(
            this.params.mousewheel.thresholdDelta &&
            e.delta < this.params.mousewheel.thresholdDelta
          ) &&
          !(
            this.params.mousewheel.thresholdTime &&
            x() - t.mousewheel.lastScrollTime <
              this.params.mousewheel.thresholdTime
          ) &&
          ((e.delta >= 6 && x() - t.mousewheel.lastScrollTime < 60) ||
            (e.direction < 0
              ? (t.isEnd && !t.params.loop) ||
                t.animating ||
                (t.slideNext(), t.emit("scroll", e.raw))
              : (t.isBeginning && !t.params.loop) ||
                t.animating ||
                (t.slidePrev(), t.emit("scroll", e.raw)),
            (t.mousewheel.lastScrollTime = new a.Date().getTime()),
            !1))
        );
      },
      releaseScroll: function (e) {
        var t = this,
          a = t.params.mousewheel;
        if (e.direction < 0) {
          if (t.isEnd && !t.params.loop && a.releaseOnEdges) return !0;
        } else if (t.isBeginning && !t.params.loop && a.releaseOnEdges)
          return !0;
        return !1;
      },
      enable: function () {
        var e = this,
          t = U.event();
        if (e.params.cssMode)
          return e.wrapperEl.removeEventListener(t, e.mousewheel.handle), !0;
        if (!t) return !1;
        if (e.mousewheel.enabled) return !1;
        var a = e.$el;
        return (
          "container" !== e.params.mousewheel.eventsTarget &&
            (a = m(e.params.mousewheel.eventsTarget)),
          a.on("mouseenter", e.mousewheel.handleMouseEnter),
          a.on("mouseleave", e.mousewheel.handleMouseLeave),
          a.on(t, e.mousewheel.handle),
          (e.mousewheel.enabled = !0),
          !0
        );
      },
      disable: function () {
        var e = this,
          t = U.event();
        if (e.params.cssMode)
          return e.wrapperEl.addEventListener(t, e.mousewheel.handle), !0;
        if (!t) return !1;
        if (!e.mousewheel.enabled) return !1;
        var a = e.$el;
        return (
          "container" !== e.params.mousewheel.eventsTarget &&
            (a = m(e.params.mousewheel.eventsTarget)),
          a.off(t, e.mousewheel.handle),
          (e.mousewheel.enabled = !1),
          !0
        );
      },
    },
    K = {
      update: function () {
        var e = this,
          t = e.params.navigation;
        if (!e.params.loop) {
          var a = e.navigation,
            i = a.$nextEl,
            s = a.$prevEl;
          s &&
            s.length > 0 &&
            (e.isBeginning
              ? s.addClass(t.disabledClass)
              : s.removeClass(t.disabledClass),
            s[
              e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"
            ](t.lockClass)),
            i &&
              i.length > 0 &&
              (e.isEnd
                ? i.addClass(t.disabledClass)
                : i.removeClass(t.disabledClass),
              i[
                e.params.watchOverflow && e.isLocked
                  ? "addClass"
                  : "removeClass"
              ](t.lockClass));
        }
      },
      onPrevClick: function (e) {
        var t = this;
        e.preventDefault(), (t.isBeginning && !t.params.loop) || t.slidePrev();
      },
      onNextClick: function (e) {
        var t = this;
        e.preventDefault(), (t.isEnd && !t.params.loop) || t.slideNext();
      },
      init: function () {
        var e,
          t,
          a = this,
          i = a.params.navigation;
        (i.nextEl || i.prevEl) &&
          (i.nextEl &&
            ((e = m(i.nextEl)),
            a.params.uniqueNavElements &&
              "string" == typeof i.nextEl &&
              e.length > 1 &&
              1 === a.$el.find(i.nextEl).length &&
              (e = a.$el.find(i.nextEl))),
          i.prevEl &&
            ((t = m(i.prevEl)),
            a.params.uniqueNavElements &&
              "string" == typeof i.prevEl &&
              t.length > 1 &&
              1 === a.$el.find(i.prevEl).length &&
              (t = a.$el.find(i.prevEl))),
          e && e.length > 0 && e.on("click", a.navigation.onNextClick),
          t && t.length > 0 && t.on("click", a.navigation.onPrevClick),
          S(a.navigation, {
            $nextEl: e,
            nextEl: e && e[0],
            $prevEl: t,
            prevEl: t && t[0],
          }));
      },
      destroy: function () {
        var e = this,
          t = e.navigation,
          a = t.$nextEl,
          i = t.$prevEl;
        a &&
          a.length &&
          (a.off("click", e.navigation.onNextClick),
          a.removeClass(e.params.navigation.disabledClass)),
          i &&
            i.length &&
            (i.off("click", e.navigation.onPrevClick),
            i.removeClass(e.params.navigation.disabledClass));
      },
    },
    Z = {
      update: function () {
        var e = this,
          t = e.rtl,
          a = e.params.pagination;
        if (
          a.el &&
          e.pagination.el &&
          e.pagination.$el &&
          0 !== e.pagination.$el.length
        ) {
          var i,
            s =
              e.virtual && e.params.virtual.enabled
                ? e.virtual.slides.length
                : e.slides.length,
            r = e.pagination.$el,
            n = e.params.loop
              ? Math.ceil((s - 2 * e.loopedSlides) / e.params.slidesPerGroup)
              : e.snapGrid.length;
          if (
            (e.params.loop
              ? ((i = Math.ceil(
                  (e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup
                )) >
                  s - 1 - 2 * e.loopedSlides && (i -= s - 2 * e.loopedSlides),
                i > n - 1 && (i -= n),
                i < 0 && "bullets" !== e.params.paginationType && (i = n + i))
              : (i = void 0 !== e.snapIndex ? e.snapIndex : e.activeIndex || 0),
            "bullets" === a.type &&
              e.pagination.bullets &&
              e.pagination.bullets.length > 0)
          ) {
            var l,
              o,
              d,
              p = e.pagination.bullets;
            if (
              (a.dynamicBullets &&
                ((e.pagination.bulletSize = p
                  .eq(0)
                  [e.isHorizontal() ? "outerWidth" : "outerHeight"](!0)),
                r.css(
                  e.isHorizontal() ? "width" : "height",
                  e.pagination.bulletSize * (a.dynamicMainBullets + 4) + "px"
                ),
                a.dynamicMainBullets > 1 &&
                  void 0 !== e.previousIndex &&
                  ((e.pagination.dynamicBulletIndex += i - e.previousIndex),
                  e.pagination.dynamicBulletIndex > a.dynamicMainBullets - 1
                    ? (e.pagination.dynamicBulletIndex =
                        a.dynamicMainBullets - 1)
                    : e.pagination.dynamicBulletIndex < 0 &&
                      (e.pagination.dynamicBulletIndex = 0)),
                (l = i - e.pagination.dynamicBulletIndex),
                (d =
                  ((o = l + (Math.min(p.length, a.dynamicMainBullets) - 1)) +
                    l) /
                  2)),
              p.removeClass(
                a.bulletActiveClass +
                  " " +
                  a.bulletActiveClass +
                  "-next " +
                  a.bulletActiveClass +
                  "-next-next " +
                  a.bulletActiveClass +
                  "-prev " +
                  a.bulletActiveClass +
                  "-prev-prev " +
                  a.bulletActiveClass +
                  "-main"
              ),
              r.length > 1)
            )
              p.each(function (e) {
                var t = m(e),
                  s = t.index();
                s === i && t.addClass(a.bulletActiveClass),
                  a.dynamicBullets &&
                    (s >= l &&
                      s <= o &&
                      t.addClass(a.bulletActiveClass + "-main"),
                    s === l &&
                      t
                        .prev()
                        .addClass(a.bulletActiveClass + "-prev")
                        .prev()
                        .addClass(a.bulletActiveClass + "-prev-prev"),
                    s === o &&
                      t
                        .next()
                        .addClass(a.bulletActiveClass + "-next")
                        .next()
                        .addClass(a.bulletActiveClass + "-next-next"));
              });
            else {
              var u = p.eq(i),
                c = u.index();
              if ((u.addClass(a.bulletActiveClass), a.dynamicBullets)) {
                for (var h = p.eq(l), v = p.eq(o), f = l; f <= o; f += 1)
                  p.eq(f).addClass(a.bulletActiveClass + "-main");
                if (e.params.loop)
                  if (c >= p.length - a.dynamicMainBullets) {
                    for (var g = a.dynamicMainBullets; g >= 0; g -= 1)
                      p.eq(p.length - g).addClass(
                        a.bulletActiveClass + "-main"
                      );
                    p.eq(p.length - a.dynamicMainBullets - 1).addClass(
                      a.bulletActiveClass + "-prev"
                    );
                  } else
                    h
                      .prev()
                      .addClass(a.bulletActiveClass + "-prev")
                      .prev()
                      .addClass(a.bulletActiveClass + "-prev-prev"),
                      v
                        .next()
                        .addClass(a.bulletActiveClass + "-next")
                        .next()
                        .addClass(a.bulletActiveClass + "-next-next");
                else
                  h
                    .prev()
                    .addClass(a.bulletActiveClass + "-prev")
                    .prev()
                    .addClass(a.bulletActiveClass + "-prev-prev"),
                    v
                      .next()
                      .addClass(a.bulletActiveClass + "-next")
                      .next()
                      .addClass(a.bulletActiveClass + "-next-next");
              }
            }
            if (a.dynamicBullets) {
              var y = Math.min(p.length, a.dynamicMainBullets + 4),
                w =
                  (e.pagination.bulletSize * y - e.pagination.bulletSize) / 2 -
                  d * e.pagination.bulletSize,
                b = t ? "right" : "left";
              p.css(e.isHorizontal() ? b : "top", w + "px");
            }
          }
          if (
            ("fraction" === a.type &&
              (r
                .find("." + a.currentClass)
                .text(a.formatFractionCurrent(i + 1)),
              r.find("." + a.totalClass).text(a.formatFractionTotal(n))),
            "progressbar" === a.type)
          ) {
            var E;
            E = a.progressbarOpposite
              ? e.isHorizontal()
                ? "vertical"
                : "horizontal"
              : e.isHorizontal()
              ? "horizontal"
              : "vertical";
            var x = (i + 1) / n,
              T = 1,
              C = 1;
            "horizontal" === E ? (T = x) : (C = x),
              r
                .find("." + a.progressbarFillClass)
                .transform(
                  "translate3d(0,0,0) scaleX(" + T + ") scaleY(" + C + ")"
                )
                .transition(e.params.speed);
          }
          "custom" === a.type && a.renderCustom
            ? (r.html(a.renderCustom(e, i + 1, n)),
              e.emit("paginationRender", r[0]))
            : e.emit("paginationUpdate", r[0]),
            r[
              e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"
            ](a.lockClass);
        }
      },
      render: function () {
        var e = this,
          t = e.params.pagination;
        if (
          t.el &&
          e.pagination.el &&
          e.pagination.$el &&
          0 !== e.pagination.$el.length
        ) {
          var a =
              e.virtual && e.params.virtual.enabled
                ? e.virtual.slides.length
                : e.slides.length,
            i = e.pagination.$el,
            s = "";
          if ("bullets" === t.type) {
            for (
              var r = e.params.loop
                  ? Math.ceil(
                      (a - 2 * e.loopedSlides) / e.params.slidesPerGroup
                    )
                  : e.snapGrid.length,
                n = 0;
              n < r;
              n += 1
            )
              t.renderBullet
                ? (s += t.renderBullet.call(e, n, t.bulletClass))
                : (s +=
                    "<" +
                    t.bulletElement +
                    ' class="' +
                    t.bulletClass +
                    '"></' +
                    t.bulletElement +
                    ">");
            i.html(s),
              (e.pagination.bullets = i.find(
                "." + t.bulletClass.replace(/ /g, ".")
              ));
          }
          "fraction" === t.type &&
            ((s = t.renderFraction
              ? t.renderFraction.call(e, t.currentClass, t.totalClass)
              : '<span class="' +
                t.currentClass +
                '"></span> / <span class="' +
                t.totalClass +
                '"></span>'),
            i.html(s)),
            "progressbar" === t.type &&
              ((s = t.renderProgressbar
                ? t.renderProgressbar.call(e, t.progressbarFillClass)
                : '<span class="' + t.progressbarFillClass + '"></span>'),
              i.html(s)),
            "custom" !== t.type &&
              e.emit("paginationRender", e.pagination.$el[0]);
        }
      },
      init: function () {
        var e = this,
          t = e.params.pagination;
        if (t.el) {
          var a = m(t.el);
          0 !== a.length &&
            (e.params.uniqueNavElements &&
              "string" == typeof t.el &&
              a.length > 1 &&
              (a = e.$el.find(t.el)),
            "bullets" === t.type && t.clickable && a.addClass(t.clickableClass),
            a.addClass(t.modifierClass + t.type),
            "bullets" === t.type &&
              t.dynamicBullets &&
              (a.addClass("" + t.modifierClass + t.type + "-dynamic"),
              (e.pagination.dynamicBulletIndex = 0),
              t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)),
            "progressbar" === t.type &&
              t.progressbarOpposite &&
              a.addClass(t.progressbarOppositeClass),
            t.clickable &&
              a.on(
                "click",
                "." + t.bulletClass.replace(/ /g, "."),
                function (t) {
                  t.preventDefault();
                  var a = m(this).index() * e.params.slidesPerGroup;
                  e.params.loop && (a += e.loopedSlides), e.slideTo(a);
                }
              ),
            S(e.pagination, { $el: a, el: a[0] }));
        }
      },
      destroy: function () {
        var e = this,
          t = e.params.pagination;
        if (
          t.el &&
          e.pagination.el &&
          e.pagination.$el &&
          0 !== e.pagination.$el.length
        ) {
          var a = e.pagination.$el;
          a.removeClass(t.hiddenClass),
            a.removeClass(t.modifierClass + t.type),
            e.pagination.bullets &&
              e.pagination.bullets.removeClass(t.bulletActiveClass),
            t.clickable &&
              a.off("click", "." + t.bulletClass.replace(/ /g, "."));
        }
      },
    },
    J = {
      setTranslate: function () {
        var e = this;
        if (e.params.scrollbar.el && e.scrollbar.el) {
          var t = e.scrollbar,
            a = e.rtlTranslate,
            i = e.progress,
            s = t.dragSize,
            r = t.trackSize,
            n = t.$dragEl,
            l = t.$el,
            o = e.params.scrollbar,
            d = s,
            p = (r - s) * i;
          a
            ? (p = -p) > 0
              ? ((d = s - p), (p = 0))
              : -p + s > r && (d = r + p)
            : p < 0
            ? ((d = s + p), (p = 0))
            : p + s > r && (d = r - p),
            e.isHorizontal()
              ? (n.transform("translate3d(" + p + "px, 0, 0)"),
                (n[0].style.width = d + "px"))
              : (n.transform("translate3d(0px, " + p + "px, 0)"),
                (n[0].style.height = d + "px")),
            o.hide &&
              (clearTimeout(e.scrollbar.timeout),
              (l[0].style.opacity = 1),
              (e.scrollbar.timeout = setTimeout(function () {
                (l[0].style.opacity = 0), l.transition(400);
              }, 1e3)));
        }
      },
      setTransition: function (e) {
        var t = this;
        t.params.scrollbar.el &&
          t.scrollbar.el &&
          t.scrollbar.$dragEl.transition(e);
      },
      updateSize: function () {
        var e = this;
        if (e.params.scrollbar.el && e.scrollbar.el) {
          var t = e.scrollbar,
            a = t.$dragEl,
            i = t.$el;
          (a[0].style.width = ""), (a[0].style.height = "");
          var s,
            r = e.isHorizontal() ? i[0].offsetWidth : i[0].offsetHeight,
            n = e.size / e.virtualSize,
            l = n * (r / e.size);
          (s =
            "auto" === e.params.scrollbar.dragSize
              ? r * n
              : parseInt(e.params.scrollbar.dragSize, 10)),
            e.isHorizontal()
              ? (a[0].style.width = s + "px")
              : (a[0].style.height = s + "px"),
            (i[0].style.display = n >= 1 ? "none" : ""),
            e.params.scrollbar.hide && (i[0].style.opacity = 0),
            S(t, { trackSize: r, divider: n, moveDivider: l, dragSize: s }),
            t.$el[
              e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"
            ](e.params.scrollbar.lockClass);
        }
      },
      getPointerPosition: function (e) {
        return this.isHorizontal()
          ? "touchstart" === e.type || "touchmove" === e.type
            ? e.targetTouches[0].clientX
            : e.clientX
          : "touchstart" === e.type || "touchmove" === e.type
          ? e.targetTouches[0].clientY
          : e.clientY;
      },
      setDragPosition: function (e) {
        var t,
          a = this,
          i = a.scrollbar,
          s = a.rtlTranslate,
          r = i.$el,
          n = i.dragSize,
          l = i.trackSize,
          o = i.dragStartPos;
        (t =
          (i.getPointerPosition(e) -
            r.offset()[a.isHorizontal() ? "left" : "top"] -
            (null !== o ? o : n / 2)) /
          (l - n)),
          (t = Math.max(Math.min(t, 1), 0)),
          s && (t = 1 - t);
        var d = a.minTranslate() + (a.maxTranslate() - a.minTranslate()) * t;
        a.updateProgress(d),
          a.setTranslate(d),
          a.updateActiveIndex(),
          a.updateSlidesClasses();
      },
      onDragStart: function (e) {
        var t = this,
          a = t.params.scrollbar,
          i = t.scrollbar,
          s = t.$wrapperEl,
          r = i.$el,
          n = i.$dragEl;
        (t.scrollbar.isTouched = !0),
          (t.scrollbar.dragStartPos =
            e.target === n[0] || e.target === n
              ? i.getPointerPosition(e) -
                e.target.getBoundingClientRect()[
                  t.isHorizontal() ? "left" : "top"
                ]
              : null),
          e.preventDefault(),
          e.stopPropagation(),
          s.transition(100),
          n.transition(100),
          i.setDragPosition(e),
          clearTimeout(t.scrollbar.dragTimeout),
          r.transition(0),
          a.hide && r.css("opacity", 1),
          t.params.cssMode && t.$wrapperEl.css("scroll-snap-type", "none"),
          t.emit("scrollbarDragStart", e);
      },
      onDragMove: function (e) {
        var t = this,
          a = t.scrollbar,
          i = t.$wrapperEl,
          s = a.$el,
          r = a.$dragEl;
        t.scrollbar.isTouched &&
          (e.preventDefault ? e.preventDefault() : (e.returnValue = !1),
          a.setDragPosition(e),
          i.transition(0),
          s.transition(0),
          r.transition(0),
          t.emit("scrollbarDragMove", e));
      },
      onDragEnd: function (e) {
        var t = this,
          a = t.params.scrollbar,
          i = t.scrollbar,
          s = t.$wrapperEl,
          r = i.$el;
        t.scrollbar.isTouched &&
          ((t.scrollbar.isTouched = !1),
          t.params.cssMode &&
            (t.$wrapperEl.css("scroll-snap-type", ""), s.transition("")),
          a.hide &&
            (clearTimeout(t.scrollbar.dragTimeout),
            (t.scrollbar.dragTimeout = E(function () {
              r.css("opacity", 0), r.transition(400);
            }, 1e3))),
          t.emit("scrollbarDragEnd", e),
          a.snapOnRelease && t.slideToClosest());
      },
      enableDraggable: function () {
        var e = this;
        if (e.params.scrollbar.el) {
          var t = r(),
            a = e.scrollbar,
            i = e.touchEventsTouch,
            s = e.touchEventsDesktop,
            n = e.params,
            l = e.support,
            o = a.$el[0],
            d = !(!l.passiveListener || !n.passiveListeners) && {
              passive: !1,
              capture: !1,
            },
            p = !(!l.passiveListener || !n.passiveListeners) && {
              passive: !0,
              capture: !1,
            };
          l.touch
            ? (o.addEventListener(i.start, e.scrollbar.onDragStart, d),
              o.addEventListener(i.move, e.scrollbar.onDragMove, d),
              o.addEventListener(i.end, e.scrollbar.onDragEnd, p))
            : (o.addEventListener(s.start, e.scrollbar.onDragStart, d),
              t.addEventListener(s.move, e.scrollbar.onDragMove, d),
              t.addEventListener(s.end, e.scrollbar.onDragEnd, p));
        }
      },
      disableDraggable: function () {
        var e = this;
        if (e.params.scrollbar.el) {
          var t = r(),
            a = e.scrollbar,
            i = e.touchEventsTouch,
            s = e.touchEventsDesktop,
            n = e.params,
            l = e.support,
            o = a.$el[0],
            d = !(!l.passiveListener || !n.passiveListeners) && {
              passive: !1,
              capture: !1,
            },
            p = !(!l.passiveListener || !n.passiveListeners) && {
              passive: !0,
              capture: !1,
            };
          l.touch
            ? (o.removeEventListener(i.start, e.scrollbar.onDragStart, d),
              o.removeEventListener(i.move, e.scrollbar.onDragMove, d),
              o.removeEventListener(i.end, e.scrollbar.onDragEnd, p))
            : (o.removeEventListener(s.start, e.scrollbar.onDragStart, d),
              t.removeEventListener(s.move, e.scrollbar.onDragMove, d),
              t.removeEventListener(s.end, e.scrollbar.onDragEnd, p));
        }
      },
      init: function () {
        var e = this;
        if (e.params.scrollbar.el) {
          var t = e.scrollbar,
            a = e.$el,
            i = e.params.scrollbar,
            s = m(i.el);
          e.params.uniqueNavElements &&
            "string" == typeof i.el &&
            s.length > 1 &&
            1 === a.find(i.el).length &&
            (s = a.find(i.el));
          var r = s.find("." + e.params.scrollbar.dragClass);
          0 === r.length &&
            ((r = m(
              '<div class="' + e.params.scrollbar.dragClass + '"></div>'
            )),
            s.append(r)),
            S(t, { $el: s, el: s[0], $dragEl: r, dragEl: r[0] }),
            i.draggable && t.enableDraggable();
        }
      },
      destroy: function () {
        this.scrollbar.disableDraggable();
      },
    },
    Q = {
      setTransform: function (e, t) {
        var a = this.rtl,
          i = m(e),
          s = a ? -1 : 1,
          r = i.attr("data-swiper-parallax") || "0",
          n = i.attr("data-swiper-parallax-x"),
          l = i.attr("data-swiper-parallax-y"),
          o = i.attr("data-swiper-parallax-scale"),
          d = i.attr("data-swiper-parallax-opacity");
        if (
          (n || l
            ? ((n = n || "0"), (l = l || "0"))
            : this.isHorizontal()
            ? ((n = r), (l = "0"))
            : ((l = r), (n = "0")),
          (n =
            n.indexOf("%") >= 0
              ? parseInt(n, 10) * t * s + "%"
              : n * t * s + "px"),
          (l = l.indexOf("%") >= 0 ? parseInt(l, 10) * t + "%" : l * t + "px"),
          null != d)
        ) {
          var p = d - (d - 1) * (1 - Math.abs(t));
          i[0].style.opacity = p;
        }
        if (null == o) i.transform("translate3d(" + n + ", " + l + ", 0px)");
        else {
          var u = o - (o - 1) * (1 - Math.abs(t));
          i.transform(
            "translate3d(" + n + ", " + l + ", 0px) scale(" + u + ")"
          );
        }
      },
      setTranslate: function () {
        var e = this,
          t = e.$el,
          a = e.slides,
          i = e.progress,
          s = e.snapGrid;
        t
          .children(
            "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]"
          )
          .each(function (t) {
            e.parallax.setTransform(t, i);
          }),
          a.each(function (t, a) {
            var r = t.progress;
            e.params.slidesPerGroup > 1 &&
              "auto" !== e.params.slidesPerView &&
              (r += Math.ceil(a / 2) - i * (s.length - 1)),
              (r = Math.min(Math.max(r, -1), 1)),
              m(t)
                .find(
                  "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]"
                )
                .each(function (t) {
                  e.parallax.setTransform(t, r);
                });
          });
      },
      setTransition: function (e) {
        void 0 === e && (e = this.params.speed);
        this.$el
          .find(
            "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]"
          )
          .each(function (t) {
            var a = m(t),
              i = parseInt(a.attr("data-swiper-parallax-duration"), 10) || e;
            0 === e && (i = 0), a.transition(i);
          });
      },
    },
    ee = {
      getDistanceBetweenTouches: function (e) {
        if (e.targetTouches.length < 2) return 1;
        var t = e.targetTouches[0].pageX,
          a = e.targetTouches[0].pageY,
          i = e.targetTouches[1].pageX,
          s = e.targetTouches[1].pageY;
        return Math.sqrt(Math.pow(i - t, 2) + Math.pow(s - a, 2));
      },
      onGestureStart: function (e) {
        var t = this,
          a = t.support,
          i = t.params.zoom,
          s = t.zoom,
          r = s.gesture;
        if (
          ((s.fakeGestureTouched = !1), (s.fakeGestureMoved = !1), !a.gestures)
        ) {
          if (
            "touchstart" !== e.type ||
            ("touchstart" === e.type && e.targetTouches.length < 2)
          )
            return;
          (s.fakeGestureTouched = !0),
            (r.scaleStart = ee.getDistanceBetweenTouches(e));
        }
        (r.$slideEl && r.$slideEl.length) ||
        ((r.$slideEl = m(e.target).closest("." + t.params.slideClass)),
        0 === r.$slideEl.length && (r.$slideEl = t.slides.eq(t.activeIndex)),
        (r.$imageEl = r.$slideEl.find(
          "img, svg, canvas, picture, .swiper-zoom-target"
        )),
        (r.$imageWrapEl = r.$imageEl.parent("." + i.containerClass)),
        (r.maxRatio = r.$imageWrapEl.attr("data-swiper-zoom") || i.maxRatio),
        0 !== r.$imageWrapEl.length)
          ? (r.$imageEl && r.$imageEl.transition(0), (t.zoom.isScaling = !0))
          : (r.$imageEl = void 0);
      },
      onGestureChange: function (e) {
        var t = this,
          a = t.support,
          i = t.params.zoom,
          s = t.zoom,
          r = s.gesture;
        if (!a.gestures) {
          if (
            "touchmove" !== e.type ||
            ("touchmove" === e.type && e.targetTouches.length < 2)
          )
            return;
          (s.fakeGestureMoved = !0),
            (r.scaleMove = ee.getDistanceBetweenTouches(e));
        }
        r.$imageEl && 0 !== r.$imageEl.length
          ? (a.gestures
              ? (s.scale = e.scale * s.currentScale)
              : (s.scale = (r.scaleMove / r.scaleStart) * s.currentScale),
            s.scale > r.maxRatio &&
              (s.scale =
                r.maxRatio - 1 + Math.pow(s.scale - r.maxRatio + 1, 0.5)),
            s.scale < i.minRatio &&
              (s.scale =
                i.minRatio + 1 - Math.pow(i.minRatio - s.scale + 1, 0.5)),
            r.$imageEl.transform("translate3d(0,0,0) scale(" + s.scale + ")"))
          : "gesturechange" === e.type && s.onGestureStart(e);
      },
      onGestureEnd: function (e) {
        var t = this,
          a = t.device,
          i = t.support,
          s = t.params.zoom,
          r = t.zoom,
          n = r.gesture;
        if (!i.gestures) {
          if (!r.fakeGestureTouched || !r.fakeGestureMoved) return;
          if (
            "touchend" !== e.type ||
            ("touchend" === e.type && e.changedTouches.length < 2 && !a.android)
          )
            return;
          (r.fakeGestureTouched = !1), (r.fakeGestureMoved = !1);
        }
        n.$imageEl &&
          0 !== n.$imageEl.length &&
          ((r.scale = Math.max(Math.min(r.scale, n.maxRatio), s.minRatio)),
          n.$imageEl
            .transition(t.params.speed)
            .transform("translate3d(0,0,0) scale(" + r.scale + ")"),
          (r.currentScale = r.scale),
          (r.isScaling = !1),
          1 === r.scale && (n.$slideEl = void 0));
      },
      onTouchStart: function (e) {
        var t = this.device,
          a = this.zoom,
          i = a.gesture,
          s = a.image;
        i.$imageEl &&
          0 !== i.$imageEl.length &&
          (s.isTouched ||
            (t.android && e.cancelable && e.preventDefault(),
            (s.isTouched = !0),
            (s.touchesStart.x =
              "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX),
            (s.touchesStart.y =
              "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY)));
      },
      onTouchMove: function (e) {
        var t = this,
          a = t.zoom,
          i = a.gesture,
          s = a.image,
          r = a.velocity;
        if (
          i.$imageEl &&
          0 !== i.$imageEl.length &&
          ((t.allowClick = !1), s.isTouched && i.$slideEl)
        ) {
          s.isMoved ||
            ((s.width = i.$imageEl[0].offsetWidth),
            (s.height = i.$imageEl[0].offsetHeight),
            (s.startX = T(i.$imageWrapEl[0], "x") || 0),
            (s.startY = T(i.$imageWrapEl[0], "y") || 0),
            (i.slideWidth = i.$slideEl[0].offsetWidth),
            (i.slideHeight = i.$slideEl[0].offsetHeight),
            i.$imageWrapEl.transition(0),
            t.rtl && ((s.startX = -s.startX), (s.startY = -s.startY)));
          var n = s.width * a.scale,
            l = s.height * a.scale;
          if (!(n < i.slideWidth && l < i.slideHeight)) {
            if (
              ((s.minX = Math.min(i.slideWidth / 2 - n / 2, 0)),
              (s.maxX = -s.minX),
              (s.minY = Math.min(i.slideHeight / 2 - l / 2, 0)),
              (s.maxY = -s.minY),
              (s.touchesCurrent.x =
                "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX),
              (s.touchesCurrent.y =
                "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY),
              !s.isMoved && !a.isScaling)
            ) {
              if (
                t.isHorizontal() &&
                ((Math.floor(s.minX) === Math.floor(s.startX) &&
                  s.touchesCurrent.x < s.touchesStart.x) ||
                  (Math.floor(s.maxX) === Math.floor(s.startX) &&
                    s.touchesCurrent.x > s.touchesStart.x))
              )
                return void (s.isTouched = !1);
              if (
                !t.isHorizontal() &&
                ((Math.floor(s.minY) === Math.floor(s.startY) &&
                  s.touchesCurrent.y < s.touchesStart.y) ||
                  (Math.floor(s.maxY) === Math.floor(s.startY) &&
                    s.touchesCurrent.y > s.touchesStart.y))
              )
                return void (s.isTouched = !1);
            }
            e.cancelable && e.preventDefault(),
              e.stopPropagation(),
              (s.isMoved = !0),
              (s.currentX = s.touchesCurrent.x - s.touchesStart.x + s.startX),
              (s.currentY = s.touchesCurrent.y - s.touchesStart.y + s.startY),
              s.currentX < s.minX &&
                (s.currentX =
                  s.minX + 1 - Math.pow(s.minX - s.currentX + 1, 0.8)),
              s.currentX > s.maxX &&
                (s.currentX =
                  s.maxX - 1 + Math.pow(s.currentX - s.maxX + 1, 0.8)),
              s.currentY < s.minY &&
                (s.currentY =
                  s.minY + 1 - Math.pow(s.minY - s.currentY + 1, 0.8)),
              s.currentY > s.maxY &&
                (s.currentY =
                  s.maxY - 1 + Math.pow(s.currentY - s.maxY + 1, 0.8)),
              r.prevPositionX || (r.prevPositionX = s.touchesCurrent.x),
              r.prevPositionY || (r.prevPositionY = s.touchesCurrent.y),
              r.prevTime || (r.prevTime = Date.now()),
              (r.x =
                (s.touchesCurrent.x - r.prevPositionX) /
                (Date.now() - r.prevTime) /
                2),
              (r.y =
                (s.touchesCurrent.y - r.prevPositionY) /
                (Date.now() - r.prevTime) /
                2),
              Math.abs(s.touchesCurrent.x - r.prevPositionX) < 2 && (r.x = 0),
              Math.abs(s.touchesCurrent.y - r.prevPositionY) < 2 && (r.y = 0),
              (r.prevPositionX = s.touchesCurrent.x),
              (r.prevPositionY = s.touchesCurrent.y),
              (r.prevTime = Date.now()),
              i.$imageWrapEl.transform(
                "translate3d(" + s.currentX + "px, " + s.currentY + "px,0)"
              );
          }
        }
      },
      onTouchEnd: function () {
        var e = this.zoom,
          t = e.gesture,
          a = e.image,
          i = e.velocity;
        if (t.$imageEl && 0 !== t.$imageEl.length) {
          if (!a.isTouched || !a.isMoved)
            return (a.isTouched = !1), void (a.isMoved = !1);
          (a.isTouched = !1), (a.isMoved = !1);
          var s = 300,
            r = 300,
            n = i.x * s,
            l = a.currentX + n,
            o = i.y * r,
            d = a.currentY + o;
          0 !== i.x && (s = Math.abs((l - a.currentX) / i.x)),
            0 !== i.y && (r = Math.abs((d - a.currentY) / i.y));
          var p = Math.max(s, r);
          (a.currentX = l), (a.currentY = d);
          var u = a.width * e.scale,
            c = a.height * e.scale;
          (a.minX = Math.min(t.slideWidth / 2 - u / 2, 0)),
            (a.maxX = -a.minX),
            (a.minY = Math.min(t.slideHeight / 2 - c / 2, 0)),
            (a.maxY = -a.minY),
            (a.currentX = Math.max(Math.min(a.currentX, a.maxX), a.minX)),
            (a.currentY = Math.max(Math.min(a.currentY, a.maxY), a.minY)),
            t.$imageWrapEl
              .transition(p)
              .transform(
                "translate3d(" + a.currentX + "px, " + a.currentY + "px,0)"
              );
        }
      },
      onTransitionEnd: function () {
        var e = this,
          t = e.zoom,
          a = t.gesture;
        a.$slideEl &&
          e.previousIndex !== e.activeIndex &&
          (a.$imageEl && a.$imageEl.transform("translate3d(0,0,0) scale(1)"),
          a.$imageWrapEl && a.$imageWrapEl.transform("translate3d(0,0,0)"),
          (t.scale = 1),
          (t.currentScale = 1),
          (a.$slideEl = void 0),
          (a.$imageEl = void 0),
          (a.$imageWrapEl = void 0));
      },
      toggle: function (e) {
        var t = this.zoom;
        t.scale && 1 !== t.scale ? t.out() : t.in(e);
      },
      in: function (e) {
        var t,
          a,
          i,
          s,
          r,
          n,
          l,
          o,
          d,
          p,
          u,
          c,
          h,
          v,
          f,
          m,
          g = this,
          y = g.zoom,
          w = g.params.zoom,
          b = y.gesture,
          E = y.image;
        (b.$slideEl ||
          (g.params.virtual && g.params.virtual.enabled && g.virtual
            ? (b.$slideEl = g.$wrapperEl.children(
                "." + g.params.slideActiveClass
              ))
            : (b.$slideEl = g.slides.eq(g.activeIndex)),
          (b.$imageEl = b.$slideEl.find(
            "img, svg, canvas, picture, .swiper-zoom-target"
          )),
          (b.$imageWrapEl = b.$imageEl.parent("." + w.containerClass))),
        b.$imageEl && 0 !== b.$imageEl.length) &&
          (b.$slideEl.addClass("" + w.zoomedSlideClass),
          void 0 === E.touchesStart.x && e
            ? ((t =
                "touchend" === e.type ? e.changedTouches[0].pageX : e.pageX),
              (a = "touchend" === e.type ? e.changedTouches[0].pageY : e.pageY))
            : ((t = E.touchesStart.x), (a = E.touchesStart.y)),
          (y.scale = b.$imageWrapEl.attr("data-swiper-zoom") || w.maxRatio),
          (y.currentScale =
            b.$imageWrapEl.attr("data-swiper-zoom") || w.maxRatio),
          e
            ? ((f = b.$slideEl[0].offsetWidth),
              (m = b.$slideEl[0].offsetHeight),
              (i = b.$slideEl.offset().left + f / 2 - t),
              (s = b.$slideEl.offset().top + m / 2 - a),
              (l = b.$imageEl[0].offsetWidth),
              (o = b.$imageEl[0].offsetHeight),
              (d = l * y.scale),
              (p = o * y.scale),
              (h = -(u = Math.min(f / 2 - d / 2, 0))),
              (v = -(c = Math.min(m / 2 - p / 2, 0))),
              (r = i * y.scale) < u && (r = u),
              r > h && (r = h),
              (n = s * y.scale) < c && (n = c),
              n > v && (n = v))
            : ((r = 0), (n = 0)),
          b.$imageWrapEl
            .transition(300)
            .transform("translate3d(" + r + "px, " + n + "px,0)"),
          b.$imageEl
            .transition(300)
            .transform("translate3d(0,0,0) scale(" + y.scale + ")"));
      },
      out: function () {
        var e = this,
          t = e.zoom,
          a = e.params.zoom,
          i = t.gesture;
        i.$slideEl ||
          (e.params.virtual && e.params.virtual.enabled && e.virtual
            ? (i.$slideEl = e.$wrapperEl.children(
                "." + e.params.slideActiveClass
              ))
            : (i.$slideEl = e.slides.eq(e.activeIndex)),
          (i.$imageEl = i.$slideEl.find(
            "img, svg, canvas, picture, .swiper-zoom-target"
          )),
          (i.$imageWrapEl = i.$imageEl.parent("." + a.containerClass))),
          i.$imageEl &&
            0 !== i.$imageEl.length &&
            ((t.scale = 1),
            (t.currentScale = 1),
            i.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"),
            i.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"),
            i.$slideEl.removeClass("" + a.zoomedSlideClass),
            (i.$slideEl = void 0));
      },
      toggleGestures: function (e) {
        var t = this,
          a = t.zoom,
          i = a.slideSelector,
          s = a.passiveListener;
        t.$wrapperEl[e]("gesturestart", i, a.onGestureStart, s),
          t.$wrapperEl[e]("gesturechange", i, a.onGestureChange, s),
          t.$wrapperEl[e]("gestureend", i, a.onGestureEnd, s);
      },
      enableGestures: function () {
        this.zoom.gesturesEnabled ||
          ((this.zoom.gesturesEnabled = !0), this.zoom.toggleGestures("on"));
      },
      disableGestures: function () {
        this.zoom.gesturesEnabled &&
          ((this.zoom.gesturesEnabled = !1), this.zoom.toggleGestures("off"));
      },
      enable: function () {
        var e = this,
          t = e.support,
          a = e.zoom;
        if (!a.enabled) {
          a.enabled = !0;
          var i = !(
              "touchstart" !== e.touchEvents.start ||
              !t.passiveListener ||
              !e.params.passiveListeners
            ) && { passive: !0, capture: !1 },
            s = !t.passiveListener || { passive: !1, capture: !0 },
            r = "." + e.params.slideClass;
          (e.zoom.passiveListener = i),
            (e.zoom.slideSelector = r),
            t.gestures
              ? (e.$wrapperEl.on(e.touchEvents.start, e.zoom.enableGestures, i),
                e.$wrapperEl.on(e.touchEvents.end, e.zoom.disableGestures, i))
              : "touchstart" === e.touchEvents.start &&
                (e.$wrapperEl.on(e.touchEvents.start, r, a.onGestureStart, i),
                e.$wrapperEl.on(e.touchEvents.move, r, a.onGestureChange, s),
                e.$wrapperEl.on(e.touchEvents.end, r, a.onGestureEnd, i),
                e.touchEvents.cancel &&
                  e.$wrapperEl.on(e.touchEvents.cancel, r, a.onGestureEnd, i)),
            e.$wrapperEl.on(
              e.touchEvents.move,
              "." + e.params.zoom.containerClass,
              a.onTouchMove,
              s
            );
        }
      },
      disable: function () {
        var e = this,
          t = e.zoom;
        if (t.enabled) {
          var a = e.support;
          e.zoom.enabled = !1;
          var i = !(
              "touchstart" !== e.touchEvents.start ||
              !a.passiveListener ||
              !e.params.passiveListeners
            ) && { passive: !0, capture: !1 },
            s = !a.passiveListener || { passive: !1, capture: !0 },
            r = "." + e.params.slideClass;
          a.gestures
            ? (e.$wrapperEl.off(e.touchEvents.start, e.zoom.enableGestures, i),
              e.$wrapperEl.off(e.touchEvents.end, e.zoom.disableGestures, i))
            : "touchstart" === e.touchEvents.start &&
              (e.$wrapperEl.off(e.touchEvents.start, r, t.onGestureStart, i),
              e.$wrapperEl.off(e.touchEvents.move, r, t.onGestureChange, s),
              e.$wrapperEl.off(e.touchEvents.end, r, t.onGestureEnd, i),
              e.touchEvents.cancel &&
                e.$wrapperEl.off(e.touchEvents.cancel, r, t.onGestureEnd, i)),
            e.$wrapperEl.off(
              e.touchEvents.move,
              "." + e.params.zoom.containerClass,
              t.onTouchMove,
              s
            );
        }
      },
    },
    te = {
      loadInSlide: function (e, t) {
        void 0 === t && (t = !0);
        var a = this,
          i = a.params.lazy;
        if (void 0 !== e && 0 !== a.slides.length) {
          var s =
              a.virtual && a.params.virtual.enabled
                ? a.$wrapperEl.children(
                    "." +
                      a.params.slideClass +
                      '[data-swiper-slide-index="' +
                      e +
                      '"]'
                  )
                : a.slides.eq(e),
            r = s.find(
              "." +
                i.elementClass +
                ":not(." +
                i.loadedClass +
                "):not(." +
                i.loadingClass +
                ")"
            );
          !s.hasClass(i.elementClass) ||
            s.hasClass(i.loadedClass) ||
            s.hasClass(i.loadingClass) ||
            r.push(s[0]),
            0 !== r.length &&
              r.each(function (e) {
                var r = m(e);
                r.addClass(i.loadingClass);
                var n = r.attr("data-background"),
                  l = r.attr("data-src"),
                  o = r.attr("data-srcset"),
                  d = r.attr("data-sizes"),
                  p = r.parent("picture");
                a.loadImage(r[0], l || n, o, d, !1, function () {
                  if (null != a && a && (!a || a.params) && !a.destroyed) {
                    if (
                      (n
                        ? (r.css("background-image", 'url("' + n + '")'),
                          r.removeAttr("data-background"))
                        : (o &&
                            (r.attr("srcset", o), r.removeAttr("data-srcset")),
                          d && (r.attr("sizes", d), r.removeAttr("data-sizes")),
                          p.length &&
                            p.children("source").each(function (e) {
                              var t = m(e);
                              t.attr("data-srcset") &&
                                (t.attr("srcset", t.attr("data-srcset")),
                                t.removeAttr("data-srcset"));
                            }),
                          l && (r.attr("src", l), r.removeAttr("data-src"))),
                      r.addClass(i.loadedClass).removeClass(i.loadingClass),
                      s.find("." + i.preloaderClass).remove(),
                      a.params.loop && t)
                    ) {
                      var e = s.attr("data-swiper-slide-index");
                      if (s.hasClass(a.params.slideDuplicateClass)) {
                        var u = a.$wrapperEl.children(
                          '[data-swiper-slide-index="' +
                            e +
                            '"]:not(.' +
                            a.params.slideDuplicateClass +
                            ")"
                        );
                        a.lazy.loadInSlide(u.index(), !1);
                      } else {
                        var c = a.$wrapperEl.children(
                          "." +
                            a.params.slideDuplicateClass +
                            '[data-swiper-slide-index="' +
                            e +
                            '"]'
                        );
                        a.lazy.loadInSlide(c.index(), !1);
                      }
                    }
                    a.emit("lazyImageReady", s[0], r[0]),
                      a.params.autoHeight && a.updateAutoHeight();
                  }
                }),
                  a.emit("lazyImageLoad", s[0], r[0]);
              });
        }
      },
      load: function () {
        var e = this,
          t = e.$wrapperEl,
          a = e.params,
          i = e.slides,
          s = e.activeIndex,
          r = e.virtual && a.virtual.enabled,
          n = a.lazy,
          l = a.slidesPerView;
        function o(e) {
          if (r) {
            if (
              t.children(
                "." + a.slideClass + '[data-swiper-slide-index="' + e + '"]'
              ).length
            )
              return !0;
          } else if (i[e]) return !0;
          return !1;
        }
        function d(e) {
          return r ? m(e).attr("data-swiper-slide-index") : m(e).index();
        }
        if (
          ("auto" === l && (l = 0),
          e.lazy.initialImageLoaded || (e.lazy.initialImageLoaded = !0),
          e.params.watchSlidesVisibility)
        )
          t.children("." + a.slideVisibleClass).each(function (t) {
            var a = r ? m(t).attr("data-swiper-slide-index") : m(t).index();
            e.lazy.loadInSlide(a);
          });
        else if (l > 1)
          for (var p = s; p < s + l; p += 1) o(p) && e.lazy.loadInSlide(p);
        else e.lazy.loadInSlide(s);
        if (n.loadPrevNext)
          if (l > 1 || (n.loadPrevNextAmount && n.loadPrevNextAmount > 1)) {
            for (
              var u = n.loadPrevNextAmount,
                c = l,
                h = Math.min(s + c + Math.max(u, c), i.length),
                v = Math.max(s - Math.max(c, u), 0),
                f = s + l;
              f < h;
              f += 1
            )
              o(f) && e.lazy.loadInSlide(f);
            for (var g = v; g < s; g += 1) o(g) && e.lazy.loadInSlide(g);
          } else {
            var y = t.children("." + a.slideNextClass);
            y.length > 0 && e.lazy.loadInSlide(d(y));
            var w = t.children("." + a.slidePrevClass);
            w.length > 0 && e.lazy.loadInSlide(d(w));
          }
      },
      checkInViewOnLoad: function () {
        var e = l(),
          t = this;
        if (t && !t.destroyed) {
          var a = t.params.lazy.scrollingElement
              ? m(t.params.lazy.scrollingElement)
              : m(e),
            i = a[0] === e,
            s = i ? e.innerWidth : a[0].offsetWidth,
            r = i ? e.innerHeight : a[0].offsetHeight,
            n = t.$el.offset(),
            o = !1;
          t.rtlTranslate && (n.left -= t.$el[0].scrollLeft);
          for (
            var d = [
                [n.left, n.top],
                [n.left + t.width, n.top],
                [n.left, n.top + t.height],
                [n.left + t.width, n.top + t.height],
              ],
              p = 0;
            p < d.length;
            p += 1
          ) {
            var u = d[p];
            if (u[0] >= 0 && u[0] <= s && u[1] >= 0 && u[1] <= r) {
              if (0 === u[0] && 0 === u[1]) continue;
              o = !0;
            }
          }
          o
            ? (t.lazy.load(), a.off("scroll", t.lazy.checkInViewOnLoad))
            : t.lazy.scrollHandlerAttached ||
              ((t.lazy.scrollHandlerAttached = !0),
              a.on("scroll", t.lazy.checkInViewOnLoad));
        }
      },
    },
    ae = {
      LinearSpline: function (e, t) {
        var a,
          i,
          s,
          r,
          n,
          l = function (e, t) {
            for (i = -1, a = e.length; a - i > 1; )
              e[(s = (a + i) >> 1)] <= t ? (i = s) : (a = s);
            return a;
          };
        return (
          (this.x = e),
          (this.y = t),
          (this.lastIndex = e.length - 1),
          (this.interpolate = function (e) {
            return e
              ? ((n = l(this.x, e)),
                (r = n - 1),
                ((e - this.x[r]) * (this.y[n] - this.y[r])) /
                  (this.x[n] - this.x[r]) +
                  this.y[r])
              : 0;
          }),
          this
        );
      },
      getInterpolateFunction: function (e) {
        var t = this;
        t.controller.spline ||
          (t.controller.spline = t.params.loop
            ? new ae.LinearSpline(t.slidesGrid, e.slidesGrid)
            : new ae.LinearSpline(t.snapGrid, e.snapGrid));
      },
      setTranslate: function (e, t) {
        var a,
          i,
          s = this,
          r = s.controller.control,
          n = s.constructor;
        function l(e) {
          var t = s.rtlTranslate ? -s.translate : s.translate;
          "slide" === s.params.controller.by &&
            (s.controller.getInterpolateFunction(e),
            (i = -s.controller.spline.interpolate(-t))),
            (i && "container" !== s.params.controller.by) ||
              ((a =
                (e.maxTranslate() - e.minTranslate()) /
                (s.maxTranslate() - s.minTranslate())),
              (i = (t - s.minTranslate()) * a + e.minTranslate())),
            s.params.controller.inverse && (i = e.maxTranslate() - i),
            e.updateProgress(i),
            e.setTranslate(i, s),
            e.updateActiveIndex(),
            e.updateSlidesClasses();
        }
        if (Array.isArray(r))
          for (var o = 0; o < r.length; o += 1)
            r[o] !== t && r[o] instanceof n && l(r[o]);
        else r instanceof n && t !== r && l(r);
      },
      setTransition: function (e, t) {
        var a,
          i = this,
          s = i.constructor,
          r = i.controller.control;
        function n(t) {
          t.setTransition(e, i),
            0 !== e &&
              (t.transitionStart(),
              t.params.autoHeight &&
                E(function () {
                  t.updateAutoHeight();
                }),
              t.$wrapperEl.transitionEnd(function () {
                r &&
                  (t.params.loop &&
                    "slide" === i.params.controller.by &&
                    t.loopFix(),
                  t.transitionEnd());
              }));
        }
        if (Array.isArray(r))
          for (a = 0; a < r.length; a += 1)
            r[a] !== t && r[a] instanceof s && n(r[a]);
        else r instanceof s && t !== r && n(r);
      },
    },
    ie = {
      getRandomNumber: function (e) {
        void 0 === e && (e = 16);
        return "x".repeat(e).replace(/x/g, function () {
          return Math.round(16 * Math.random()).toString(16);
        });
      },
      makeElFocusable: function (e) {
        return e.attr("tabIndex", "0"), e;
      },
      makeElNotFocusable: function (e) {
        return e.attr("tabIndex", "-1"), e;
      },
      addElRole: function (e, t) {
        return e.attr("role", t), e;
      },
      addElRoleDescription: function (e, t) {
        return e.attr("aria-role-description", t), e;
      },
      addElControls: function (e, t) {
        return e.attr("aria-controls", t), e;
      },
      addElLabel: function (e, t) {
        return e.attr("aria-label", t), e;
      },
      addElId: function (e, t) {
        return e.attr("id", t), e;
      },
      addElLive: function (e, t) {
        return e.attr("aria-live", t), e;
      },
      disableEl: function (e) {
        return e.attr("aria-disabled", !0), e;
      },
      enableEl: function (e) {
        return e.attr("aria-disabled", !1), e;
      },
      onEnterKey: function (e) {
        var t = this,
          a = t.params.a11y;
        if (13 === e.keyCode) {
          var i = m(e.target);
          t.navigation &&
            t.navigation.$nextEl &&
            i.is(t.navigation.$nextEl) &&
            ((t.isEnd && !t.params.loop) || t.slideNext(),
            t.isEnd
              ? t.a11y.notify(a.lastSlideMessage)
              : t.a11y.notify(a.nextSlideMessage)),
            t.navigation &&
              t.navigation.$prevEl &&
              i.is(t.navigation.$prevEl) &&
              ((t.isBeginning && !t.params.loop) || t.slidePrev(),
              t.isBeginning
                ? t.a11y.notify(a.firstSlideMessage)
                : t.a11y.notify(a.prevSlideMessage)),
            t.pagination &&
              i.is("." + t.params.pagination.bulletClass.replace(/ /g, ".")) &&
              i[0].click();
        }
      },
      notify: function (e) {
        var t = this.a11y.liveRegion;
        0 !== t.length && (t.html(""), t.html(e));
      },
      updateNavigation: function () {
        var e = this;
        if (!e.params.loop && e.navigation) {
          var t = e.navigation,
            a = t.$nextEl,
            i = t.$prevEl;
          i &&
            i.length > 0 &&
            (e.isBeginning
              ? (e.a11y.disableEl(i), e.a11y.makeElNotFocusable(i))
              : (e.a11y.enableEl(i), e.a11y.makeElFocusable(i))),
            a &&
              a.length > 0 &&
              (e.isEnd
                ? (e.a11y.disableEl(a), e.a11y.makeElNotFocusable(a))
                : (e.a11y.enableEl(a), e.a11y.makeElFocusable(a)));
        }
      },
      updatePagination: function () {
        var e = this,
          t = e.params.a11y;
        e.pagination &&
          e.params.pagination.clickable &&
          e.pagination.bullets &&
          e.pagination.bullets.length &&
          e.pagination.bullets.each(function (a) {
            var i = m(a);
            e.a11y.makeElFocusable(i),
              e.params.pagination.renderBullet ||
                (e.a11y.addElRole(i, "button"),
                e.a11y.addElLabel(
                  i,
                  t.paginationBulletMessage.replace(
                    /\{\{index\}\}/,
                    i.index() + 1
                  )
                ));
          });
      },
      init: function () {
        var e = this,
          t = e.params.a11y;
        e.$el.append(e.a11y.liveRegion);
        var a = e.$el;
        t.containerRoleDescriptionMessage &&
          e.a11y.addElRoleDescription(a, t.containerRoleDescriptionMessage),
          t.containerMessage && e.a11y.addElLabel(a, t.containerMessage);
        var i,
          s,
          r,
          n = e.$wrapperEl,
          l = n.attr("id") || "swiper-wrapper-" + e.a11y.getRandomNumber(16);
        e.a11y.addElId(n, l),
          (i =
            e.params.autoplay && e.params.autoplay.enabled ? "off" : "polite"),
          e.a11y.addElLive(n, i),
          t.itemRoleDescriptionMessage &&
            e.a11y.addElRoleDescription(
              m(e.slides),
              t.itemRoleDescriptionMessage
            ),
          e.a11y.addElRole(m(e.slides), "group"),
          e.slides.each(function (t) {
            var a = m(t);
            e.a11y.addElLabel(a, a.index() + 1 + " / " + e.slides.length);
          }),
          e.navigation && e.navigation.$nextEl && (s = e.navigation.$nextEl),
          e.navigation && e.navigation.$prevEl && (r = e.navigation.$prevEl),
          s &&
            s.length &&
            (e.a11y.makeElFocusable(s),
            "BUTTON" !== s[0].tagName &&
              (e.a11y.addElRole(s, "button"),
              s.on("keydown", e.a11y.onEnterKey)),
            e.a11y.addElLabel(s, t.nextSlideMessage),
            e.a11y.addElControls(s, l)),
          r &&
            r.length &&
            (e.a11y.makeElFocusable(r),
            "BUTTON" !== r[0].tagName &&
              (e.a11y.addElRole(r, "button"),
              r.on("keydown", e.a11y.onEnterKey)),
            e.a11y.addElLabel(r, t.prevSlideMessage),
            e.a11y.addElControls(r, l)),
          e.pagination &&
            e.params.pagination.clickable &&
            e.pagination.bullets &&
            e.pagination.bullets.length &&
            e.pagination.$el.on(
              "keydown",
              "." + e.params.pagination.bulletClass.replace(/ /g, "."),
              e.a11y.onEnterKey
            );
      },
      destroy: function () {
        var e,
          t,
          a = this;
        a.a11y.liveRegion &&
          a.a11y.liveRegion.length > 0 &&
          a.a11y.liveRegion.remove(),
          a.navigation && a.navigation.$nextEl && (e = a.navigation.$nextEl),
          a.navigation && a.navigation.$prevEl && (t = a.navigation.$prevEl),
          e && e.off("keydown", a.a11y.onEnterKey),
          t && t.off("keydown", a.a11y.onEnterKey),
          a.pagination &&
            a.params.pagination.clickable &&
            a.pagination.bullets &&
            a.pagination.bullets.length &&
            a.pagination.$el.off(
              "keydown",
              "." + a.params.pagination.bulletClass.replace(/ /g, "."),
              a.a11y.onEnterKey
            );
      },
    },
    se = {
      init: function () {
        var e = this,
          t = l();
        if (e.params.history) {
          if (!t.history || !t.history.pushState)
            return (
              (e.params.history.enabled = !1),
              void (e.params.hashNavigation.enabled = !0)
            );
          var a = e.history;
          (a.initialized = !0),
            (a.paths = se.getPathValues(e.params.url)),
            (a.paths.key || a.paths.value) &&
              (a.scrollToSlide(0, a.paths.value, e.params.runCallbacksOnInit),
              e.params.history.replaceState ||
                t.addEventListener("popstate", e.history.setHistoryPopState));
        }
      },
      destroy: function () {
        var e = l();
        this.params.history.replaceState ||
          e.removeEventListener("popstate", this.history.setHistoryPopState);
      },
      setHistoryPopState: function () {
        var e = this;
        (e.history.paths = se.getPathValues(e.params.url)),
          e.history.scrollToSlide(e.params.speed, e.history.paths.value, !1);
      },
      getPathValues: function (e) {
        var t = l(),
          a = (e ? new URL(e) : t.location).pathname
            .slice(1)
            .split("/")
            .filter(function (e) {
              return "" !== e;
            }),
          i = a.length;
        return { key: a[i - 2], value: a[i - 1] };
      },
      setHistory: function (e, t) {
        var a = this,
          i = l();
        if (a.history.initialized && a.params.history.enabled) {
          var s;
          s = a.params.url ? new URL(a.params.url) : i.location;
          var r = a.slides.eq(t),
            n = se.slugify(r.attr("data-history"));
          s.pathname.includes(e) || (n = e + "/" + n);
          var o = i.history.state;
          (o && o.value === n) ||
            (a.params.history.replaceState
              ? i.history.replaceState({ value: n }, null, n)
              : i.history.pushState({ value: n }, null, n));
        }
      },
      slugify: function (e) {
        return e
          .toString()
          .replace(/\s+/g, "-")
          .replace(/[^\w-]+/g, "")
          .replace(/--+/g, "-")
          .replace(/^-+/, "")
          .replace(/-+$/, "");
      },
      scrollToSlide: function (e, t, a) {
        var i = this;
        if (t)
          for (var s = 0, r = i.slides.length; s < r; s += 1) {
            var n = i.slides.eq(s);
            if (
              se.slugify(n.attr("data-history")) === t &&
              !n.hasClass(i.params.slideDuplicateClass)
            ) {
              var l = n.index();
              i.slideTo(l, e, a);
            }
          }
        else i.slideTo(0, e, a);
      },
    },
    re = {
      onHashCange: function () {
        var e = this,
          t = r();
        e.emit("hashChange");
        var a = t.location.hash.replace("#", "");
        if (a !== e.slides.eq(e.activeIndex).attr("data-hash")) {
          var i = e.$wrapperEl
            .children("." + e.params.slideClass + '[data-hash="' + a + '"]')
            .index();
          if (void 0 === i) return;
          e.slideTo(i);
        }
      },
      setHash: function () {
        var e = this,
          t = l(),
          a = r();
        if (e.hashNavigation.initialized && e.params.hashNavigation.enabled)
          if (
            e.params.hashNavigation.replaceState &&
            t.history &&
            t.history.replaceState
          )
            t.history.replaceState(
              null,
              null,
              "#" + e.slides.eq(e.activeIndex).attr("data-hash") || ""
            ),
              e.emit("hashSet");
          else {
            var i = e.slides.eq(e.activeIndex),
              s = i.attr("data-hash") || i.attr("data-history");
            (a.location.hash = s || ""), e.emit("hashSet");
          }
      },
      init: function () {
        var e = this,
          t = r(),
          a = l();
        if (
          !(
            !e.params.hashNavigation.enabled ||
            (e.params.history && e.params.history.enabled)
          )
        ) {
          e.hashNavigation.initialized = !0;
          var i = t.location.hash.replace("#", "");
          if (i)
            for (var s = 0, n = e.slides.length; s < n; s += 1) {
              var o = e.slides.eq(s);
              if (
                (o.attr("data-hash") || o.attr("data-history")) === i &&
                !o.hasClass(e.params.slideDuplicateClass)
              ) {
                var d = o.index();
                e.slideTo(d, 0, e.params.runCallbacksOnInit, !0);
              }
            }
          e.params.hashNavigation.watchState &&
            m(a).on("hashchange", e.hashNavigation.onHashCange);
        }
      },
      destroy: function () {
        var e = l();
        this.params.hashNavigation.watchState &&
          m(e).off("hashchange", this.hashNavigation.onHashCange);
      },
    },
    ne = {
      run: function () {
        var e = this,
          t = e.slides.eq(e.activeIndex),
          a = e.params.autoplay.delay;
        t.attr("data-swiper-autoplay") &&
          (a = t.attr("data-swiper-autoplay") || e.params.autoplay.delay),
          clearTimeout(e.autoplay.timeout),
          (e.autoplay.timeout = E(function () {
            var t;
            e.params.autoplay.reverseDirection
              ? e.params.loop
                ? (e.loopFix(),
                  (t = e.slidePrev(e.params.speed, !0, !0)),
                  e.emit("autoplay"))
                : e.isBeginning
                ? e.params.autoplay.stopOnLastSlide
                  ? e.autoplay.stop()
                  : ((t = e.slideTo(
                      e.slides.length - 1,
                      e.params.speed,
                      !0,
                      !0
                    )),
                    e.emit("autoplay"))
                : ((t = e.slidePrev(e.params.speed, !0, !0)),
                  e.emit("autoplay"))
              : e.params.loop
              ? (e.loopFix(),
                (t = e.slideNext(e.params.speed, !0, !0)),
                e.emit("autoplay"))
              : e.isEnd
              ? e.params.autoplay.stopOnLastSlide
                ? e.autoplay.stop()
                : ((t = e.slideTo(0, e.params.speed, !0, !0)),
                  e.emit("autoplay"))
              : ((t = e.slideNext(e.params.speed, !0, !0)), e.emit("autoplay")),
              ((e.params.cssMode && e.autoplay.running) || !1 === t) &&
                e.autoplay.run();
          }, a));
      },
      start: function () {
        var e = this;
        return (
          void 0 === e.autoplay.timeout &&
          !e.autoplay.running &&
          ((e.autoplay.running = !0),
          e.emit("autoplayStart"),
          e.autoplay.run(),
          !0)
        );
      },
      stop: function () {
        var e = this;
        return (
          !!e.autoplay.running &&
          void 0 !== e.autoplay.timeout &&
          (e.autoplay.timeout &&
            (clearTimeout(e.autoplay.timeout), (e.autoplay.timeout = void 0)),
          (e.autoplay.running = !1),
          e.emit("autoplayStop"),
          !0)
        );
      },
      pause: function (e) {
        var t = this;
        t.autoplay.running &&
          (t.autoplay.paused ||
            (t.autoplay.timeout && clearTimeout(t.autoplay.timeout),
            (t.autoplay.paused = !0),
            0 !== e && t.params.autoplay.waitForTransition
              ? (t.$wrapperEl[0].addEventListener(
                  "transitionend",
                  t.autoplay.onTransitionEnd
                ),
                t.$wrapperEl[0].addEventListener(
                  "webkitTransitionEnd",
                  t.autoplay.onTransitionEnd
                ))
              : ((t.autoplay.paused = !1), t.autoplay.run())));
      },
      onVisibilityChange: function () {
        var e = this,
          t = r();
        "hidden" === t.visibilityState &&
          e.autoplay.running &&
          e.autoplay.pause(),
          "visible" === t.visibilityState &&
            e.autoplay.paused &&
            (e.autoplay.run(), (e.autoplay.paused = !1));
      },
      onTransitionEnd: function (e) {
        var t = this;
        t &&
          !t.destroyed &&
          t.$wrapperEl &&
          e.target === t.$wrapperEl[0] &&
          (t.$wrapperEl[0].removeEventListener(
            "transitionend",
            t.autoplay.onTransitionEnd
          ),
          t.$wrapperEl[0].removeEventListener(
            "webkitTransitionEnd",
            t.autoplay.onTransitionEnd
          ),
          (t.autoplay.paused = !1),
          t.autoplay.running ? t.autoplay.run() : t.autoplay.stop());
      },
    },
    le = {
      setTranslate: function () {
        for (var e = this, t = e.slides, a = 0; a < t.length; a += 1) {
          var i = e.slides.eq(a),
            s = -i[0].swiperSlideOffset;
          e.params.virtualTranslate || (s -= e.translate);
          var r = 0;
          e.isHorizontal() || ((r = s), (s = 0));
          var n = e.params.fadeEffect.crossFade
            ? Math.max(1 - Math.abs(i[0].progress), 0)
            : 1 + Math.min(Math.max(i[0].progress, -1), 0);
          i.css({ opacity: n }).transform(
            "translate3d(" + s + "px, " + r + "px, 0px)"
          );
        }
      },
      setTransition: function (e) {
        var t = this,
          a = t.slides,
          i = t.$wrapperEl;
        if ((a.transition(e), t.params.virtualTranslate && 0 !== e)) {
          var s = !1;
          a.transitionEnd(function () {
            if (!s && t && !t.destroyed) {
              (s = !0), (t.animating = !1);
              for (
                var e = ["webkitTransitionEnd", "transitionend"], a = 0;
                a < e.length;
                a += 1
              )
                i.trigger(e[a]);
            }
          });
        }
      },
    },
    oe = {
      setTranslate: function () {
        var e,
          t = this,
          a = t.$el,
          i = t.$wrapperEl,
          s = t.slides,
          r = t.width,
          n = t.height,
          l = t.rtlTranslate,
          o = t.size,
          d = t.browser,
          p = t.params.cubeEffect,
          u = t.isHorizontal(),
          c = t.virtual && t.params.virtual.enabled,
          h = 0;
        p.shadow &&
          (u
            ? (0 === (e = i.find(".swiper-cube-shadow")).length &&
                ((e = m('<div class="swiper-cube-shadow"></div>')),
                i.append(e)),
              e.css({ height: r + "px" }))
            : 0 === (e = a.find(".swiper-cube-shadow")).length &&
              ((e = m('<div class="swiper-cube-shadow"></div>')), a.append(e)));
        for (var v = 0; v < s.length; v += 1) {
          var f = s.eq(v),
            g = v;
          c && (g = parseInt(f.attr("data-swiper-slide-index"), 10));
          var y = 90 * g,
            w = Math.floor(y / 360);
          l && ((y = -y), (w = Math.floor(-y / 360)));
          var b = Math.max(Math.min(f[0].progress, 1), -1),
            E = 0,
            x = 0,
            T = 0;
          g % 4 == 0
            ? ((E = 4 * -w * o), (T = 0))
            : (g - 1) % 4 == 0
            ? ((E = 0), (T = 4 * -w * o))
            : (g - 2) % 4 == 0
            ? ((E = o + 4 * w * o), (T = o))
            : (g - 3) % 4 == 0 && ((E = -o), (T = 3 * o + 4 * o * w)),
            l && (E = -E),
            u || ((x = E), (E = 0));
          var C =
            "rotateX(" +
            (u ? 0 : -y) +
            "deg) rotateY(" +
            (u ? y : 0) +
            "deg) translate3d(" +
            E +
            "px, " +
            x +
            "px, " +
            T +
            "px)";
          if (
            (b <= 1 &&
              b > -1 &&
              ((h = 90 * g + 90 * b), l && (h = 90 * -g - 90 * b)),
            f.transform(C),
            p.slideShadows)
          ) {
            var S = u
                ? f.find(".swiper-slide-shadow-left")
                : f.find(".swiper-slide-shadow-top"),
              M = u
                ? f.find(".swiper-slide-shadow-right")
                : f.find(".swiper-slide-shadow-bottom");
            0 === S.length &&
              ((S = m(
                '<div class="swiper-slide-shadow-' +
                  (u ? "left" : "top") +
                  '"></div>'
              )),
              f.append(S)),
              0 === M.length &&
                ((M = m(
                  '<div class="swiper-slide-shadow-' +
                    (u ? "right" : "bottom") +
                    '"></div>'
                )),
                f.append(M)),
              S.length && (S[0].style.opacity = Math.max(-b, 0)),
              M.length && (M[0].style.opacity = Math.max(b, 0));
          }
        }
        if (
          (i.css({
            "-webkit-transform-origin": "50% 50% -" + o / 2 + "px",
            "-moz-transform-origin": "50% 50% -" + o / 2 + "px",
            "-ms-transform-origin": "50% 50% -" + o / 2 + "px",
            "transform-origin": "50% 50% -" + o / 2 + "px",
          }),
          p.shadow)
        )
          if (u)
            e.transform(
              "translate3d(0px, " +
                (r / 2 + p.shadowOffset) +
                "px, " +
                -r / 2 +
                "px) rotateX(90deg) rotateZ(0deg) scale(" +
                p.shadowScale +
                ")"
            );
          else {
            var z = Math.abs(h) - 90 * Math.floor(Math.abs(h) / 90),
              P =
                1.5 -
                (Math.sin((2 * z * Math.PI) / 360) / 2 +
                  Math.cos((2 * z * Math.PI) / 360) / 2),
              k = p.shadowScale,
              L = p.shadowScale / P,
              $ = p.shadowOffset;
            e.transform(
              "scale3d(" +
                k +
                ", 1, " +
                L +
                ") translate3d(0px, " +
                (n / 2 + $) +
                "px, " +
                -n / 2 / L +
                "px) rotateX(-90deg)"
            );
          }
        var I = d.isSafari || d.isWebView ? -o / 2 : 0;
        i.transform(
          "translate3d(0px,0," +
            I +
            "px) rotateX(" +
            (t.isHorizontal() ? 0 : h) +
            "deg) rotateY(" +
            (t.isHorizontal() ? -h : 0) +
            "deg)"
        );
      },
      setTransition: function (e) {
        var t = this,
          a = t.$el;
        t.slides
          .transition(e)
          .find(
            ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
          )
          .transition(e),
          t.params.cubeEffect.shadow &&
            !t.isHorizontal() &&
            a.find(".swiper-cube-shadow").transition(e);
      },
    },
    de = {
      setTranslate: function () {
        for (
          var e = this, t = e.slides, a = e.rtlTranslate, i = 0;
          i < t.length;
          i += 1
        ) {
          var s = t.eq(i),
            r = s[0].progress;
          e.params.flipEffect.limitRotation &&
            (r = Math.max(Math.min(s[0].progress, 1), -1));
          var n = -180 * r,
            l = 0,
            o = -s[0].swiperSlideOffset,
            d = 0;
          if (
            (e.isHorizontal()
              ? a && (n = -n)
              : ((d = o), (o = 0), (l = -n), (n = 0)),
            (s[0].style.zIndex = -Math.abs(Math.round(r)) + t.length),
            e.params.flipEffect.slideShadows)
          ) {
            var p = e.isHorizontal()
                ? s.find(".swiper-slide-shadow-left")
                : s.find(".swiper-slide-shadow-top"),
              u = e.isHorizontal()
                ? s.find(".swiper-slide-shadow-right")
                : s.find(".swiper-slide-shadow-bottom");
            0 === p.length &&
              ((p = m(
                '<div class="swiper-slide-shadow-' +
                  (e.isHorizontal() ? "left" : "top") +
                  '"></div>'
              )),
              s.append(p)),
              0 === u.length &&
                ((u = m(
                  '<div class="swiper-slide-shadow-' +
                    (e.isHorizontal() ? "right" : "bottom") +
                    '"></div>'
                )),
                s.append(u)),
              p.length && (p[0].style.opacity = Math.max(-r, 0)),
              u.length && (u[0].style.opacity = Math.max(r, 0));
          }
          s.transform(
            "translate3d(" +
              o +
              "px, " +
              d +
              "px, 0px) rotateX(" +
              l +
              "deg) rotateY(" +
              n +
              "deg)"
          );
        }
      },
      setTransition: function (e) {
        var t = this,
          a = t.slides,
          i = t.activeIndex,
          s = t.$wrapperEl;
        if (
          (a
            .transition(e)
            .find(
              ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
            )
            .transition(e),
          t.params.virtualTranslate && 0 !== e)
        ) {
          var r = !1;
          a.eq(i).transitionEnd(function () {
            if (!r && t && !t.destroyed) {
              (r = !0), (t.animating = !1);
              for (
                var e = ["webkitTransitionEnd", "transitionend"], a = 0;
                a < e.length;
                a += 1
              )
                s.trigger(e[a]);
            }
          });
        }
      },
    },
    pe = {
      setTranslate: function () {
        for (
          var e = this,
            t = e.width,
            a = e.height,
            i = e.slides,
            s = e.slidesSizesGrid,
            r = e.params.coverflowEffect,
            n = e.isHorizontal(),
            l = e.translate,
            o = n ? t / 2 - l : a / 2 - l,
            d = n ? r.rotate : -r.rotate,
            p = r.depth,
            u = 0,
            c = i.length;
          u < c;
          u += 1
        ) {
          var h = i.eq(u),
            v = s[u],
            f = ((o - h[0].swiperSlideOffset - v / 2) / v) * r.modifier,
            g = n ? d * f : 0,
            y = n ? 0 : d * f,
            w = -p * Math.abs(f),
            b = r.stretch;
          "string" == typeof b &&
            -1 !== b.indexOf("%") &&
            (b = (parseFloat(r.stretch) / 100) * v);
          var E = n ? 0 : b * f,
            x = n ? b * f : 0,
            T = 1 - (1 - r.scale) * Math.abs(f);
          Math.abs(x) < 0.001 && (x = 0),
            Math.abs(E) < 0.001 && (E = 0),
            Math.abs(w) < 0.001 && (w = 0),
            Math.abs(g) < 0.001 && (g = 0),
            Math.abs(y) < 0.001 && (y = 0),
            Math.abs(T) < 0.001 && (T = 0);
          var C =
            "translate3d(" +
            x +
            "px," +
            E +
            "px," +
            w +
            "px)  rotateX(" +
            y +
            "deg) rotateY(" +
            g +
            "deg) scale(" +
            T +
            ")";
          if (
            (h.transform(C),
            (h[0].style.zIndex = 1 - Math.abs(Math.round(f))),
            r.slideShadows)
          ) {
            var S = n
                ? h.find(".swiper-slide-shadow-left")
                : h.find(".swiper-slide-shadow-top"),
              M = n
                ? h.find(".swiper-slide-shadow-right")
                : h.find(".swiper-slide-shadow-bottom");
            0 === S.length &&
              ((S = m(
                '<div class="swiper-slide-shadow-' +
                  (n ? "left" : "top") +
                  '"></div>'
              )),
              h.append(S)),
              0 === M.length &&
                ((M = m(
                  '<div class="swiper-slide-shadow-' +
                    (n ? "right" : "bottom") +
                    '"></div>'
                )),
                h.append(M)),
              S.length && (S[0].style.opacity = f > 0 ? f : 0),
              M.length && (M[0].style.opacity = -f > 0 ? -f : 0);
          }
        }
      },
      setTransition: function (e) {
        this.slides
          .transition(e)
          .find(
            ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
          )
          .transition(e);
      },
    },
    ue = {
      init: function () {
        var e = this,
          t = e.params.thumbs;
        if (e.thumbs.initialized) return !1;
        e.thumbs.initialized = !0;
        var a = e.constructor;
        return (
          t.swiper instanceof a
            ? ((e.thumbs.swiper = t.swiper),
              S(e.thumbs.swiper.originalParams, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1,
              }),
              S(e.thumbs.swiper.params, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1,
              }))
            : C(t.swiper) &&
              ((e.thumbs.swiper = new a(
                S({}, t.swiper, {
                  watchSlidesVisibility: !0,
                  watchSlidesProgress: !0,
                  slideToClickedSlide: !1,
                })
              )),
              (e.thumbs.swiperCreated = !0)),
          e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass),
          e.thumbs.swiper.on("tap", e.thumbs.onThumbClick),
          !0
        );
      },
      onThumbClick: function () {
        var e = this,
          t = e.thumbs.swiper;
        if (t) {
          var a = t.clickedIndex,
            i = t.clickedSlide;
          if (
            !(
              (i && m(i).hasClass(e.params.thumbs.slideThumbActiveClass)) ||
              null == a
            )
          ) {
            var s;
            if (
              ((s = t.params.loop
                ? parseInt(
                    m(t.clickedSlide).attr("data-swiper-slide-index"),
                    10
                  )
                : a),
              e.params.loop)
            ) {
              var r = e.activeIndex;
              e.slides.eq(r).hasClass(e.params.slideDuplicateClass) &&
                (e.loopFix(),
                (e._clientLeft = e.$wrapperEl[0].clientLeft),
                (r = e.activeIndex));
              var n = e.slides
                  .eq(r)
                  .prevAll('[data-swiper-slide-index="' + s + '"]')
                  .eq(0)
                  .index(),
                l = e.slides
                  .eq(r)
                  .nextAll('[data-swiper-slide-index="' + s + '"]')
                  .eq(0)
                  .index();
              s = void 0 === n ? l : void 0 === l ? n : l - r < r - n ? l : n;
            }
            e.slideTo(s);
          }
        }
      },
      update: function (e) {
        var t = this,
          a = t.thumbs.swiper;
        if (a) {
          var i =
              "auto" === a.params.slidesPerView
                ? a.slidesPerViewDynamic()
                : a.params.slidesPerView,
            s = t.params.thumbs.autoScrollOffset,
            r = s && !a.params.loop;
          if (t.realIndex !== a.realIndex || r) {
            var n,
              l,
              o = a.activeIndex;
            if (a.params.loop) {
              a.slides.eq(o).hasClass(a.params.slideDuplicateClass) &&
                (a.loopFix(),
                (a._clientLeft = a.$wrapperEl[0].clientLeft),
                (o = a.activeIndex));
              var d = a.slides
                  .eq(o)
                  .prevAll('[data-swiper-slide-index="' + t.realIndex + '"]')
                  .eq(0)
                  .index(),
                p = a.slides
                  .eq(o)
                  .nextAll('[data-swiper-slide-index="' + t.realIndex + '"]')
                  .eq(0)
                  .index();
              (n =
                void 0 === d
                  ? p
                  : void 0 === p
                  ? d
                  : p - o == o - d
                  ? o
                  : p - o < o - d
                  ? p
                  : d),
                (l = t.activeIndex > t.previousIndex ? "next" : "prev");
            } else l = (n = t.realIndex) > t.previousIndex ? "next" : "prev";
            r && (n += "next" === l ? s : -1 * s),
              a.visibleSlidesIndexes &&
                a.visibleSlidesIndexes.indexOf(n) < 0 &&
                (a.params.centeredSlides
                  ? (n =
                      n > o
                        ? n - Math.floor(i / 2) + 1
                        : n + Math.floor(i / 2) - 1)
                  : n > o && (n = n - i + 1),
                a.slideTo(n, e ? 0 : void 0));
          }
          var u = 1,
            c = t.params.thumbs.slideThumbActiveClass;
          if (
            (t.params.slidesPerView > 1 &&
              !t.params.centeredSlides &&
              (u = t.params.slidesPerView),
            t.params.thumbs.multipleActiveThumbs || (u = 1),
            (u = Math.floor(u)),
            a.slides.removeClass(c),
            a.params.loop || (a.params.virtual && a.params.virtual.enabled))
          )
            for (var h = 0; h < u; h += 1)
              a.$wrapperEl
                .children(
                  '[data-swiper-slide-index="' + (t.realIndex + h) + '"]'
                )
                .addClass(c);
          else
            for (var v = 0; v < u; v += 1)
              a.slides.eq(t.realIndex + v).addClass(c);
        }
      },
    },
    ce = [
      q,
      _,
      {
        name: "mousewheel",
        params: {
          mousewheel: {
            enabled: !1,
            releaseOnEdges: !1,
            invert: !1,
            forceToAxis: !1,
            sensitivity: 1,
            eventsTarget: "container",
            thresholdDelta: null,
            thresholdTime: null,
          },
        },
        create: function () {
          M(this, {
            mousewheel: {
              enabled: !1,
              lastScrollTime: x(),
              lastEventBeforeSnap: void 0,
              recentWheelEvents: [],
              enable: U.enable,
              disable: U.disable,
              handle: U.handle,
              handleMouseEnter: U.handleMouseEnter,
              handleMouseLeave: U.handleMouseLeave,
              animateSlider: U.animateSlider,
              releaseScroll: U.releaseScroll,
            },
          });
        },
        on: {
          init: function (e) {
            !e.params.mousewheel.enabled &&
              e.params.cssMode &&
              e.mousewheel.disable(),
              e.params.mousewheel.enabled && e.mousewheel.enable();
          },
          destroy: function (e) {
            e.params.cssMode && e.mousewheel.enable(),
              e.mousewheel.enabled && e.mousewheel.disable();
          },
        },
      },
      {
        name: "navigation",
        params: {
          navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: !1,
            disabledClass: "swiper-button-disabled",
            hiddenClass: "swiper-button-hidden",
            lockClass: "swiper-button-lock",
          },
        },
        create: function () {
          M(this, { navigation: t({}, K) });
        },
        on: {
          init: function (e) {
            e.navigation.init(), e.navigation.update();
          },
          toEdge: function (e) {
            e.navigation.update();
          },
          fromEdge: function (e) {
            e.navigation.update();
          },
          destroy: function (e) {
            e.navigation.destroy();
          },
          click: function (e, t) {
            var a,
              i = e.navigation,
              s = i.$nextEl,
              r = i.$prevEl;
            !e.params.navigation.hideOnClick ||
              m(t.target).is(r) ||
              m(t.target).is(s) ||
              (s
                ? (a = s.hasClass(e.params.navigation.hiddenClass))
                : r && (a = r.hasClass(e.params.navigation.hiddenClass)),
              !0 === a ? e.emit("navigationShow") : e.emit("navigationHide"),
              s && s.toggleClass(e.params.navigation.hiddenClass),
              r && r.toggleClass(e.params.navigation.hiddenClass));
          },
        },
      },
      {
        name: "pagination",
        params: {
          pagination: {
            el: null,
            bulletElement: "span",
            clickable: !1,
            hideOnClick: !1,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: !1,
            type: "bullets",
            dynamicBullets: !1,
            dynamicMainBullets: 1,
            formatFractionCurrent: function (e) {
              return e;
            },
            formatFractionTotal: function (e) {
              return e;
            },
            bulletClass: "swiper-pagination-bullet",
            bulletActiveClass: "swiper-pagination-bullet-active",
            modifierClass: "swiper-pagination-",
            currentClass: "swiper-pagination-current",
            totalClass: "swiper-pagination-total",
            hiddenClass: "swiper-pagination-hidden",
            progressbarFillClass: "swiper-pagination-progressbar-fill",
            progressbarOppositeClass: "swiper-pagination-progressbar-opposite",
            clickableClass: "swiper-pagination-clickable",
            lockClass: "swiper-pagination-lock",
          },
        },
        create: function () {
          M(this, { pagination: t({ dynamicBulletIndex: 0 }, Z) });
        },
        on: {
          init: function (e) {
            e.pagination.init(), e.pagination.render(), e.pagination.update();
          },
          activeIndexChange: function (e) {
            (e.params.loop || void 0 === e.snapIndex) && e.pagination.update();
          },
          snapIndexChange: function (e) {
            e.params.loop || e.pagination.update();
          },
          slidesLengthChange: function (e) {
            e.params.loop && (e.pagination.render(), e.pagination.update());
          },
          snapGridLengthChange: function (e) {
            e.params.loop || (e.pagination.render(), e.pagination.update());
          },
          destroy: function (e) {
            e.pagination.destroy();
          },
          click: function (e, t) {
            e.params.pagination.el &&
              e.params.pagination.hideOnClick &&
              e.pagination.$el.length > 0 &&
              !m(t.target).hasClass(e.params.pagination.bulletClass) &&
              (!0 === e.pagination.$el.hasClass(e.params.pagination.hiddenClass)
                ? e.emit("paginationShow")
                : e.emit("paginationHide"),
              e.pagination.$el.toggleClass(e.params.pagination.hiddenClass));
          },
        },
      },
      {
        name: "scrollbar",
        params: {
          scrollbar: {
            el: null,
            dragSize: "auto",
            hide: !1,
            draggable: !1,
            snapOnRelease: !0,
            lockClass: "swiper-scrollbar-lock",
            dragClass: "swiper-scrollbar-drag",
          },
        },
        create: function () {
          M(this, {
            scrollbar: t(
              { isTouched: !1, timeout: null, dragTimeout: null },
              J
            ),
          });
        },
        on: {
          init: function (e) {
            e.scrollbar.init(),
              e.scrollbar.updateSize(),
              e.scrollbar.setTranslate();
          },
          update: function (e) {
            e.scrollbar.updateSize();
          },
          resize: function (e) {
            e.scrollbar.updateSize();
          },
          observerUpdate: function (e) {
            e.scrollbar.updateSize();
          },
          setTranslate: function (e) {
            e.scrollbar.setTranslate();
          },
          setTransition: function (e, t) {
            e.scrollbar.setTransition(t);
          },
          destroy: function (e) {
            e.scrollbar.destroy();
          },
        },
      },
      {
        name: "parallax",
        params: { parallax: { enabled: !1 } },
        create: function () {
          M(this, { parallax: t({}, Q) });
        },
        on: {
          beforeInit: function (e) {
            e.params.parallax.enabled &&
              ((e.params.watchSlidesProgress = !0),
              (e.originalParams.watchSlidesProgress = !0));
          },
          init: function (e) {
            e.params.parallax.enabled && e.parallax.setTranslate();
          },
          setTranslate: function (e) {
            e.params.parallax.enabled && e.parallax.setTranslate();
          },
          setTransition: function (e, t) {
            e.params.parallax.enabled && e.parallax.setTransition(t);
          },
        },
      },
      {
        name: "zoom",
        params: {
          zoom: {
            enabled: !1,
            maxRatio: 3,
            minRatio: 1,
            toggle: !0,
            containerClass: "swiper-zoom-container",
            zoomedSlideClass: "swiper-slide-zoomed",
          },
        },
        create: function () {
          var e = this;
          M(e, {
            zoom: t(
              {
                enabled: !1,
                scale: 1,
                currentScale: 1,
                isScaling: !1,
                gesture: {
                  $slideEl: void 0,
                  slideWidth: void 0,
                  slideHeight: void 0,
                  $imageEl: void 0,
                  $imageWrapEl: void 0,
                  maxRatio: 3,
                },
                image: {
                  isTouched: void 0,
                  isMoved: void 0,
                  currentX: void 0,
                  currentY: void 0,
                  minX: void 0,
                  minY: void 0,
                  maxX: void 0,
                  maxY: void 0,
                  width: void 0,
                  height: void 0,
                  startX: void 0,
                  startY: void 0,
                  touchesStart: {},
                  touchesCurrent: {},
                },
                velocity: {
                  x: void 0,
                  y: void 0,
                  prevPositionX: void 0,
                  prevPositionY: void 0,
                  prevTime: void 0,
                },
              },
              ee
            ),
          });
          var a = 1;
          Object.defineProperty(e.zoom, "scale", {
            get: function () {
              return a;
            },
            set: function (t) {
              if (a !== t) {
                var i = e.zoom.gesture.$imageEl
                    ? e.zoom.gesture.$imageEl[0]
                    : void 0,
                  s = e.zoom.gesture.$slideEl
                    ? e.zoom.gesture.$slideEl[0]
                    : void 0;
                e.emit("zoomChange", t, i, s);
              }
              a = t;
            },
          });
        },
        on: {
          init: function (e) {
            e.params.zoom.enabled && e.zoom.enable();
          },
          destroy: function (e) {
            e.zoom.disable();
          },
          touchStart: function (e, t) {
            e.zoom.enabled && e.zoom.onTouchStart(t);
          },
          touchEnd: function (e, t) {
            e.zoom.enabled && e.zoom.onTouchEnd(t);
          },
          doubleTap: function (e, t) {
            e.params.zoom.enabled &&
              e.zoom.enabled &&
              e.params.zoom.toggle &&
              e.zoom.toggle(t);
          },
          transitionEnd: function (e) {
            e.zoom.enabled && e.params.zoom.enabled && e.zoom.onTransitionEnd();
          },
          slideChange: function (e) {
            e.zoom.enabled &&
              e.params.zoom.enabled &&
              e.params.cssMode &&
              e.zoom.onTransitionEnd();
          },
        },
      },
      {
        name: "lazy",
        params: {
          lazy: {
            checkInView: !1,
            enabled: !1,
            loadPrevNext: !1,
            loadPrevNextAmount: 1,
            loadOnTransitionStart: !1,
            scrollingElement: "",
            elementClass: "swiper-lazy",
            loadingClass: "swiper-lazy-loading",
            loadedClass: "swiper-lazy-loaded",
            preloaderClass: "swiper-lazy-preloader",
          },
        },
        create: function () {
          M(this, { lazy: t({ initialImageLoaded: !1 }, te) });
        },
        on: {
          beforeInit: function (e) {
            e.params.lazy.enabled &&
              e.params.preloadImages &&
              (e.params.preloadImages = !1);
          },
          init: function (e) {
            e.params.lazy.enabled &&
              !e.params.loop &&
              0 === e.params.initialSlide &&
              (e.params.lazy.checkInView
                ? e.lazy.checkInViewOnLoad()
                : e.lazy.load());
          },
          scroll: function (e) {
            e.params.freeMode && !e.params.freeModeSticky && e.lazy.load();
          },
          resize: function (e) {
            e.params.lazy.enabled && e.lazy.load();
          },
          scrollbarDragMove: function (e) {
            e.params.lazy.enabled && e.lazy.load();
          },
          transitionStart: function (e) {
            e.params.lazy.enabled &&
              (e.params.lazy.loadOnTransitionStart ||
                (!e.params.lazy.loadOnTransitionStart &&
                  !e.lazy.initialImageLoaded)) &&
              e.lazy.load();
          },
          transitionEnd: function (e) {
            e.params.lazy.enabled &&
              !e.params.lazy.loadOnTransitionStart &&
              e.lazy.load();
          },
          slideChange: function (e) {
            e.params.lazy.enabled && e.params.cssMode && e.lazy.load();
          },
        },
      },
      {
        name: "controller",
        params: { controller: { control: void 0, inverse: !1, by: "slide" } },
        create: function () {
          M(this, {
            controller: t({ control: this.params.controller.control }, ae),
          });
        },
        on: {
          update: function (e) {
            e.controller.control &&
              e.controller.spline &&
              ((e.controller.spline = void 0), delete e.controller.spline);
          },
          resize: function (e) {
            e.controller.control &&
              e.controller.spline &&
              ((e.controller.spline = void 0), delete e.controller.spline);
          },
          observerUpdate: function (e) {
            e.controller.control &&
              e.controller.spline &&
              ((e.controller.spline = void 0), delete e.controller.spline);
          },
          setTranslate: function (e, t, a) {
            e.controller.control && e.controller.setTranslate(t, a);
          },
          setTransition: function (e, t, a) {
            e.controller.control && e.controller.setTransition(t, a);
          },
        },
      },
      {
        name: "a11y",
        params: {
          a11y: {
            enabled: !0,
            notificationClass: "swiper-notification",
            prevSlideMessage: "Previous slide",
            nextSlideMessage: "Next slide",
            firstSlideMessage: "This is the first slide",
            lastSlideMessage: "This is the last slide",
            paginationBulletMessage: "Go to slide {{index}}",
            containerMessage: null,
            containerRoleDescriptionMessage: null,
            itemRoleDescriptionMessage: null,
          },
        },
        create: function () {
          M(this, {
            a11y: t({}, ie, {
              liveRegion: m(
                '<span class="' +
                  this.params.a11y.notificationClass +
                  '" aria-live="assertive" aria-atomic="true"></span>'
              ),
            }),
          });
        },
        on: {
          afterInit: function (e) {
            e.params.a11y.enabled && (e.a11y.init(), e.a11y.updateNavigation());
          },
          toEdge: function (e) {
            e.params.a11y.enabled && e.a11y.updateNavigation();
          },
          fromEdge: function (e) {
            e.params.a11y.enabled && e.a11y.updateNavigation();
          },
          paginationUpdate: function (e) {
            e.params.a11y.enabled && e.a11y.updatePagination();
          },
          destroy: function (e) {
            e.params.a11y.enabled && e.a11y.destroy();
          },
        },
      },
      {
        name: "history",
        params: { history: { enabled: !1, replaceState: !1, key: "slides" } },
        create: function () {
          M(this, { history: t({}, se) });
        },
        on: {
          init: function (e) {
            e.params.history.enabled && e.history.init();
          },
          destroy: function (e) {
            e.params.history.enabled && e.history.destroy();
          },
          transitionEnd: function (e) {
            e.history.initialized &&
              e.history.setHistory(e.params.history.key, e.activeIndex);
          },
          slideChange: function (e) {
            e.history.initialized &&
              e.params.cssMode &&
              e.history.setHistory(e.params.history.key, e.activeIndex);
          },
        },
      },
      {
        name: "hash-navigation",
        params: {
          hashNavigation: { enabled: !1, replaceState: !1, watchState: !1 },
        },
        create: function () {
          M(this, { hashNavigation: t({ initialized: !1 }, re) });
        },
        on: {
          init: function (e) {
            e.params.hashNavigation.enabled && e.hashNavigation.init();
          },
          destroy: function (e) {
            e.params.hashNavigation.enabled && e.hashNavigation.destroy();
          },
          transitionEnd: function (e) {
            e.hashNavigation.initialized && e.hashNavigation.setHash();
          },
          slideChange: function (e) {
            e.hashNavigation.initialized &&
              e.params.cssMode &&
              e.hashNavigation.setHash();
          },
        },
      },
      {
        name: "autoplay",
        params: {
          autoplay: {
            enabled: !1,
            delay: 3e3,
            waitForTransition: !0,
            disableOnInteraction: !0,
            stopOnLastSlide: !1,
            reverseDirection: !1,
          },
        },
        create: function () {
          M(this, { autoplay: t({}, ne, { running: !1, paused: !1 }) });
        },
        on: {
          init: function (e) {
            e.params.autoplay.enabled &&
              (e.autoplay.start(),
              r().addEventListener(
                "visibilitychange",
                e.autoplay.onVisibilityChange
              ));
          },
          beforeTransitionStart: function (e, t, a) {
            e.autoplay.running &&
              (a || !e.params.autoplay.disableOnInteraction
                ? e.autoplay.pause(t)
                : e.autoplay.stop());
          },
          sliderFirstMove: function (e) {
            e.autoplay.running &&
              (e.params.autoplay.disableOnInteraction
                ? e.autoplay.stop()
                : e.autoplay.pause());
          },
          touchEnd: function (e) {
            e.params.cssMode &&
              e.autoplay.paused &&
              !e.params.autoplay.disableOnInteraction &&
              e.autoplay.run();
          },
          destroy: function (e) {
            e.autoplay.running && e.autoplay.stop(),
              r().removeEventListener(
                "visibilitychange",
                e.autoplay.onVisibilityChange
              );
          },
        },
      },
      {
        name: "effect-fade",
        params: { fadeEffect: { crossFade: !1 } },
        create: function () {
          M(this, { fadeEffect: t({}, le) });
        },
        on: {
          beforeInit: function (e) {
            if ("fade" === e.params.effect) {
              e.classNames.push(e.params.containerModifierClass + "fade");
              var t = {
                slidesPerView: 1,
                slidesPerColumn: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                spaceBetween: 0,
                virtualTranslate: !0,
              };
              S(e.params, t), S(e.originalParams, t);
            }
          },
          setTranslate: function (e) {
            "fade" === e.params.effect && e.fadeEffect.setTranslate();
          },
          setTransition: function (e, t) {
            "fade" === e.params.effect && e.fadeEffect.setTransition(t);
          },
        },
      },
      {
        name: "effect-cube",
        params: {
          cubeEffect: {
            slideShadows: !0,
            shadow: !0,
            shadowOffset: 20,
            shadowScale: 0.94,
          },
        },
        create: function () {
          M(this, { cubeEffect: t({}, oe) });
        },
        on: {
          beforeInit: function (e) {
            if ("cube" === e.params.effect) {
              e.classNames.push(e.params.containerModifierClass + "cube"),
                e.classNames.push(e.params.containerModifierClass + "3d");
              var t = {
                slidesPerView: 1,
                slidesPerColumn: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                resistanceRatio: 0,
                spaceBetween: 0,
                centeredSlides: !1,
                virtualTranslate: !0,
              };
              S(e.params, t), S(e.originalParams, t);
            }
          },
          setTranslate: function (e) {
            "cube" === e.params.effect && e.cubeEffect.setTranslate();
          },
          setTransition: function (e, t) {
            "cube" === e.params.effect && e.cubeEffect.setTransition(t);
          },
        },
      },
      {
        name: "effect-flip",
        params: { flipEffect: { slideShadows: !0, limitRotation: !0 } },
        create: function () {
          M(this, { flipEffect: t({}, de) });
        },
        on: {
          beforeInit: function (e) {
            if ("flip" === e.params.effect) {
              e.classNames.push(e.params.containerModifierClass + "flip"),
                e.classNames.push(e.params.containerModifierClass + "3d");
              var t = {
                slidesPerView: 1,
                slidesPerColumn: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                spaceBetween: 0,
                virtualTranslate: !0,
              };
              S(e.params, t), S(e.originalParams, t);
            }
          },
          setTranslate: function (e) {
            "flip" === e.params.effect && e.flipEffect.setTranslate();
          },
          setTransition: function (e, t) {
            "flip" === e.params.effect && e.flipEffect.setTransition(t);
          },
        },
      },
      {
        name: "effect-coverflow",
        params: {
          coverflowEffect: {
            rotate: 50,
            stretch: 0,
            depth: 100,
            scale: 1,
            modifier: 1,
            slideShadows: !0,
          },
        },
        create: function () {
          M(this, { coverflowEffect: t({}, pe) });
        },
        on: {
          beforeInit: function (e) {
            "coverflow" === e.params.effect &&
              (e.classNames.push(e.params.containerModifierClass + "coverflow"),
              e.classNames.push(e.params.containerModifierClass + "3d"),
              (e.params.watchSlidesProgress = !0),
              (e.originalParams.watchSlidesProgress = !0));
          },
          setTranslate: function (e) {
            "coverflow" === e.params.effect && e.coverflowEffect.setTranslate();
          },
          setTransition: function (e, t) {
            "coverflow" === e.params.effect &&
              e.coverflowEffect.setTransition(t);
          },
        },
      },
      {
        name: "thumbs",
        params: {
          thumbs: {
            swiper: null,
            multipleActiveThumbs: !0,
            autoScrollOffset: 0,
            slideThumbActiveClass: "swiper-slide-thumb-active",
            thumbsContainerClass: "swiper-container-thumbs",
          },
        },
        create: function () {
          M(this, { thumbs: t({ swiper: null, initialized: !1 }, ue) });
        },
        on: {
          beforeInit: function (e) {
            var t = e.params.thumbs;
            t && t.swiper && (e.thumbs.init(), e.thumbs.update(!0));
          },
          slideChange: function (e) {
            e.thumbs.swiper && e.thumbs.update();
          },
          update: function (e) {
            e.thumbs.swiper && e.thumbs.update();
          },
          resize: function (e) {
            e.thumbs.swiper && e.thumbs.update();
          },
          observerUpdate: function (e) {
            e.thumbs.swiper && e.thumbs.update();
          },
          setTransition: function (e, t) {
            var a = e.thumbs.swiper;
            a && a.setTransition(t);
          },
          beforeDestroy: function (e) {
            var t = e.thumbs.swiper;
            t && e.thumbs.swiperCreated && t && t.destroy();
          },
        },
      },
    ];
  return R.use(ce), R;
});


let mainSlider = new Swiper(".top-slider__inner", {
    navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
    },
    pagination: {
        el: ".swiper-pagination",
        clickable: true,
    },
    slidesPerView: 1,
    autoplay: {
        delay: 2000,
        disableOnInteraction: false
    },
    speed: 800,
    effect: 'slide',
    preloadImages: false,
    lazy: {
        loadOnTransitionStart: false,
        loadPrevNext: true,
    },
    watchSlidesProgress: true,
    watchSlidesVisibility: true,
});

let reviews__Slider = new Swiper(".reviews__slider", {
    navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
    },
    pagination: {
        el: ".swiper-pagination",
        clickable: true,
    },
    slidesPerView: 1,
    // autoplay: {
    //     delay: 2000,
    //     disableOnInteraction: false
    // },
    speed: 800,
    effect: 'slide',
    preloadImages: false,
    lazy: {
        loadOnTransitionStart: false,
        loadPrevNext: true,
    },
    watchSlidesProgress: true,
    watchSlidesVisibility: true,
    breakpoints: {
        900: {
            slidesPerView: 2,

        }
    }
});

let fag__Slider = new Swiper(".fag__slider", {
    navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
    },
    pagination: {
        el: ".swiper-pagination",
        clickable: true,
    },
    slidesPerView: 1,
    // autoplay: {
    //     delay: 2000,
    //     disableOnInteraction: false
    // },
    speed: 800,
    effect: 'slide',
    preloadImages: false,
    lazy: {
        loadOnTransitionStart: false,
        loadPrevNext: true,
    },
    watchSlidesProgress: true,
    watchSlidesVisibility: true,
    breakpoints: {
        900: {
            slidesPerView: 2,

        }
    }
});
document.body.insertAdjacentHTML('beforeend', '<div class="scrollToTop _icon-arr"></div>')
let scrollBtn = document.querySelector('.scrollToTop');



scrollBtn.addEventListener('click', function (e) {
  document.body.scrollIntoView({
    behavior: 'smooth',
    block: 'start'
  })
})

window.onscroll = function() {
  let scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
  if (scrollTop > 400) {
    scrollBtn.style.display = 'flex';
  } else {
    scrollBtn.style.display = 'none';
  }
}






/*! nouislider - 14.6.2 - 9/16/2020 */
!(function (t) {
	"function" == typeof define && define.amd
		? define([], t)
		: "object" == typeof exports
		? (module.exports = t())
		: (window.noUiSlider = t());
})(function () {
	"use strict";
	var lt = "14.6.2";
	function ut(t) {
		t.parentElement.removeChild(t);
	}
	function a(t) {
		return null != t;
	}
	function ct(t) {
		t.preventDefault();
	}
	function o(t) {
		return "number" == typeof t && !isNaN(t) && isFinite(t);
	}
	function pt(t, e, r) {
		0 < r &&
		(ht(t, e),
			setTimeout(function () {
				mt(t, e);
			}, r));
	}
	function ft(t) {
		return Math.max(Math.min(t, 100), 0);
	}
	function dt(t) {
		return Array.isArray(t) ? t : [t];
	}
	function e(t) {
		var e = (t = String(t)).split(".");
		return 1 < e.length ? e[1].length : 0;
	}
	function ht(t, e) {
		t.classList && !/\s/.test(e)
			? t.classList.add(e)
			: (t.className += " " + e);
	}
	function mt(t, e) {
		t.classList && !/\s/.test(e)
			? t.classList.remove(e)
			: (t.className = t.className.replace(
			new RegExp("(^|\\b)" + e.split(" ").join("|") + "(\\b|$)", "gi"),
			" "
			));
	}
	function gt(t) {
		var e = void 0 !== window.pageXOffset,
			r = "CSS1Compat" === (t.compatMode || "");
		return {
			x: e
				? window.pageXOffset
				: r
					? t.documentElement.scrollLeft
					: t.body.scrollLeft,
			y: e
				? window.pageYOffset
				: r
					? t.documentElement.scrollTop
					: t.body.scrollTop,
		};
	}
	function c(t, e) {
		return 100 / (e - t);
	}
	function p(t, e, r) {
		return (100 * e) / (t[r + 1] - t[r]);
	}
	function f(t, e) {
		for (var r = 1; t >= e[r]; ) r += 1;
		return r;
	}
	function r(t, e, r) {
		if (r >= t.slice(-1)[0]) return 100;
		var n,
			i,
			o = f(r, t),
			s = t[o - 1],
			a = t[o],
			l = e[o - 1],
			u = e[o];
		return (
			l +
			((i = r),
			p((n = [s, a]), n[0] < 0 ? i + Math.abs(n[0]) : i - n[0], 0) / c(l, u))
		);
	}
	function n(t, e, r, n) {
		if (100 === n) return n;
		var i,
			o,
			s = f(n, t),
			a = t[s - 1],
			l = t[s];
		return r
			? (l - a) / 2 < n - a
				? l
				: a
			: e[s - 1]
				? t[s - 1] + ((i = n - t[s - 1]), (o = e[s - 1]), Math.round(i / o) * o)
				: n;
	}
	function s(t, e, r) {
		var n;
		if (("number" == typeof e && (e = [e]), !Array.isArray(e)))
			throw new Error(
				"noUiSlider (" + lt + "): 'range' contains invalid value."
			);
		if (
			!o((n = "min" === t ? 0 : "max" === t ? 100 : parseFloat(t))) ||
			!o(e[0])
		)
			throw new Error("noUiSlider (" + lt + "): 'range' value isn't numeric.");
		r.xPct.push(n),
			r.xVal.push(e[0]),
			n
				? r.xSteps.push(!isNaN(e[1]) && e[1])
				: isNaN(e[1]) || (r.xSteps[0] = e[1]),
			r.xHighestCompleteStep.push(0);
	}
	function l(t, e, r) {
		if (e)
			if (r.xVal[t] !== r.xVal[t + 1]) {
				r.xSteps[t] =
					p([r.xVal[t], r.xVal[t + 1]], e, 0) / c(r.xPct[t], r.xPct[t + 1]);
				var n = (r.xVal[t + 1] - r.xVal[t]) / r.xNumSteps[t],
					i = Math.ceil(Number(n.toFixed(3)) - 1),
					o = r.xVal[t] + r.xNumSteps[t] * i;
				r.xHighestCompleteStep[t] = o;
			} else r.xSteps[t] = r.xHighestCompleteStep[t] = r.xVal[t];
	}
	function i(t, e, r) {
		var n;
		(this.xPct = []),
			(this.xVal = []),
			(this.xSteps = [r || !1]),
			(this.xNumSteps = [!1]),
			(this.xHighestCompleteStep = []),
			(this.snap = e);
		var i = [];
		for (n in t) t.hasOwnProperty(n) && i.push([t[n], n]);
		for (
			i.length && "object" == typeof i[0][0]
				? i.sort(function (t, e) {
					return t[0][0] - e[0][0];
				})
				: i.sort(function (t, e) {
					return t[0] - e[0];
				}),
				n = 0;
			n < i.length;
			n++
		)
			s(i[n][1], i[n][0], this);
		for (
			this.xNumSteps = this.xSteps.slice(0), n = 0;
			n < this.xNumSteps.length;
			n++
		)
			l(n, this.xNumSteps[n], this);
	}
	(i.prototype.getDistance = function (t) {
		var e,
			r = [];
		for (e = 0; e < this.xNumSteps.length - 1; e++) {
			var n = this.xNumSteps[e];
			if (n && (t / n) % 1 != 0)
				throw new Error(
					"noUiSlider (" +
					lt +
					"): 'limit', 'margin' and 'padding' of " +
					this.xPct[e] +
					"% range must be divisible by step."
				);
			r[e] = p(this.xVal, t, e);
		}
		return r;
	}),
		(i.prototype.getAbsoluteDistance = function (t, e, r) {
			var n,
				i = 0;
			if (t < this.xPct[this.xPct.length - 1])
				for (; t > this.xPct[i + 1]; ) i++;
			else t === this.xPct[this.xPct.length - 1] && (i = this.xPct.length - 2);
			r || t !== this.xPct[i + 1] || i++;
			var o = 1,
				s = e[i],
				a = 0,
				l = 0,
				u = 0,
				c = 0;
			for (
				n = r
					? (t - this.xPct[i]) / (this.xPct[i + 1] - this.xPct[i])
					: (this.xPct[i + 1] - t) / (this.xPct[i + 1] - this.xPct[i]);
				0 < s;

			)
				(a = this.xPct[i + 1 + c] - this.xPct[i + c]),
					100 < e[i + c] * o + 100 - 100 * n
						? ((l = a * n), (o = (s - 100 * n) / e[i + c]), (n = 1))
						: ((l = ((e[i + c] * a) / 100) * o), (o = 0)),
					r
						? ((u -= l), 1 <= this.xPct.length + c && c--)
						: ((u += l), 1 <= this.xPct.length - c && c++),
					(s = e[i + c] * o);
			return t + u;
		}),
		(i.prototype.toStepping = function (t) {
			return (t = r(this.xVal, this.xPct, t));
		}),
		(i.prototype.fromStepping = function (t) {
			return (function (t, e, r) {
				if (100 <= r) return t.slice(-1)[0];
				var n,
					i = f(r, e),
					o = t[i - 1],
					s = t[i],
					a = e[i - 1],
					l = e[i];
				return (n = [o, s]), ((r - a) * c(a, l) * (n[1] - n[0])) / 100 + n[0];
			})(this.xVal, this.xPct, t);
		}),
		(i.prototype.getStep = function (t) {
			return (t = n(this.xPct, this.xSteps, this.snap, t));
		}),
		(i.prototype.getDefaultStep = function (t, e, r) {
			var n = f(t, this.xPct);
			return (
				(100 === t || (e && t === this.xPct[n - 1])) &&
				(n = Math.max(n - 1, 1)),
				(this.xVal[n] - this.xVal[n - 1]) / r
			);
		}),
		(i.prototype.getNearbySteps = function (t) {
			var e = f(t, this.xPct);
			return {
				stepBefore: {
					startValue: this.xVal[e - 2],
					step: this.xNumSteps[e - 2],
					highestStep: this.xHighestCompleteStep[e - 2],
				},
				thisStep: {
					startValue: this.xVal[e - 1],
					step: this.xNumSteps[e - 1],
					highestStep: this.xHighestCompleteStep[e - 1],
				},
				stepAfter: {
					startValue: this.xVal[e],
					step: this.xNumSteps[e],
					highestStep: this.xHighestCompleteStep[e],
				},
			};
		}),
		(i.prototype.countStepDecimals = function () {
			var t = this.xNumSteps.map(e);
			return Math.max.apply(null, t);
		}),
		(i.prototype.convert = function (t) {
			return this.getStep(this.toStepping(t));
		});
	var u = {
			to: function (t) {
				return void 0 !== t && t.toFixed(2);
			},
			from: Number,
		},
		d = {
			target: "target",
			base: "base",
			origin: "origin",
			handle: "handle",
			handleLower: "handle-lower",
			handleUpper: "handle-upper",
			touchArea: "touch-area",
			horizontal: "horizontal",
			vertical: "vertical",
			background: "background",
			connect: "connect",
			connects: "connects",
			ltr: "ltr",
			rtl: "rtl",
			textDirectionLtr: "txt-dir-ltr",
			textDirectionRtl: "txt-dir-rtl",
			draggable: "draggable",
			drag: "state-drag",
			tap: "state-tap",
			active: "active",
			tooltip: "tooltip",
			pips: "pips",
			pipsHorizontal: "pips-horizontal",
			pipsVertical: "pips-vertical",
			marker: "marker",
			markerHorizontal: "marker-horizontal",
			markerVertical: "marker-vertical",
			markerNormal: "marker-normal",
			markerLarge: "marker-large",
			markerSub: "marker-sub",
			value: "value",
			valueHorizontal: "value-horizontal",
			valueVertical: "value-vertical",
			valueNormal: "value-normal",
			valueLarge: "value-large",
			valueSub: "value-sub",
		};
	function h(t) {
		if (
			"object" == typeof (e = t) &&
			"function" == typeof e.to &&
			"function" == typeof e.from
		)
			return !0;
		var e;
		throw new Error(
			"noUiSlider (" + lt + "): 'format' requires 'to' and 'from' methods."
		);
	}
	function m(t, e) {
		if (!o(e))
			throw new Error("noUiSlider (" + lt + "): 'step' is not numeric.");
		t.singleStep = e;
	}
	function g(t, e) {
		if (!o(e))
			throw new Error(
				"noUiSlider (" + lt + "): 'keyboardPageMultiplier' is not numeric."
			);
		t.keyboardPageMultiplier = e;
	}
	function v(t, e) {
		if (!o(e))
			throw new Error(
				"noUiSlider (" + lt + "): 'keyboardDefaultStep' is not numeric."
			);
		t.keyboardDefaultStep = e;
	}
	function b(t, e) {
		if ("object" != typeof e || Array.isArray(e))
			throw new Error("noUiSlider (" + lt + "): 'range' is not an object.");
		if (void 0 === e.min || void 0 === e.max)
			throw new Error(
				"noUiSlider (" + lt + "): Missing 'min' or 'max' in 'range'."
			);
		if (e.min === e.max)
			throw new Error(
				"noUiSlider (" + lt + "): 'range' 'min' and 'max' cannot be equal."
			);
		t.spectrum = new i(e, t.snap, t.singleStep);
	}
	function x(t, e) {
		if (((e = dt(e)), !Array.isArray(e) || !e.length))
			throw new Error("noUiSlider (" + lt + "): 'start' option is incorrect.");
		(t.handles = e.length), (t.start = e);
	}
	function S(t, e) {
		if ("boolean" != typeof (t.snap = e))
			throw new Error(
				"noUiSlider (" + lt + "): 'snap' option must be a boolean."
			);
	}
	function w(t, e) {
		if ("boolean" != typeof (t.animate = e))
			throw new Error(
				"noUiSlider (" + lt + "): 'animate' option must be a boolean."
			);
	}
	function y(t, e) {
		if ("number" != typeof (t.animationDuration = e))
			throw new Error(
				"noUiSlider (" + lt + "): 'animationDuration' option must be a number."
			);
	}
	function E(t, e) {
		var r,
			n = [!1];
		if (
			("lower" === e ? (e = [!0, !1]) : "upper" === e && (e = [!1, !0]),
			!0 === e || !1 === e)
		) {
			for (r = 1; r < t.handles; r++) n.push(e);
			n.push(!1);
		} else {
			if (!Array.isArray(e) || !e.length || e.length !== t.handles + 1)
				throw new Error(
					"noUiSlider (" +
					lt +
					"): 'connect' option doesn't match handle count."
				);
			n = e;
		}
		t.connect = n;
	}
	function C(t, e) {
		switch (e) {
			case "horizontal":
				t.ort = 0;
				break;
			case "vertical":
				t.ort = 1;
				break;
			default:
				throw new Error(
					"noUiSlider (" + lt + "): 'orientation' option is invalid."
				);
		}
	}
	function P(t, e) {
		if (!o(e))
			throw new Error(
				"noUiSlider (" + lt + "): 'margin' option must be numeric."
			);
		0 !== e && (t.margin = t.spectrum.getDistance(e));
	}
	function N(t, e) {
		if (!o(e))
			throw new Error(
				"noUiSlider (" + lt + "): 'limit' option must be numeric."
			);
		if (((t.limit = t.spectrum.getDistance(e)), !t.limit || t.handles < 2))
			throw new Error(
				"noUiSlider (" +
				lt +
				"): 'limit' option is only supported on linear sliders with 2 or more handles."
			);
	}
	function k(t, e) {
		var r;
		if (!o(e) && !Array.isArray(e))
			throw new Error(
				"noUiSlider (" +
				lt +
				"): 'padding' option must be numeric or array of exactly 2 numbers."
			);
		if (Array.isArray(e) && 2 !== e.length && !o(e[0]) && !o(e[1]))
			throw new Error(
				"noUiSlider (" +
				lt +
				"): 'padding' option must be numeric or array of exactly 2 numbers."
			);
		if (0 !== e) {
			for (
				Array.isArray(e) || (e = [e, e]),
					t.padding = [
						t.spectrum.getDistance(e[0]),
						t.spectrum.getDistance(e[1]),
					],
					r = 0;
				r < t.spectrum.xNumSteps.length - 1;
				r++
			)
				if (t.padding[0][r] < 0 || t.padding[1][r] < 0)
					throw new Error(
						"noUiSlider (" +
						lt +
						"): 'padding' option must be a positive number(s)."
					);
			var n = e[0] + e[1],
				i = t.spectrum.xVal[0];
			if (1 < n / (t.spectrum.xVal[t.spectrum.xVal.length - 1] - i))
				throw new Error(
					"noUiSlider (" +
					lt +
					"): 'padding' option must not exceed 100% of the range."
				);
		}
	}
	function U(t, e) {
		switch (e) {
			case "ltr":
				t.dir = 0;
				break;
			case "rtl":
				t.dir = 1;
				break;
			default:
				throw new Error(
					"noUiSlider (" + lt + "): 'direction' option was not recognized."
				);
		}
	}
	function A(t, e) {
		if ("string" != typeof e)
			throw new Error(
				"noUiSlider (" +
				lt +
				"): 'behaviour' must be a string containing options."
			);
		var r = 0 <= e.indexOf("tap"),
			n = 0 <= e.indexOf("drag"),
			i = 0 <= e.indexOf("fixed"),
			o = 0 <= e.indexOf("snap"),
			s = 0 <= e.indexOf("hover"),
			a = 0 <= e.indexOf("unconstrained");
		if (i) {
			if (2 !== t.handles)
				throw new Error(
					"noUiSlider (" +
					lt +
					"): 'fixed' behaviour must be used with 2 handles"
				);
			P(t, t.start[1] - t.start[0]);
		}
		if (a && (t.margin || t.limit))
			throw new Error(
				"noUiSlider (" +
				lt +
				"): 'unconstrained' behaviour cannot be used with margin or limit"
			);
		t.events = {
			tap: r || o,
			drag: n,
			fixed: i,
			snap: o,
			hover: s,
			unconstrained: a,
		};
	}
	function V(t, e) {
		if (!1 !== e)
			if (!0 === e) {
				t.tooltips = [];
				for (var r = 0; r < t.handles; r++) t.tooltips.push(!0);
			} else {
				if (((t.tooltips = dt(e)), t.tooltips.length !== t.handles))
					throw new Error(
						"noUiSlider (" + lt + "): must pass a formatter for all handles."
					);
				t.tooltips.forEach(function (t) {
					if (
						"boolean" != typeof t &&
						("object" != typeof t || "function" != typeof t.to)
					)
						throw new Error(
							"noUiSlider (" +
							lt +
							"): 'tooltips' must be passed a formatter or 'false'."
						);
				});
			}
	}
	function D(t, e) {
		h((t.ariaFormat = e));
	}
	function M(t, e) {
		h((t.format = e));
	}
	function O(t, e) {
		if ("boolean" != typeof (t.keyboardSupport = e))
			throw new Error(
				"noUiSlider (" + lt + "): 'keyboardSupport' option must be a boolean."
			);
	}
	function L(t, e) {
		t.documentElement = e;
	}
	function z(t, e) {
		if ("string" != typeof e && !1 !== e)
			throw new Error(
				"noUiSlider (" + lt + "): 'cssPrefix' must be a string or `false`."
			);
		t.cssPrefix = e;
	}
	function H(t, e) {
		if ("object" != typeof e)
			throw new Error(
				"noUiSlider (" + lt + "): 'cssClasses' must be an object."
			);
		if ("string" == typeof t.cssPrefix)
			for (var r in ((t.cssClasses = {}), e))
				e.hasOwnProperty(r) && (t.cssClasses[r] = t.cssPrefix + e[r]);
		else t.cssClasses = e;
	}
	function vt(e) {
		var r = {
				margin: 0,
				limit: 0,
				padding: 0,
				animate: !0,
				animationDuration: 300,
				ariaFormat: u,
				format: u,
			},
			n = {
				step: { r: !1, t: m },
				keyboardPageMultiplier: { r: !1, t: g },
				keyboardDefaultStep: { r: !1, t: v },
				start: { r: !0, t: x },
				connect: { r: !0, t: E },
				direction: { r: !0, t: U },
				snap: { r: !1, t: S },
				animate: { r: !1, t: w },
				animationDuration: { r: !1, t: y },
				range: { r: !0, t: b },
				orientation: { r: !1, t: C },
				margin: { r: !1, t: P },
				limit: { r: !1, t: N },
				padding: { r: !1, t: k },
				behaviour: { r: !0, t: A },
				ariaFormat: { r: !1, t: D },
				format: { r: !1, t: M },
				tooltips: { r: !1, t: V },
				keyboardSupport: { r: !0, t: O },
				documentElement: { r: !1, t: L },
				cssPrefix: { r: !0, t: z },
				cssClasses: { r: !0, t: H },
			},
			i = {
				connect: !1,
				direction: "ltr",
				behaviour: "tap",
				orientation: "horizontal",
				keyboardSupport: !0,
				cssPrefix: "noUi-",
				cssClasses: d,
				keyboardPageMultiplier: 5,
				keyboardDefaultStep: 10,
			};
		e.format && !e.ariaFormat && (e.ariaFormat = e.format),
			Object.keys(n).forEach(function (t) {
				if (!a(e[t]) && void 0 === i[t]) {
					if (n[t].r)
						throw new Error(
							"noUiSlider (" + lt + "): '" + t + "' is required."
						);
					return !0;
				}
				n[t].t(r, a(e[t]) ? e[t] : i[t]);
			}),
			(r.pips = e.pips);
		var t = document.createElement("div"),
			o = void 0 !== t.style.msTransform,
			s = void 0 !== t.style.transform;
		r.transformRule = s ? "transform" : o ? "msTransform" : "webkitTransform";
		return (
			(r.style = [
				["left", "top"],
				["right", "bottom"],
			][r.dir][r.ort]),
				r
		);
	}
	function j(t, b, o) {
		var l,
			u,
			s,
			c,
			i,
			a,
			e,
			p,
			f = window.navigator.pointerEnabled
				? { start: "pointerdown", move: "pointermove", end: "pointerup" }
				: window.navigator.msPointerEnabled
					? { start: "MSPointerDown", move: "MSPointerMove", end: "MSPointerUp" }
					: {
						start: "mousedown touchstart",
						move: "mousemove touchmove",
						end: "mouseup touchend",
					},
			d =
				window.CSS &&
				CSS.supports &&
				CSS.supports("touch-action", "none") &&
				(function () {
					var t = !1;
					try {
						var e = Object.defineProperty({}, "passive", {
							get: function () {
								t = !0;
							},
						});
						window.addEventListener("test", null, e);
					} catch (t) {}
					return t;
				})(),
			h = t,
			y = b.spectrum,
			x = [],
			S = [],
			m = [],
			g = 0,
			v = {},
			w = t.ownerDocument,
			E = b.documentElement || w.documentElement,
			C = w.body,
			P = -1,
			N = 0,
			k = 1,
			U = 2,
			A = "rtl" === w.dir || 1 === b.ort ? 0 : 100;
		function V(t, e) {
			var r = w.createElement("div");
			return e && ht(r, e), t.appendChild(r), r;
		}
		function D(t, e) {
			var r = V(t, b.cssClasses.origin),
				n = V(r, b.cssClasses.handle);
			return (
				V(n, b.cssClasses.touchArea),
					n.setAttribute("data-handle", e),
				b.keyboardSupport &&
				(n.setAttribute("tabindex", "0"),
					n.addEventListener("keydown", function (t) {
						return (function (t, e) {
							if (O() || L(e)) return !1;
							var r = ["Left", "Right"],
								n = ["Down", "Up"],
								i = ["PageDown", "PageUp"],
								o = ["Home", "End"];
							b.dir && !b.ort
								? r.reverse()
								: b.ort && !b.dir && (n.reverse(), i.reverse());
							var s,
								a = t.key.replace("Arrow", ""),
								l = a === i[0],
								u = a === i[1],
								c = a === n[0] || a === r[0] || l,
								p = a === n[1] || a === r[1] || u,
								f = a === o[0],
								d = a === o[1];
							if (!(c || p || f || d)) return !0;
							if ((t.preventDefault(), p || c)) {
								var h = b.keyboardPageMultiplier,
									m = c ? 0 : 1,
									g = at(e),
									v = g[m];
								if (null === v) return !1;
								!1 === v &&
								(v = y.getDefaultStep(S[e], c, b.keyboardDefaultStep)),
								(u || l) && (v *= h),
									(v = Math.max(v, 1e-7)),
									(v *= c ? -1 : 1),
									(s = x[e] + v);
							} else s = d ? b.spectrum.xVal[b.spectrum.xVal.length - 1] : b.spectrum.xVal[0];
							return (
								rt(e, y.toStepping(s), !0, !0),
									J("slide", e),
									J("update", e),
									J("change", e),
									J("set", e),
									!1
							);
						})(t, e);
					})),
					n.setAttribute("role", "slider"),
					n.setAttribute("aria-orientation", b.ort ? "vertical" : "horizontal"),
					0 === e
						? ht(n, b.cssClasses.handleLower)
						: e === b.handles - 1 && ht(n, b.cssClasses.handleUpper),
					r
			);
		}
		function M(t, e) {
			return !!e && V(t, b.cssClasses.connect);
		}
		function r(t, e) {
			return !!b.tooltips[e] && V(t.firstChild, b.cssClasses.tooltip);
		}
		function O() {
			return h.hasAttribute("disabled");
		}
		function L(t) {
			return u[t].hasAttribute("disabled");
		}
		function z() {
			i &&
			(G("update.tooltips"),
				i.forEach(function (t) {
					t && ut(t);
				}),
				(i = null));
		}
		function H() {
			z(),
				(i = u.map(r)),
				$("update.tooltips", function (t, e, r) {
					if (i[e]) {
						var n = t[e];
						!0 !== b.tooltips[e] && (n = b.tooltips[e].to(r[e])),
							(i[e].innerHTML = n);
					}
				});
		}
		function j(e, i, o) {
			var s = w.createElement("div"),
				a = [];
			(a[N] = b.cssClasses.valueNormal),
				(a[k] = b.cssClasses.valueLarge),
				(a[U] = b.cssClasses.valueSub);
			var l = [];
			(l[N] = b.cssClasses.markerNormal),
				(l[k] = b.cssClasses.markerLarge),
				(l[U] = b.cssClasses.markerSub);
			var u = [b.cssClasses.valueHorizontal, b.cssClasses.valueVertical],
				c = [b.cssClasses.markerHorizontal, b.cssClasses.markerVertical];
			function p(t, e) {
				var r = e === b.cssClasses.value,
					n = r ? a : l;
				return e + " " + (r ? u : c)[b.ort] + " " + n[t];
			}
			return (
				ht(s, b.cssClasses.pips),
					ht(
						s,
						0 === b.ort ? b.cssClasses.pipsHorizontal : b.cssClasses.pipsVertical
					),
					Object.keys(e).forEach(function (t) {
						!(function (t, e, r) {
							if ((r = i ? i(e, r) : r) !== P) {
								var n = V(s, !1);
								(n.className = p(r, b.cssClasses.marker)),
									(n.style[b.style] = t + "%"),
								N < r &&
								(((n = V(s, !1)).className = p(r, b.cssClasses.value)),
									n.setAttribute("data-value", e),
									(n.style[b.style] = t + "%"),
									(n.innerHTML = o.to(e)));
							}
						})(t, e[t][0], e[t][1]);
					}),
					s
			);
		}
		function F() {
			c && (ut(c), (c = null));
		}
		function R(t) {
			F();
			var m,
				g,
				v,
				b,
				e,
				r,
				x,
				S,
				w,
				n = t.mode,
				i = t.density || 1,
				o = t.filter || !1,
				s = (function (t, e, r) {
					if ("range" === t || "steps" === t) return y.xVal;
					if ("count" === t) {
						if (e < 2)
							throw new Error(
								"noUiSlider (" +
								lt +
								"): 'values' (>= 2) required for mode 'count'."
							);
						var n = e - 1,
							i = 100 / n;
						for (e = []; n--; ) e[n] = n * i;
						e.push(100), (t = "positions");
					}
					return "positions" === t
						? e.map(function (t) {
							return y.fromStepping(r ? y.getStep(t) : t);
						})
						: "values" === t
							? r
								? e.map(function (t) {
									return y.fromStepping(y.getStep(y.toStepping(t)));
								})
								: e
							: void 0;
				})(n, t.values || !1, t.stepped || !1),
				a =
					((m = i),
						(g = n),
						(v = s),
						(b = {}),
						(e = y.xVal[0]),
						(r = y.xVal[y.xVal.length - 1]),
						(S = x = !1),
						(w = 0),
					(v = v
					.slice()
					.sort(function (t, e) {
						return t - e;
					})
					.filter(function (t) {
						return !this[t] && (this[t] = !0);
					}, {}))[0] !== e && (v.unshift(e), (x = !0)),
					v[v.length - 1] !== r && (v.push(r), (S = !0)),
						v.forEach(function (t, e) {
							var r,
								n,
								i,
								o,
								s,
								a,
								l,
								u,
								c,
								p,
								f = t,
								d = v[e + 1],
								h = "steps" === g;
							if ((h && (r = y.xNumSteps[e]), r || (r = d - f), !1 !== f))
								for (
									void 0 === d && (d = f), r = Math.max(r, 1e-7), n = f;
									n <= d;
									n = (n + r).toFixed(7) / 1
								) {
									for (
										u = (s = (o = y.toStepping(n)) - w) / m,
											p = s / (c = Math.round(u)),
											i = 1;
										i <= c;
										i += 1
									)
										b[(a = w + i * p).toFixed(5)] = [y.fromStepping(a), 0];
									(l = -1 < v.indexOf(n) ? k : h ? U : N),
									!e && x && n !== d && (l = 0),
									(n === d && S) || (b[o.toFixed(5)] = [n, l]),
										(w = o);
								}
						}),
						b),
				l = t.format || { to: Math.round };
			return (c = h.appendChild(j(a, o, l)));
		}
		function T() {
			var t = l.getBoundingClientRect(),
				e = "offset" + ["Width", "Height"][b.ort];
			return 0 === b.ort ? t.width || l[e] : t.height || l[e];
		}
		function B(n, i, o, s) {
			var e = function (t) {
					return (
						!!(t = (function (t, e, r) {
							var n,
								i,
								o = 0 === t.type.indexOf("touch"),
								s = 0 === t.type.indexOf("mouse"),
								a = 0 === t.type.indexOf("pointer");
							0 === t.type.indexOf("MSPointer") && (a = !0);
							if ("mousedown" === t.type && !t.buttons && !t.touches) return !1;
							if (o) {
								var l = function (t) {
									return (
										t.target === r ||
										r.contains(t.target) ||
										(t.target.shadowRoot && t.target.shadowRoot.contains(r))
									);
								};
								if ("touchstart" === t.type) {
									var u = Array.prototype.filter.call(t.touches, l);
									if (1 < u.length) return !1;
									(n = u[0].pageX), (i = u[0].pageY);
								} else {
									var c = Array.prototype.find.call(t.changedTouches, l);
									if (!c) return !1;
									(n = c.pageX), (i = c.pageY);
								}
							}
							(e = e || gt(w)),
							(s || a) && ((n = t.clientX + e.x), (i = t.clientY + e.y));
							return (
								(t.pageOffset = e), (t.points = [n, i]), (t.cursor = s || a), t
							);
						})(t, s.pageOffset, s.target || i)) &&
						!(O() && !s.doNotReject) &&
						((e = h),
							(r = b.cssClasses.tap),
						!(
							(e.classList
								? e.classList.contains(r)
								: new RegExp("\\b" + r + "\\b").test(e.className)) &&
							!s.doNotReject
						) &&
						!(n === f.start && void 0 !== t.buttons && 1 < t.buttons) &&
						(!s.hover || !t.buttons) &&
						(d || t.preventDefault(),
							(t.calcPoint = t.points[b.ort]),
							void o(t, s)))
					);
					var e, r;
				},
				r = [];
			return (
				n.split(" ").forEach(function (t) {
					i.addEventListener(t, e, !!d && { passive: !0 }), r.push([t, e]);
				}),
					r
			);
		}
		function q(t) {
			var e,
				r,
				n,
				i,
				o,
				s,
				a =
					(100 *
						(t -
							((e = l),
								(r = b.ort),
								(n = e.getBoundingClientRect()),
								(i = e.ownerDocument),
								(o = i.documentElement),
								(s = gt(i)),
							/webkit.*Chrome.*Mobile/i.test(navigator.userAgent) && (s.x = 0),
								r ? n.top + s.y - o.clientTop : n.left + s.x - o.clientLeft))) /
					T();
			return (a = ft(a)), b.dir ? 100 - a : a;
		}
		function X(t, e) {
			"mouseout" === t.type &&
			"HTML" === t.target.nodeName &&
			null === t.relatedTarget &&
			_(t, e);
		}
		function Y(t, e) {
			if (
				-1 === navigator.appVersion.indexOf("MSIE 9") &&
				0 === t.buttons &&
				0 !== e.buttonsProperty
			)
				return _(t, e);
			var r = (b.dir ? -1 : 1) * (t.calcPoint - e.startCalcPoint);
			Z(0 < r, (100 * r) / e.baseSize, e.locations, e.handleNumbers);
		}
		function _(t, e) {
			e.handle && (mt(e.handle, b.cssClasses.active), (g -= 1)),
				e.listeners.forEach(function (t) {
					E.removeEventListener(t[0], t[1]);
				}),
			0 === g &&
			(mt(h, b.cssClasses.drag),
				et(),
			t.cursor &&
			((C.style.cursor = ""), C.removeEventListener("selectstart", ct))),
				e.handleNumbers.forEach(function (t) {
					J("change", t), J("set", t), J("end", t);
				});
		}
		function I(t, e) {
			if (e.handleNumbers.some(L)) return !1;
			var r;
			1 === e.handleNumbers.length &&
			((r = u[e.handleNumbers[0]].children[0]),
				(g += 1),
				ht(r, b.cssClasses.active));
			t.stopPropagation();
			var n = [],
				i = B(f.move, E, Y, {
					target: t.target,
					handle: r,
					listeners: n,
					startCalcPoint: t.calcPoint,
					baseSize: T(),
					pageOffset: t.pageOffset,
					handleNumbers: e.handleNumbers,
					buttonsProperty: t.buttons,
					locations: S.slice(),
				}),
				o = B(f.end, E, _, {
					target: t.target,
					handle: r,
					listeners: n,
					doNotReject: !0,
					handleNumbers: e.handleNumbers,
				}),
				s = B("mouseout", E, X, {
					target: t.target,
					handle: r,
					listeners: n,
					doNotReject: !0,
					handleNumbers: e.handleNumbers,
				});
			n.push.apply(n, i.concat(o, s)),
			t.cursor &&
			((C.style.cursor = getComputedStyle(t.target).cursor),
			1 < u.length && ht(h, b.cssClasses.drag),
				C.addEventListener("selectstart", ct, !1)),
				e.handleNumbers.forEach(function (t) {
					J("start", t);
				});
		}
		function n(t) {
			t.stopPropagation();
			var i,
				o,
				s,
				e = q(t.calcPoint),
				r =
					((i = e),
						(s = !(o = 100)),
						u.forEach(function (t, e) {
							if (!L(e)) {
								var r = S[e],
									n = Math.abs(r - i);
								(n < o || (n <= o && r < i) || (100 === n && 100 === o)) &&
								((s = e), (o = n));
							}
						}),
						s);
			if (!1 === r) return !1;
			b.events.snap || pt(h, b.cssClasses.tap, b.animationDuration),
				rt(r, e, !0, !0),
				et(),
				J("slide", r, !0),
				J("update", r, !0),
				J("change", r, !0),
				J("set", r, !0),
			b.events.snap && I(t, { handleNumbers: [r] });
		}
		function W(t) {
			var e = q(t.calcPoint),
				r = y.getStep(e),
				n = y.fromStepping(r);
			Object.keys(v).forEach(function (t) {
				"hover" === t.split(".")[0] &&
				v[t].forEach(function (t) {
					t.call(a, n);
				});
			});
		}
		function $(t, e) {
			(v[t] = v[t] || []),
				v[t].push(e),
			"update" === t.split(".")[0] &&
			u.forEach(function (t, e) {
				J("update", e);
			});
		}
		function G(t) {
			var n = t && t.split(".")[0],
				i = n && t.substring(n.length);
			Object.keys(v).forEach(function (t) {
				var e = t.split(".")[0],
					r = t.substring(e.length);
				(n && n !== e) || (i && i !== r) || delete v[t];
			});
		}
		function J(r, n, i) {
			Object.keys(v).forEach(function (t) {
				var e = t.split(".")[0];
				r === e &&
				v[t].forEach(function (t) {
					t.call(a, x.map(b.format.to), n, x.slice(), i || !1, S.slice(), a);
				});
			});
		}
		function K(t, e, r, n, i, o) {
			var s;
			return (
				1 < u.length &&
				!b.events.unconstrained &&
				(n &&
				0 < e &&
				((s = y.getAbsoluteDistance(t[e - 1], b.margin, 0)),
					(r = Math.max(r, s))),
				i &&
				e < u.length - 1 &&
				((s = y.getAbsoluteDistance(t[e + 1], b.margin, 1)),
					(r = Math.min(r, s)))),
				1 < u.length &&
				b.limit &&
				(n &&
				0 < e &&
				((s = y.getAbsoluteDistance(t[e - 1], b.limit, 0)),
					(r = Math.min(r, s))),
				i &&
				e < u.length - 1 &&
				((s = y.getAbsoluteDistance(t[e + 1], b.limit, 1)),
					(r = Math.max(r, s)))),
				b.padding &&
				(0 === e &&
				((s = y.getAbsoluteDistance(0, b.padding[0], 0)),
					(r = Math.max(r, s))),
				e === u.length - 1 &&
				((s = y.getAbsoluteDistance(100, b.padding[1], 1)),
					(r = Math.min(r, s)))),
				!((r = ft((r = y.getStep(r)))) === t[e] && !o) && r
			);
		}
		function Q(t, e) {
			var r = b.ort;
			return (r ? e : t) + ", " + (r ? t : e);
		}
		function Z(t, n, r, e) {
			var i = r.slice(),
				o = [!t, t],
				s = [t, !t];
			(e = e.slice()),
			t && e.reverse(),
				1 < e.length
					? e.forEach(function (t, e) {
						var r = K(i, t, i[t] + n, o[e], s[e], !1);
						!1 === r ? (n = 0) : ((n = r - i[t]), (i[t] = r));
					})
					: (o = s = [!0]);
			var a = !1;
			e.forEach(function (t, e) {
				a = rt(t, r[t] + n, o[e], s[e]) || a;
			}),
			a &&
			e.forEach(function (t) {
				J("update", t), J("slide", t);
			});
		}
		function tt(t, e) {
			return b.dir ? 100 - t - e : t;
		}
		function et() {
			m.forEach(function (t) {
				var e = 50 < S[t] ? -1 : 1,
					r = 3 + (u.length + e * t);
				u[t].style.zIndex = r;
			});
		}
		function rt(t, e, r, n, i) {
			return (
				i || (e = K(S, t, e, r, n, !1)),
				!1 !== e &&
				((function (t, e) {
					(S[t] = e), (x[t] = y.fromStepping(e));
					var r = "translate(" + Q(10 * (tt(e, 0) - A) + "%", "0") + ")";
					(u[t].style[b.transformRule] = r), nt(t), nt(t + 1);
				})(t, e),
					!0)
			);
		}
		function nt(t) {
			if (s[t]) {
				var e = 0,
					r = 100;
				0 !== t && (e = S[t - 1]), t !== s.length - 1 && (r = S[t]);
				var n = r - e,
					i = "translate(" + Q(tt(e, n) + "%", "0") + ")",
					o = "scale(" + Q(n / 100, "1") + ")";
				s[t].style[b.transformRule] = i + " " + o;
			}
		}
		function it(t, e) {
			return null === t || !1 === t || void 0 === t
				? S[e]
				: ("number" == typeof t && (t = String(t)),
					(t = b.format.from(t)),
					!1 === (t = y.toStepping(t)) || isNaN(t) ? S[e] : t);
		}
		function ot(t, e, r) {
			var n = dt(t),
				i = void 0 === S[0];
			(e = void 0 === e || !!e),
			b.animate && !i && pt(h, b.cssClasses.tap, b.animationDuration),
				m.forEach(function (t) {
					rt(t, it(n[t], t), !0, !1, r);
				});
			for (var o = 1 === m.length ? 0 : 1; o < m.length; ++o)
				m.forEach(function (t) {
					rt(t, S[t], !0, !0, r);
				});
			et(),
				m.forEach(function (t) {
					J("update", t), null !== n[t] && e && J("set", t);
				});
		}
		function st() {
			var t = x.map(b.format.to);
			return 1 === t.length ? t[0] : t;
		}
		function at(t) {
			var e = S[t],
				r = y.getNearbySteps(e),
				n = x[t],
				i = r.thisStep.step,
				o = null;
			if (b.snap)
				return [
					n - r.stepBefore.startValue || null,
					r.stepAfter.startValue - n || null,
				];
			!1 !== i &&
			n + i > r.stepAfter.startValue &&
			(i = r.stepAfter.startValue - n),
				(o =
					n > r.thisStep.startValue
						? r.thisStep.step
						: !1 !== r.stepBefore.step && n - r.stepBefore.highestStep),
				100 === e ? (i = null) : 0 === e && (o = null);
			var s = y.countStepDecimals();
			return (
				null !== i && !1 !== i && (i = Number(i.toFixed(s))),
				null !== o && !1 !== o && (o = Number(o.toFixed(s))),
					[o, i]
			);
		}
		return (
			ht((e = h), b.cssClasses.target),
				0 === b.dir ? ht(e, b.cssClasses.ltr) : ht(e, b.cssClasses.rtl),
				0 === b.ort
					? ht(e, b.cssClasses.horizontal)
					: ht(e, b.cssClasses.vertical),
				ht(
					e,
					"rtl" === getComputedStyle(e).direction
						? b.cssClasses.textDirectionRtl
						: b.cssClasses.textDirectionLtr
				),
				(l = V(e, b.cssClasses.base)),
				(function (t, e) {
					var r = V(e, b.cssClasses.connects);
					(u = []), (s = []).push(M(r, t[0]));
					for (var n = 0; n < b.handles; n++)
						u.push(D(e, n)), (m[n] = n), s.push(M(r, t[n + 1]));
				})(b.connect, l),
			(p = b.events).fixed ||
			u.forEach(function (t, e) {
				B(f.start, t.children[0], I, { handleNumbers: [e] });
			}),
			p.tap && B(f.start, l, n, {}),
			p.hover && B(f.move, l, W, { hover: !0 }),
			p.drag &&
			s.forEach(function (t, e) {
				if (!1 !== t && 0 !== e && e !== s.length - 1) {
					var r = u[e - 1],
						n = u[e],
						i = [t];
					ht(t, b.cssClasses.draggable),
					p.fixed && (i.push(r.children[0]), i.push(n.children[0])),
						i.forEach(function (t) {
							B(f.start, t, I, {
								handles: [r, n],
								handleNumbers: [e - 1, e],
							});
						});
				}
			}),
				ot(b.start),
			b.pips && R(b.pips),
			b.tooltips && H(),
				$("update", function (t, e, s, r, a) {
					m.forEach(function (t) {
						var e = u[t],
							r = K(S, t, 0, !0, !0, !0),
							n = K(S, t, 100, !0, !0, !0),
							i = a[t],
							o = b.ariaFormat.to(s[t]);
						(r = y.fromStepping(r).toFixed(1)),
							(n = y.fromStepping(n).toFixed(1)),
							(i = y.fromStepping(i).toFixed(1)),
							e.children[0].setAttribute("aria-valuemin", r),
							e.children[0].setAttribute("aria-valuemax", n),
							e.children[0].setAttribute("aria-valuenow", i),
							e.children[0].setAttribute("aria-valuetext", o);
					});
				}),
				(a = {
					destroy: function () {
						for (var t in b.cssClasses)
							b.cssClasses.hasOwnProperty(t) && mt(h, b.cssClasses[t]);
						for (; h.firstChild; ) h.removeChild(h.firstChild);
						delete h.noUiSlider;
					},
					steps: function () {
						return m.map(at);
					},
					on: $,
					off: G,
					get: st,
					set: ot,
					setHandle: function (t, e, r, n) {
						if (!(0 <= (t = Number(t)) && t < m.length))
							throw new Error(
								"noUiSlider (" + lt + "): invalid handle number, got: " + t
							);
						rt(t, it(e, t), !0, !0, n), J("update", t), r && J("set", t);
					},
					reset: function (t) {
						ot(b.start, t);
					},
					__moveHandles: function (t, e, r) {
						Z(t, e, S, r);
					},
					options: o,
					updateOptions: function (e, t) {
						var r = st(),
							n = [
								"margin",
								"limit",
								"padding",
								"range",
								"animate",
								"snap",
								"step",
								"format",
								"pips",
								"tooltips",
							];
						n.forEach(function (t) {
							void 0 !== e[t] && (o[t] = e[t]);
						});
						var i = vt(o);
						n.forEach(function (t) {
							void 0 !== e[t] && (b[t] = i[t]);
						}),
							(y = i.spectrum),
							(b.margin = i.margin),
							(b.limit = i.limit),
							(b.padding = i.padding),
							b.pips ? R(b.pips) : F(),
							b.tooltips ? H() : z(),
							(S = []),
							ot(e.start || r, t);
					},
					target: h,
					removePips: F,
					removeTooltips: z,
					getTooltips: function () {
						return i;
					},
					getOrigins: function () {
						return u;
					},
					pips: R,
				})
		);
	}
	return {
		__spectrum: i,
		version: lt,
		cssClasses: d,
		create: function (t, e) {
			if (!t || !t.nodeName)
				throw new Error(
					"noUiSlider (" + lt + "): create requires a single element, got: " + t
				);
			if (t.noUiSlider)
				throw new Error(
					"noUiSlider (" + lt + "): Slider was already initialized."
				);
			var r = j(t, vt(e), e);
			return (t.noUiSlider = r);
		},
	};

});


const rangeSlider = document.getElementById('range-slider');

if (rangeSlider) {
	noUiSlider.create(rangeSlider, {
		start: [500, 999999],
		connect: true,
		step: 1,
		range: {
			'min': [500],
			'max': [10000]
		}
	});

	const input0 = document.getElementById('input-0');
	const input1 = document.getElementById('input-1');
	const inputs = [input0, input1];

	rangeSlider.noUiSlider.on('update', function(values, handle){
		inputs[handle].value = Math.round(values[handle]);
	});

	const setRangeSlider = (i, value) => {
		let arr = [null, null];
		arr[i] = value;

		rangeSlider.noUiSlider.set(arr);
	};

	inputs.forEach((el, index) => {
		el.addEventListener('change', (e) => {
			console.log(index);
			setRangeSlider(index, e.currentTarget.value);
		});
	});
}

function getTimeRemaining(endtime) {
  const total = Date.parse(endtime) - Date.parse(new Date());
  const seconds = Math.floor((total / 1000) % 60);
  const minutes = Math.floor((total / 1000 / 60) % 60);
  const hours = Math.floor((total / (1000 * 60 * 60)) % 24);
  const days = Math.floor(total / (1000 * 60 * 60 * 24));

  return {
    total,
    days,
    hours,
    minutes,
    seconds
  };
}

function initializeClock(id, endtime) {
  const clock = document.querySelector('.promo__clock');
  const daysSpan = clock.querySelector('.promo__days');
  const hoursSpan = clock.querySelector('.promo__hours');
  const minutesSpan = clock.querySelector('.promo__minutes');
  const secondsSpan = clock.querySelector('.promo__seconds');

  function updateClock() {
    const t = getTimeRemaining(endtime);

    daysSpan.innerHTML = t.days;
    hoursSpan.innerHTML = ('0' + t.hours).slice(-2);
    minutesSpan.innerHTML = ('0' + t.minutes).slice(-2);
    secondsSpan.innerHTML = ('0' + t.seconds).slice(-2);

    if (t.total <= 0) {
      clearInterval(timeinterval);
    }
  }

  updateClock();
  const timeinterval = setInterval(updateClock, 1000);
}

const promo__clock = document.querySelector('.promo__clock')

if (promo__clock) {
  const deadline = new Date(Date.parse(new Date()) + 15 * 24 * 60 * 60 * 1000);
  initializeClock('promo__clock', deadline);
}



document.addEventListener('click', function (e) {
	element = e.target;

  

if (element.classList.contains('tab__link')) {
	e.preventDefault()

	let tabs = (element) => {
		let parentTabs = element.closest('.tab')

		let $tabLinkActiv = parentTabs.querySelector('.tab__link--active')
		let $tabContentActiv = parentTabs.querySelector('.tab__content-item--active')

		let $tabLink = parentTabs.querySelectorAll('.tab__link')
		let $tabsContent = parentTabs.querySelectorAll('.tab__content-item')


		$tabLinkActiv.classList.remove('tab__link--active')
		$tabContentActiv.classList.remove('tab__content-item--active')

		element.classList.add('tab__link--active')

		$tabLink.forEach((item, key) => {
			let tabClass = item.className.indexOf('tab__link--active')

			if(tabClass >= 1)
			{
				let array = [...$tabsContent]
				array[key].classList.add('tab__content-item--active')
			}
		})

	}

	tabs(element)

}


  if (element.classList.contains('select__input')) {
    const $select = element.closest('.select')
    $select.classList.toggle('open')
}
if (element.classList.contains('select__item')) {
    const $select = element.closest('.select')
    $select.classList.remove('open')


    const $selectInput = $select.querySelector('.select__input')
    $selectInput.textContent = element.textContent
}

  let $grid = element.closest('.shop-content__filter-btn')

  if ($grid) {
    $activeGrid = $grid.parentElement.querySelectorAll('.shop-content__filter-btn--active')
    $productItems = document.querySelectorAll('.product-item')

    $activeGrid.forEach((item) => {
        item.classList.remove('shop-content__filter-btn--active')
    })

    $productItems.forEach((item) => {
        item.classList.toggle('product-item--list')
    })

    $grid.classList.add('shop-content__filter-btn--active')
  }



});


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJzY3JpcHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiIShmdW5jdGlvbiAoZSwgdCkge1xuICBcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIG1vZHVsZVxuICAgID8gKG1vZHVsZS5leHBvcnRzID0gdCgpKVxuICAgIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZFxuICAgID8gZGVmaW5lKHQpXG4gICAgOiAoKGUgPVxuICAgICAgICBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBnbG9iYWxUaGlzXG4gICAgICAgICAgPyBnbG9iYWxUaGlzXG4gICAgICAgICAgOiBlIHx8IHNlbGYpLlN3aXBlciA9IHQoKSk7XG59KSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBmdW5jdGlvbiBlKGUsIHQpIHtcbiAgICBmb3IgKHZhciBhID0gMDsgYSA8IHQubGVuZ3RoOyBhKyspIHtcbiAgICAgIHZhciBpID0gdFthXTtcbiAgICAgIChpLmVudW1lcmFibGUgPSBpLmVudW1lcmFibGUgfHwgITEpLFxuICAgICAgICAoaS5jb25maWd1cmFibGUgPSAhMCksXG4gICAgICAgIFwidmFsdWVcIiBpbiBpICYmIChpLndyaXRhYmxlID0gITApLFxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgaS5rZXksIGkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0KCkge1xuICAgIHJldHVybiAodCA9XG4gICAgICBPYmplY3QuYXNzaWduIHx8XG4gICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzW3RdO1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gYSlcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBpKSAmJiAoZVtpXSA9IGFbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfSkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBmdW5jdGlvbiBhKGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgbnVsbCAhPT0gZSAmJlxuICAgICAgXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJlxuICAgICAgXCJjb25zdHJ1Y3RvclwiIGluIGUgJiZcbiAgICAgIGUuY29uc3RydWN0b3IgPT09IE9iamVjdFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gaShlLCB0KSB7XG4gICAgdm9pZCAwID09PSBlICYmIChlID0ge30pLFxuICAgICAgdm9pZCAwID09PSB0ICYmICh0ID0ge30pLFxuICAgICAgT2JqZWN0LmtleXModCkuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICB2b2lkIDAgPT09IGVbc11cbiAgICAgICAgICA/IChlW3NdID0gdFtzXSlcbiAgICAgICAgICA6IGEodFtzXSkgJiYgYShlW3NdKSAmJiBPYmplY3Qua2V5cyh0W3NdKS5sZW5ndGggPiAwICYmIGkoZVtzXSwgdFtzXSk7XG4gICAgICB9KTtcbiAgfVxuICB2YXIgcyA9IHtcbiAgICBib2R5OiB7fSxcbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7fSxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7fSxcbiAgICBhY3RpdmVFbGVtZW50OiB7IGJsdXI6IGZ1bmN0aW9uICgpIHt9LCBub2RlTmFtZTogXCJcIiB9LFxuICAgIHF1ZXJ5U2VsZWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgZ2V0RWxlbWVudEJ5SWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgY3JlYXRlRXZlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGluaXRFdmVudDogZnVuY3Rpb24gKCkge30gfTtcbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgIHN0eWxlOiB7fSxcbiAgICAgICAgc2V0QXR0cmlidXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgZ2V0RWxlbWVudHNCeVRhZ05hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudE5TOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICBpbXBvcnROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGxvY2F0aW9uOiB7XG4gICAgICBoYXNoOiBcIlwiLFxuICAgICAgaG9zdDogXCJcIixcbiAgICAgIGhvc3RuYW1lOiBcIlwiLFxuICAgICAgaHJlZjogXCJcIixcbiAgICAgIG9yaWdpbjogXCJcIixcbiAgICAgIHBhdGhuYW1lOiBcIlwiLFxuICAgICAgcHJvdG9jb2w6IFwiXCIsXG4gICAgICBzZWFyY2g6IFwiXCIsXG4gICAgfSxcbiAgfTtcbiAgZnVuY3Rpb24gcigpIHtcbiAgICB2YXIgZSA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGRvY3VtZW50ID8gZG9jdW1lbnQgOiB7fTtcbiAgICByZXR1cm4gaShlLCBzKSwgZTtcbiAgfVxuICB2YXIgbiA9IHtcbiAgICBkb2N1bWVudDogcyxcbiAgICBuYXZpZ2F0b3I6IHsgdXNlckFnZW50OiBcIlwiIH0sXG4gICAgbG9jYXRpb246IHtcbiAgICAgIGhhc2g6IFwiXCIsXG4gICAgICBob3N0OiBcIlwiLFxuICAgICAgaG9zdG5hbWU6IFwiXCIsXG4gICAgICBocmVmOiBcIlwiLFxuICAgICAgb3JpZ2luOiBcIlwiLFxuICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICBwcm90b2NvbDogXCJcIixcbiAgICAgIHNlYXJjaDogXCJcIixcbiAgICB9LFxuICAgIGhpc3Rvcnk6IHtcbiAgICAgIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKCkge30sXG4gICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgZ286IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgYmFjazogZnVuY3Rpb24gKCkge30sXG4gICAgfSxcbiAgICBDdXN0b21FdmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7fSxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7fSxcbiAgICBnZXRDb21wdXRlZFN0eWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXRQcm9wZXJ0eVZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG4gICAgSW1hZ2U6IGZ1bmN0aW9uICgpIHt9LFxuICAgIERhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgIHNjcmVlbjoge30sXG4gICAgc2V0VGltZW91dDogZnVuY3Rpb24gKCkge30sXG4gICAgY2xlYXJUaW1lb3V0OiBmdW5jdGlvbiAoKSB7fSxcbiAgICBtYXRjaE1lZGlhOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2Ygc2V0VGltZW91dCA/IChlKCksIG51bGwpIDogc2V0VGltZW91dChlLCAwKTtcbiAgICB9LFxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lOiBmdW5jdGlvbiAoZSkge1xuICAgICAgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygc2V0VGltZW91dCAmJiBjbGVhclRpbWVvdXQoZSk7XG4gICAgfSxcbiAgfTtcbiAgZnVuY3Rpb24gbCgpIHtcbiAgICB2YXIgZSA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyA/IHdpbmRvdyA6IHt9O1xuICAgIHJldHVybiBpKGUsIG4pLCBlO1xuICB9XG4gIGZ1bmN0aW9uIG8oZSkge1xuICAgIHJldHVybiAobyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZlxuICAgICAgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbiAgICAgIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpO1xuICAgICAgICB9KShlKTtcbiAgfVxuICBmdW5jdGlvbiBkKGUsIHQpIHtcbiAgICByZXR1cm4gKGQgPVxuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICByZXR1cm4gKGUuX19wcm90b19fID0gdCksIGU7XG4gICAgICB9KShlLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBwKCkge1xuICAgIGlmIChcInVuZGVmaW5lZFwiID09IHR5cGVvZiBSZWZsZWN0IHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuICExO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gITE7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgUHJveHkpIHJldHVybiAhMDtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pXG4gICAgICAgICksXG4gICAgICAgICEwXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdShlLCB0LCBhKSB7XG4gICAgcmV0dXJuICh1ID0gcCgpXG4gICAgICA/IFJlZmxlY3QuY29uc3RydWN0XG4gICAgICA6IGZ1bmN0aW9uIChlLCB0LCBhKSB7XG4gICAgICAgICAgdmFyIGkgPSBbbnVsbF07XG4gICAgICAgICAgaS5wdXNoLmFwcGx5KGksIHQpO1xuICAgICAgICAgIHZhciBzID0gbmV3IChGdW5jdGlvbi5iaW5kLmFwcGx5KGUsIGkpKSgpO1xuICAgICAgICAgIHJldHVybiBhICYmIGQocywgYS5wcm90b3R5cGUpLCBzO1xuICAgICAgICB9KS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIGMoZSkge1xuICAgIHZhciB0ID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBNYXAgPyBuZXcgTWFwKCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIChjID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCA9PT0gZSB8fFxuICAgICAgICAoKGEgPSBlKSwgLTEgPT09IEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoYSkuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikpXG4gICAgICApXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgdmFyIGE7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIlxuICAgICAgICApO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gdCkge1xuICAgICAgICBpZiAodC5oYXMoZSkpIHJldHVybiB0LmdldChlKTtcbiAgICAgICAgdC5zZXQoZSwgaSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpKCkge1xuICAgICAgICByZXR1cm4gdShlLCBhcmd1bWVudHMsIG8odGhpcykuY29uc3RydWN0b3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSwge1xuICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogaSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KSksXG4gICAgICAgIGQoaSwgZSlcbiAgICAgICk7XG4gICAgfSkoZSk7XG4gIH1cbiAgdmFyIGggPSAoZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgdCwgYTtcbiAgICBmdW5jdGlvbiBpKHQpIHtcbiAgICAgIHZhciBhLCBpLCBzO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGEgPSBlLmNhbGwuYXBwbHkoZSwgW3RoaXNdLmNvbmNhdCh0KSkgfHwgdGhpcyksXG4gICAgICAgIChpID0gKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgICAgICAgXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSkoYSkpLFxuICAgICAgICAocyA9IGkuX19wcm90b19fKSxcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIFwiX19wcm90b19fXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcy5fX3Byb3RvX18gPSBlO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgICBhXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgKGEgPSBlKSxcbiAgICAgICgodCA9IGkpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYS5wcm90b3R5cGUpKSxcbiAgICAgICh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHQpLFxuICAgICAgKHQuX19wcm90b19fID0gYSksXG4gICAgICBpXG4gICAgKTtcbiAgfSkoYyhBcnJheSkpO1xuICBmdW5jdGlvbiB2KGUpIHtcbiAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSBbXSk7XG4gICAgdmFyIHQgPSBbXTtcbiAgICByZXR1cm4gKFxuICAgICAgZS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIEFycmF5LmlzQXJyYXkoZSkgPyB0LnB1c2guYXBwbHkodCwgdihlKSkgOiB0LnB1c2goZSk7XG4gICAgICB9KSxcbiAgICAgIHRcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGYoZSwgdCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZSwgdCk7XG4gIH1cbiAgZnVuY3Rpb24gbShlLCB0KSB7XG4gICAgdmFyIGEgPSBsKCksXG4gICAgICBpID0gcigpLFxuICAgICAgcyA9IFtdO1xuICAgIGlmICghdCAmJiBlIGluc3RhbmNlb2YgaCkgcmV0dXJuIGU7XG4gICAgaWYgKCFlKSByZXR1cm4gbmV3IGgocyk7XG4gICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICAgIHZhciBuID0gZS50cmltKCk7XG4gICAgICBpZiAobi5pbmRleE9mKFwiPFwiKSA+PSAwICYmIG4uaW5kZXhPZihcIj5cIikgPj0gMCkge1xuICAgICAgICB2YXIgbyA9IFwiZGl2XCI7XG4gICAgICAgIDAgPT09IG4uaW5kZXhPZihcIjxsaVwiKSAmJiAobyA9IFwidWxcIiksXG4gICAgICAgICAgMCA9PT0gbi5pbmRleE9mKFwiPHRyXCIpICYmIChvID0gXCJ0Ym9keVwiKSxcbiAgICAgICAgICAoMCAhPT0gbi5pbmRleE9mKFwiPHRkXCIpICYmIDAgIT09IG4uaW5kZXhPZihcIjx0aFwiKSkgfHwgKG8gPSBcInRyXCIpLFxuICAgICAgICAgIDAgPT09IG4uaW5kZXhPZihcIjx0Ym9keVwiKSAmJiAobyA9IFwidGFibGVcIiksXG4gICAgICAgICAgMCA9PT0gbi5pbmRleE9mKFwiPG9wdGlvblwiKSAmJiAobyA9IFwic2VsZWN0XCIpO1xuICAgICAgICB2YXIgZCA9IGkuY3JlYXRlRWxlbWVudChvKTtcbiAgICAgICAgZC5pbm5lckhUTUwgPSBuO1xuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IGQuY2hpbGROb2Rlcy5sZW5ndGg7IHAgKz0gMSlcbiAgICAgICAgICBzLnB1c2goZC5jaGlsZE5vZGVzW3BdKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBzID0gKGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGUpIHJldHVybiBbZV07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciBhID0gW10sIGkgPSB0LnF1ZXJ5U2VsZWN0b3JBbGwoZSksIHMgPSAwO1xuICAgICAgICAgICAgcyA8IGkubGVuZ3RoO1xuICAgICAgICAgICAgcyArPSAxXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYS5wdXNoKGlbc10pO1xuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9KShlLnRyaW0oKSwgdCB8fCBpKTtcbiAgICB9IGVsc2UgaWYgKGUubm9kZVR5cGUgfHwgZSA9PT0gYSB8fCBlID09PSBpKSBzLnB1c2goZSk7XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBoKSByZXR1cm4gZTtcbiAgICAgIHMgPSBlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGgoXG4gICAgICAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZm9yICh2YXIgdCA9IFtdLCBhID0gMDsgYSA8IGUubGVuZ3RoOyBhICs9IDEpXG4gICAgICAgICAgLTEgPT09IHQuaW5kZXhPZihlW2FdKSAmJiB0LnB1c2goZVthXSk7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfSkocylcbiAgICApO1xuICB9XG4gIG0uZm4gPSBoLnByb3RvdHlwZTtcbiAgdmFyIGcsXG4gICAgeSxcbiAgICB3LFxuICAgIGIgPSB7XG4gICAgICBhZGRDbGFzczogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShlKSwgYSA9IDA7IGEgPCBlOyBhKyspXG4gICAgICAgICAgdFthXSA9IGFyZ3VtZW50c1thXTtcbiAgICAgICAgdmFyIGkgPSB2KFxuICAgICAgICAgIHQubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgKHQgPSBlLmNsYXNzTGlzdCkuYWRkLmFwcGx5KHQsIGkpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShlKSwgYSA9IDA7IGEgPCBlOyBhKyspXG4gICAgICAgICAgdFthXSA9IGFyZ3VtZW50c1thXTtcbiAgICAgICAgdmFyIGkgPSB2KFxuICAgICAgICAgIHQubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgKHQgPSBlLmNsYXNzTGlzdCkucmVtb3ZlLmFwcGx5KHQsIGkpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBoYXNDbGFzczogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShlKSwgYSA9IDA7IGEgPCBlOyBhKyspXG4gICAgICAgICAgdFthXSA9IGFyZ3VtZW50c1thXTtcbiAgICAgICAgdmFyIGkgPSB2KFxuICAgICAgICAgIHQubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBmKHRoaXMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBpLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmNsYXNzTGlzdC5jb250YWlucyh0KTtcbiAgICAgICAgICAgICAgfSkubGVuZ3RoID4gMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KS5sZW5ndGggPiAwXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoZSksIGEgPSAwOyBhIDwgZTsgYSsrKVxuICAgICAgICAgIHRbYV0gPSBhcmd1bWVudHNbYV07XG4gICAgICAgIHZhciBpID0gdihcbiAgICAgICAgICB0Lm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGkuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgZS5jbGFzc0xpc3QudG9nZ2xlKHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBhdHRyOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBlKVxuICAgICAgICAgIHJldHVybiB0aGlzWzBdID8gdGhpc1swXS5nZXRBdHRyaWJ1dGUoZSkgOiB2b2lkIDA7XG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgdGhpcy5sZW5ndGg7IGEgKz0gMSlcbiAgICAgICAgICBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkgdGhpc1thXS5zZXRBdHRyaWJ1dGUoZSwgdCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBlKSAodGhpc1thXVtpXSA9IGVbaV0pLCB0aGlzW2FdLnNldEF0dHJpYnV0ZShpLCBlW2ldKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGlzLmxlbmd0aDsgdCArPSAxKSB0aGlzW3RdLnJlbW92ZUF0dHJpYnV0ZShlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHRoaXMubGVuZ3RoOyB0ICs9IDEpIHRoaXNbdF0uc3R5bGUudHJhbnNmb3JtID0gZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgdHJhbnNpdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGlzLmxlbmd0aDsgdCArPSAxKVxuICAgICAgICAgIHRoaXNbdF0uc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID1cbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgPyBlICsgXCJtc1wiIDogZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoZSksIGEgPSAwOyBhIDwgZTsgYSsrKVxuICAgICAgICAgIHRbYV0gPSBhcmd1bWVudHNbYV07XG4gICAgICAgIHZhciBpID0gdFswXSxcbiAgICAgICAgICBzID0gdFsxXSxcbiAgICAgICAgICByID0gdFsyXSxcbiAgICAgICAgICBuID0gdFszXTtcbiAgICAgICAgZnVuY3Rpb24gbChlKSB7XG4gICAgICAgICAgdmFyIHQgPSBlLnRhcmdldDtcbiAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgdmFyIGEgPSBlLnRhcmdldC5kb203RXZlbnREYXRhIHx8IFtdO1xuICAgICAgICAgICAgaWYgKChhLmluZGV4T2YoZSkgPCAwICYmIGEudW5zaGlmdChlKSwgbSh0KS5pcyhzKSkpIHIuYXBwbHkodCwgYSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBtKHQpLnBhcmVudHMoKSwgbiA9IDA7IG4gPCBpLmxlbmd0aDsgbiArPSAxKVxuICAgICAgICAgICAgICAgIG0oaVtuXSkuaXMocykgJiYgci5hcHBseShpW25dLCBhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbyhlKSB7XG4gICAgICAgICAgdmFyIHQgPSAoZSAmJiBlLnRhcmdldCAmJiBlLnRhcmdldC5kb203RXZlbnREYXRhKSB8fCBbXTtcbiAgICAgICAgICB0LmluZGV4T2YoZSkgPCAwICYmIHQudW5zaGlmdChlKSwgci5hcHBseSh0aGlzLCB0KTtcbiAgICAgICAgfVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRbMV0gJiZcbiAgICAgICAgICAoKGkgPSB0WzBdKSwgKHIgPSB0WzFdKSwgKG4gPSB0WzJdKSwgKHMgPSB2b2lkIDApKSxcbiAgICAgICAgICBuIHx8IChuID0gITEpO1xuICAgICAgICBmb3IgKHZhciBkLCBwID0gaS5zcGxpdChcIiBcIiksIHUgPSAwOyB1IDwgdGhpcy5sZW5ndGg7IHUgKz0gMSkge1xuICAgICAgICAgIHZhciBjID0gdGhpc1t1XTtcbiAgICAgICAgICBpZiAocylcbiAgICAgICAgICAgIGZvciAoZCA9IDA7IGQgPCBwLmxlbmd0aDsgZCArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBoID0gcFtkXTtcbiAgICAgICAgICAgICAgYy5kb203TGl2ZUxpc3RlbmVycyB8fCAoYy5kb203TGl2ZUxpc3RlbmVycyA9IHt9KSxcbiAgICAgICAgICAgICAgICBjLmRvbTdMaXZlTGlzdGVuZXJzW2hdIHx8IChjLmRvbTdMaXZlTGlzdGVuZXJzW2hdID0gW10pLFxuICAgICAgICAgICAgICAgIGMuZG9tN0xpdmVMaXN0ZW5lcnNbaF0ucHVzaCh7IGxpc3RlbmVyOiByLCBwcm94eUxpc3RlbmVyOiBsIH0pLFxuICAgICAgICAgICAgICAgIGMuYWRkRXZlbnRMaXN0ZW5lcihoLCBsLCBuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGQgPSAwOyBkIDwgcC5sZW5ndGg7IGQgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgdiA9IHBbZF07XG4gICAgICAgICAgICAgIGMuZG9tN0xpc3RlbmVycyB8fCAoYy5kb203TGlzdGVuZXJzID0ge30pLFxuICAgICAgICAgICAgICAgIGMuZG9tN0xpc3RlbmVyc1t2XSB8fCAoYy5kb203TGlzdGVuZXJzW3ZdID0gW10pLFxuICAgICAgICAgICAgICAgIGMuZG9tN0xpc3RlbmVyc1t2XS5wdXNoKHsgbGlzdGVuZXI6IHIsIHByb3h5TGlzdGVuZXI6IG8gfSksXG4gICAgICAgICAgICAgICAgYy5hZGRFdmVudExpc3RlbmVyKHYsIG8sIG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG9mZjogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShlKSwgYSA9IDA7IGEgPCBlOyBhKyspXG4gICAgICAgICAgdFthXSA9IGFyZ3VtZW50c1thXTtcbiAgICAgICAgdmFyIGkgPSB0WzBdLFxuICAgICAgICAgIHMgPSB0WzFdLFxuICAgICAgICAgIHIgPSB0WzJdLFxuICAgICAgICAgIG4gPSB0WzNdO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRbMV0gJiZcbiAgICAgICAgICAoKGkgPSB0WzBdKSwgKHIgPSB0WzFdKSwgKG4gPSB0WzJdKSwgKHMgPSB2b2lkIDApKSxcbiAgICAgICAgICBuIHx8IChuID0gITEpO1xuICAgICAgICBmb3IgKHZhciBsID0gaS5zcGxpdChcIiBcIiksIG8gPSAwOyBvIDwgbC5sZW5ndGg7IG8gKz0gMSlcbiAgICAgICAgICBmb3IgKHZhciBkID0gbFtvXSwgcCA9IDA7IHAgPCB0aGlzLmxlbmd0aDsgcCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgdSA9IHRoaXNbcF0sXG4gICAgICAgICAgICAgIGMgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICghcyAmJiB1LmRvbTdMaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICA/IChjID0gdS5kb203TGlzdGVuZXJzW2RdKVxuICAgICAgICAgICAgICAgIDogcyAmJiB1LmRvbTdMaXZlTGlzdGVuZXJzICYmIChjID0gdS5kb203TGl2ZUxpc3RlbmVyc1tkXSksXG4gICAgICAgICAgICAgIGMgJiYgYy5sZW5ndGgpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIGZvciAodmFyIGggPSBjLmxlbmd0aCAtIDE7IGggPj0gMDsgaCAtPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSBjW2hdO1xuICAgICAgICAgICAgICAgIChyICYmIHYubGlzdGVuZXIgPT09IHIpIHx8XG4gICAgICAgICAgICAgICAgKHIgJiZcbiAgICAgICAgICAgICAgICAgIHYubGlzdGVuZXIgJiZcbiAgICAgICAgICAgICAgICAgIHYubGlzdGVuZXIuZG9tN3Byb3h5ICYmXG4gICAgICAgICAgICAgICAgICB2Lmxpc3RlbmVyLmRvbTdwcm94eSA9PT0gcilcbiAgICAgICAgICAgICAgICAgID8gKHUucmVtb3ZlRXZlbnRMaXN0ZW5lcihkLCB2LnByb3h5TGlzdGVuZXIsIG4pLFxuICAgICAgICAgICAgICAgICAgICBjLnNwbGljZShoLCAxKSlcbiAgICAgICAgICAgICAgICAgIDogciB8fFxuICAgICAgICAgICAgICAgICAgICAodS5yZW1vdmVFdmVudExpc3RlbmVyKGQsIHYucHJveHlMaXN0ZW5lciwgbiksXG4gICAgICAgICAgICAgICAgICAgIGMuc3BsaWNlKGgsIDEpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBlID0gbCgpLCB0ID0gYXJndW1lbnRzLmxlbmd0aCwgYSA9IG5ldyBBcnJheSh0KSwgaSA9IDA7XG4gICAgICAgICAgaSA8IHQ7XG4gICAgICAgICAgaSsrXG4gICAgICAgIClcbiAgICAgICAgICBhW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBzID0gYVswXS5zcGxpdChcIiBcIiksIHIgPSBhWzFdLCBuID0gMDsgbiA8IHMubGVuZ3RoOyBuICs9IDEpXG4gICAgICAgICAgZm9yICh2YXIgbyA9IHNbbl0sIGQgPSAwOyBkIDwgdGhpcy5sZW5ndGg7IGQgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzW2RdO1xuICAgICAgICAgICAgaWYgKGUuQ3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFyIHUgPSBuZXcgZS5DdXN0b21FdmVudChvLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiByLFxuICAgICAgICAgICAgICAgIGJ1YmJsZXM6ICEwLFxuICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgKHAuZG9tN0V2ZW50RGF0YSA9IGEuZmlsdGVyKGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQgPiAwO1xuICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgcC5kaXNwYXRjaEV2ZW50KHUpLFxuICAgICAgICAgICAgICAgIChwLmRvbTdFdmVudERhdGEgPSBbXSksXG4gICAgICAgICAgICAgICAgZGVsZXRlIHAuZG9tN0V2ZW50RGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBlICYmXG4gICAgICAgICAgICB0Lm9uKFwidHJhbnNpdGlvbmVuZFwiLCBmdW5jdGlvbiBhKGkpIHtcbiAgICAgICAgICAgICAgaS50YXJnZXQgPT09IHRoaXMgJiYgKGUuY2FsbCh0aGlzLCBpKSwgdC5vZmYoXCJ0cmFuc2l0aW9uZW5kXCIsIGEpKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBvdXRlcldpZHRoOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0gdGhpcy5zdHlsZXMoKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHRoaXNbMF0ub2Zmc2V0V2lkdGggK1xuICAgICAgICAgICAgICBwYXJzZUZsb2F0KHQuZ2V0UHJvcGVydHlWYWx1ZShcIm1hcmdpbi1yaWdodFwiKSkgK1xuICAgICAgICAgICAgICBwYXJzZUZsb2F0KHQuZ2V0UHJvcGVydHlWYWx1ZShcIm1hcmdpbi1sZWZ0XCIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXNbMF0ub2Zmc2V0V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgb3V0ZXJIZWlnaHQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLnN0eWxlcygpO1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgdGhpc1swXS5vZmZzZXRIZWlnaHQgK1xuICAgICAgICAgICAgICBwYXJzZUZsb2F0KHQuZ2V0UHJvcGVydHlWYWx1ZShcIm1hcmdpbi10b3BcIikpICtcbiAgICAgICAgICAgICAgcGFyc2VGbG9hdCh0LmdldFByb3BlcnR5VmFsdWUoXCJtYXJnaW4tYm90dG9tXCIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXNbMF0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHN0eWxlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IGwoKTtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gPyBlLmdldENvbXB1dGVkU3R5bGUodGhpc1swXSwgbnVsbCkgOiB7fTtcbiAgICAgIH0sXG4gICAgICBvZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBlID0gbCgpLFxuICAgICAgICAgICAgdCA9IHIoKSxcbiAgICAgICAgICAgIGEgPSB0aGlzWzBdLFxuICAgICAgICAgICAgaSA9IGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBzID0gdC5ib2R5LFxuICAgICAgICAgICAgbiA9IGEuY2xpZW50VG9wIHx8IHMuY2xpZW50VG9wIHx8IDAsXG4gICAgICAgICAgICBvID0gYS5jbGllbnRMZWZ0IHx8IHMuY2xpZW50TGVmdCB8fCAwLFxuICAgICAgICAgICAgZCA9IGEgPT09IGUgPyBlLnNjcm9sbFkgOiBhLnNjcm9sbFRvcCxcbiAgICAgICAgICAgIHAgPSBhID09PSBlID8gZS5zY3JvbGxYIDogYS5zY3JvbGxMZWZ0O1xuICAgICAgICAgIHJldHVybiB7IHRvcDogaS50b3AgKyBkIC0gbiwgbGVmdDogaS5sZWZ0ICsgcCAtIG8gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICBjc3M6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHZhciBhLFxuICAgICAgICAgIGkgPSBsKCk7XG4gICAgICAgIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGUpIHtcbiAgICAgICAgICAgIGZvciAoYSA9IDA7IGEgPCB0aGlzLmxlbmd0aDsgYSArPSAxKVxuICAgICAgICAgICAgICBmb3IgKHZhciBzIGluIGUpIHRoaXNbYV0uc3R5bGVbc10gPSBlW3NdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzWzBdKVxuICAgICAgICAgICAgcmV0dXJuIGkuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzWzBdLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICAgICAgICBmb3IgKGEgPSAwOyBhIDwgdGhpcy5sZW5ndGg7IGEgKz0gMSkgdGhpc1thXS5zdHlsZVtlXSA9IHQ7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZWFjaDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgICA/ICh0aGlzLmZvckVhY2goZnVuY3Rpb24gKHQsIGEpIHtcbiAgICAgICAgICAgICAgZS5hcHBseSh0LCBbdCwgYV0pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzKVxuICAgICAgICAgIDogdGhpcztcbiAgICAgIH0sXG4gICAgICBodG1sOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodm9pZCAwID09PSBlKSByZXR1cm4gdGhpc1swXSA/IHRoaXNbMF0uaW5uZXJIVE1MIDogbnVsbDtcbiAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGlzLmxlbmd0aDsgdCArPSAxKSB0aGlzW3RdLmlubmVySFRNTCA9IGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHRleHQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IGUpIHJldHVybiB0aGlzWzBdID8gdGhpc1swXS50ZXh0Q29udGVudC50cmltKCkgOiBudWxsO1xuICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHRoaXMubGVuZ3RoOyB0ICs9IDEpIHRoaXNbdF0udGV4dENvbnRlbnQgPSBlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBpczogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBpID0gbCgpLFxuICAgICAgICAgIHMgPSByKCksXG4gICAgICAgICAgbiA9IHRoaXNbMF07XG4gICAgICAgIGlmICghbiB8fCB2b2lkIDAgPT09IGUpIHJldHVybiAhMTtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICAgICAgICBpZiAobi5tYXRjaGVzKSByZXR1cm4gbi5tYXRjaGVzKGUpO1xuICAgICAgICAgIGlmIChuLndlYmtpdE1hdGNoZXNTZWxlY3RvcikgcmV0dXJuIG4ud2Via2l0TWF0Y2hlc1NlbGVjdG9yKGUpO1xuICAgICAgICAgIGlmIChuLm1zTWF0Y2hlc1NlbGVjdG9yKSByZXR1cm4gbi5tc01hdGNoZXNTZWxlY3RvcihlKTtcbiAgICAgICAgICBmb3IgKHQgPSBtKGUpLCBhID0gMDsgYSA8IHQubGVuZ3RoOyBhICs9IDEpIGlmICh0W2FdID09PSBuKSByZXR1cm4gITA7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlID09PSBzKSByZXR1cm4gbiA9PT0gcztcbiAgICAgICAgaWYgKGUgPT09IGkpIHJldHVybiBuID09PSBpO1xuICAgICAgICBpZiAoZS5ub2RlVHlwZSB8fCBlIGluc3RhbmNlb2YgaCkge1xuICAgICAgICAgIGZvciAodCA9IGUubm9kZVR5cGUgPyBbZV0gOiBlLCBhID0gMDsgYSA8IHQubGVuZ3RoOyBhICs9IDEpXG4gICAgICAgICAgICBpZiAodFthXSA9PT0gbikgcmV0dXJuICEwO1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LFxuICAgICAgaW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUsXG4gICAgICAgICAgdCA9IHRoaXNbMF07XG4gICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgZm9yIChlID0gMDsgbnVsbCAhPT0gKHQgPSB0LnByZXZpb3VzU2libGluZyk7IClcbiAgICAgICAgICAgIDEgPT09IHQubm9kZVR5cGUgJiYgKGUgKz0gMSk7XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlcTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgcmV0dXJuIHRoaXM7XG4gICAgICAgIHZhciB0ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChlID4gdCAtIDEpIHJldHVybiBtKFtdKTtcbiAgICAgICAgaWYgKGUgPCAwKSB7XG4gICAgICAgICAgdmFyIGEgPSB0ICsgZTtcbiAgICAgICAgICByZXR1cm4gbShhIDwgMCA/IFtdIDogW3RoaXNbYV1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbShbdGhpc1tlXV0pO1xuICAgICAgfSxcbiAgICAgIGFwcGVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBlLCB0ID0gcigpLCBhID0gMDsgYSA8IGFyZ3VtZW50cy5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgICAgIGUgPSBhIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGEgPyB2b2lkIDAgOiBhcmd1bWVudHNbYV07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKVxuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICAgICAgICAgICAgdmFyIHMgPSB0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgIGZvciAocy5pbm5lckhUTUwgPSBlOyBzLmZpcnN0Q2hpbGQ7IClcbiAgICAgICAgICAgICAgICB0aGlzW2ldLmFwcGVuZENoaWxkKHMuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBoKVxuICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUubGVuZ3RoOyBuICs9IDEpIHRoaXNbaV0uYXBwZW5kQ2hpbGQoZVtuXSk7XG4gICAgICAgICAgICBlbHNlIHRoaXNbaV0uYXBwZW5kQ2hpbGQoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgcHJlcGVuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBpID0gcigpO1xuICAgICAgICBmb3IgKHQgPSAwOyB0IDwgdGhpcy5sZW5ndGg7IHQgKz0gMSlcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgICAgICAgICAgdmFyIHMgPSBpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBmb3IgKHMuaW5uZXJIVE1MID0gZSwgYSA9IHMuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBhID49IDA7IGEgLT0gMSlcbiAgICAgICAgICAgICAgdGhpc1t0XS5pbnNlcnRCZWZvcmUocy5jaGlsZE5vZGVzW2FdLCB0aGlzW3RdLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIGgpXG4gICAgICAgICAgICBmb3IgKGEgPSAwOyBhIDwgZS5sZW5ndGg7IGEgKz0gMSlcbiAgICAgICAgICAgICAgdGhpc1t0XS5pbnNlcnRCZWZvcmUoZVthXSwgdGhpc1t0XS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICBlbHNlIHRoaXNbdF0uaW5zZXJ0QmVmb3JlKGUsIHRoaXNbdF0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IDBcbiAgICAgICAgICA/IGVcbiAgICAgICAgICAgID8gdGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmcgJiYgbSh0aGlzWzBdLm5leHRFbGVtZW50U2libGluZykuaXMoZSlcbiAgICAgICAgICAgICAgPyBtKFt0aGlzWzBdLm5leHRFbGVtZW50U2libGluZ10pXG4gICAgICAgICAgICAgIDogbShbXSlcbiAgICAgICAgICAgIDogdGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmdcbiAgICAgICAgICAgID8gbShbdGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmddKVxuICAgICAgICAgICAgOiBtKFtdKVxuICAgICAgICAgIDogbShbXSk7XG4gICAgICB9LFxuICAgICAgbmV4dEFsbDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQgPSBbXSxcbiAgICAgICAgICBhID0gdGhpc1swXTtcbiAgICAgICAgaWYgKCFhKSByZXR1cm4gbShbXSk7XG4gICAgICAgIGZvciAoOyBhLm5leHRFbGVtZW50U2libGluZzsgKSB7XG4gICAgICAgICAgdmFyIGkgPSBhLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgICBlID8gbShpKS5pcyhlKSAmJiB0LnB1c2goaSkgOiB0LnB1c2goaSksIChhID0gaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0odCk7XG4gICAgICB9LFxuICAgICAgcHJldjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0ID0gdGhpc1swXTtcbiAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgPyB0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgbSh0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcpLmlzKGUpXG4gICAgICAgICAgICAgID8gbShbdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nXSlcbiAgICAgICAgICAgICAgOiBtKFtdKVxuICAgICAgICAgICAgOiB0LnByZXZpb3VzRWxlbWVudFNpYmxpbmdcbiAgICAgICAgICAgID8gbShbdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nXSlcbiAgICAgICAgICAgIDogbShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0oW10pO1xuICAgICAgfSxcbiAgICAgIHByZXZBbGw6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0ID0gW10sXG4gICAgICAgICAgYSA9IHRoaXNbMF07XG4gICAgICAgIGlmICghYSkgcmV0dXJuIG0oW10pO1xuICAgICAgICBmb3IgKDsgYS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nOyApIHtcbiAgICAgICAgICB2YXIgaSA9IGEucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICAgICAgICBlID8gbShpKS5pcyhlKSAmJiB0LnB1c2goaSkgOiB0LnB1c2goaSksIChhID0gaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0odCk7XG4gICAgICB9LFxuICAgICAgcGFyZW50OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmb3IgKHZhciB0ID0gW10sIGEgPSAwOyBhIDwgdGhpcy5sZW5ndGg7IGEgKz0gMSlcbiAgICAgICAgICBudWxsICE9PSB0aGlzW2FdLnBhcmVudE5vZGUgJiZcbiAgICAgICAgICAgIChlXG4gICAgICAgICAgICAgID8gbSh0aGlzW2FdLnBhcmVudE5vZGUpLmlzKGUpICYmIHQucHVzaCh0aGlzW2FdLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgIDogdC5wdXNoKHRoaXNbYV0ucGFyZW50Tm9kZSkpO1xuICAgICAgICByZXR1cm4gbSh0KTtcbiAgICAgIH0sXG4gICAgICBwYXJlbnRzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmb3IgKHZhciB0ID0gW10sIGEgPSAwOyBhIDwgdGhpcy5sZW5ndGg7IGEgKz0gMSlcbiAgICAgICAgICBmb3IgKHZhciBpID0gdGhpc1thXS5wYXJlbnROb2RlOyBpOyApXG4gICAgICAgICAgICBlID8gbShpKS5pcyhlKSAmJiB0LnB1c2goaSkgOiB0LnB1c2goaSksIChpID0gaS5wYXJlbnROb2RlKTtcbiAgICAgICAgcmV0dXJuIG0odCk7XG4gICAgICB9LFxuICAgICAgY2xvc2VzdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdm9pZCAwID09PSBlID8gbShbXSkgOiAodC5pcyhlKSB8fCAodCA9IHQucGFyZW50cyhlKS5lcSgwKSksIHQpO1xuICAgICAgfSxcbiAgICAgIGZpbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGZvciAodmFyIHQgPSBbXSwgYSA9IDA7IGEgPCB0aGlzLmxlbmd0aDsgYSArPSAxKVxuICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzW2FdLnF1ZXJ5U2VsZWN0b3JBbGwoZSksIHMgPSAwOyBzIDwgaS5sZW5ndGg7IHMgKz0gMSlcbiAgICAgICAgICAgIHQucHVzaChpW3NdKTtcbiAgICAgICAgcmV0dXJuIG0odCk7XG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGZvciAodmFyIHQgPSBbXSwgYSA9IDA7IGEgPCB0aGlzLmxlbmd0aDsgYSArPSAxKVxuICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzW2FdLmNoaWxkcmVuLCBzID0gMDsgcyA8IGkubGVuZ3RoOyBzICs9IDEpXG4gICAgICAgICAgICAoZSAmJiAhbShpW3NdKS5pcyhlKSkgfHwgdC5wdXNoKGlbc10pO1xuICAgICAgICByZXR1cm4gbSh0KTtcbiAgICAgIH0sXG4gICAgICBmaWx0ZXI6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBtKGYodGhpcywgZSkpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMubGVuZ3RoOyBlICs9IDEpXG4gICAgICAgICAgdGhpc1tlXS5wYXJlbnROb2RlICYmIHRoaXNbZV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzW2VdKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgIH07XG4gIGZ1bmN0aW9uIEUoZSwgdCkge1xuICAgIHJldHVybiB2b2lkIDAgPT09IHQgJiYgKHQgPSAwKSwgc2V0VGltZW91dChlLCB0KTtcbiAgfVxuICBmdW5jdGlvbiB4KCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9XG4gIGZ1bmN0aW9uIFQoZSwgdCkge1xuICAgIHZvaWQgMCA9PT0gdCAmJiAodCA9IFwieFwiKTtcbiAgICB2YXIgYSxcbiAgICAgIGksXG4gICAgICBzLFxuICAgICAgciA9IGwoKSxcbiAgICAgIG4gPSByLmdldENvbXB1dGVkU3R5bGUoZSwgbnVsbCk7XG4gICAgcmV0dXJuIChcbiAgICAgIHIuV2ViS2l0Q1NTTWF0cml4XG4gICAgICAgID8gKChpID0gbi50cmFuc2Zvcm0gfHwgbi53ZWJraXRUcmFuc2Zvcm0pLnNwbGl0KFwiLFwiKS5sZW5ndGggPiA2ICYmXG4gICAgICAgICAgICAoaSA9IGlcbiAgICAgICAgICAgICAgLnNwbGl0KFwiLCBcIilcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLnJlcGxhY2UoXCIsXCIsIFwiLlwiKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmpvaW4oXCIsIFwiKSksXG4gICAgICAgICAgKHMgPSBuZXcgci5XZWJLaXRDU1NNYXRyaXgoXCJub25lXCIgPT09IGkgPyBcIlwiIDogaSkpKVxuICAgICAgICA6IChhID0gKHMgPVxuICAgICAgICAgICAgbi5Nb3pUcmFuc2Zvcm0gfHxcbiAgICAgICAgICAgIG4uT1RyYW5zZm9ybSB8fFxuICAgICAgICAgICAgbi5Nc1RyYW5zZm9ybSB8fFxuICAgICAgICAgICAgbi5tc1RyYW5zZm9ybSB8fFxuICAgICAgICAgICAgbi50cmFuc2Zvcm0gfHxcbiAgICAgICAgICAgIG5cbiAgICAgICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUoXCJ0cmFuc2Zvcm1cIilcbiAgICAgICAgICAgICAgLnJlcGxhY2UoXCJ0cmFuc2xhdGUoXCIsIFwibWF0cml4KDEsIDAsIDAsIDEsXCIpKVxuICAgICAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgICAgIC5zcGxpdChcIixcIikpLFxuICAgICAgXCJ4XCIgPT09IHQgJiZcbiAgICAgICAgKGkgPSByLldlYktpdENTU01hdHJpeFxuICAgICAgICAgID8gcy5tNDFcbiAgICAgICAgICA6IDE2ID09PSBhLmxlbmd0aFxuICAgICAgICAgID8gcGFyc2VGbG9hdChhWzEyXSlcbiAgICAgICAgICA6IHBhcnNlRmxvYXQoYVs0XSkpLFxuICAgICAgXCJ5XCIgPT09IHQgJiZcbiAgICAgICAgKGkgPSByLldlYktpdENTU01hdHJpeFxuICAgICAgICAgID8gcy5tNDJcbiAgICAgICAgICA6IDE2ID09PSBhLmxlbmd0aFxuICAgICAgICAgID8gcGFyc2VGbG9hdChhWzEzXSlcbiAgICAgICAgICA6IHBhcnNlRmxvYXQoYVs1XSkpLFxuICAgICAgaSB8fCAwXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBDKGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJlxuICAgICAgbnVsbCAhPT0gZSAmJlxuICAgICAgZS5jb25zdHJ1Y3RvciAmJlxuICAgICAgZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBTKCkge1xuICAgIGZvciAoXG4gICAgICB2YXIgZSA9IE9iamVjdChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0pLCB0ID0gMTtcbiAgICAgIHQgPCBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdCArPSAxXG4gICAgKSB7XG4gICAgICB2YXIgYSA9IHQgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gdCA/IHZvaWQgMCA6IGFyZ3VtZW50c1t0XTtcbiAgICAgIGlmIChudWxsICE9IGEpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGkgPSBPYmplY3Qua2V5cyhPYmplY3QoYSkpLCBzID0gMCwgciA9IGkubGVuZ3RoO1xuICAgICAgICAgIHMgPCByO1xuICAgICAgICAgIHMgKz0gMVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgbiA9IGlbc10sXG4gICAgICAgICAgICBsID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLCBuKTtcbiAgICAgICAgICB2b2lkIDAgIT09IGwgJiZcbiAgICAgICAgICAgIGwuZW51bWVyYWJsZSAmJlxuICAgICAgICAgICAgKEMoZVtuXSkgJiYgQyhhW25dKVxuICAgICAgICAgICAgICA/IFMoZVtuXSwgYVtuXSlcbiAgICAgICAgICAgICAgOiAhQyhlW25dKSAmJiBDKGFbbl0pXG4gICAgICAgICAgICAgID8gKChlW25dID0ge30pLCBTKGVbbl0sIGFbbl0pKVxuICAgICAgICAgICAgICA6IChlW25dID0gYVtuXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIGZ1bmN0aW9uIE0oZSwgdCkge1xuICAgIE9iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgIEModFthXSkgJiZcbiAgICAgICAgT2JqZWN0LmtleXModFthXSkuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdFthXVtpXSAmJiAodFthXVtpXSA9IHRbYV1baV0uYmluZChlKSk7XG4gICAgICAgIH0pLFxuICAgICAgICAoZVthXSA9IHRbYV0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHooKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGcgfHxcbiAgICAgICAgKGcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlID0gbCgpLFxuICAgICAgICAgICAgdCA9IHIoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG91Y2g6ICEhKFxuICAgICAgICAgICAgICBcIm9udG91Y2hzdGFydFwiIGluIGUgfHxcbiAgICAgICAgICAgICAgKGUuRG9jdW1lbnRUb3VjaCAmJiB0IGluc3RhbmNlb2YgZS5Eb2N1bWVudFRvdWNoKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6XG4gICAgICAgICAgICAgICEhZS5Qb2ludGVyRXZlbnQgJiZcbiAgICAgICAgICAgICAgXCJtYXhUb3VjaFBvaW50c1wiIGluIGUubmF2aWdhdG9yICYmXG4gICAgICAgICAgICAgIGUubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID49IDAsXG4gICAgICAgICAgICBvYnNlcnZlcjogXCJNdXRhdGlvbk9ic2VydmVyXCIgaW4gZSB8fCBcIldlYmtpdE11dGF0aW9uT2JzZXJ2ZXJcIiBpbiBlLFxuICAgICAgICAgICAgcGFzc2l2ZUxpc3RlbmVyOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdCA9ICExO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInBhc3NpdmVcIiwge1xuICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSAhMDtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZS5hZGRFdmVudExpc3RlbmVyKFwidGVzdFBhc3NpdmVMaXN0ZW5lclwiLCBudWxsLCBhKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICB9KSgpLFxuICAgICAgICAgICAgZ2VzdHVyZXM6IFwib25nZXN0dXJlc3RhcnRcIiBpbiBlLFxuICAgICAgICAgIH07XG4gICAgICAgIH0pKCkpLFxuICAgICAgZ1xuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gUChlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IHt9KSxcbiAgICAgIHkgfHxcbiAgICAgICAgKHkgPSAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgdCA9ICh2b2lkIDAgPT09IGUgPyB7fSA6IGUpLnVzZXJBZ2VudCxcbiAgICAgICAgICAgIGEgPSB6KCksXG4gICAgICAgICAgICBpID0gbCgpLFxuICAgICAgICAgICAgcyA9IGkubmF2aWdhdG9yLnBsYXRmb3JtLFxuICAgICAgICAgICAgciA9IHQgfHwgaS5uYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICAgICAgbiA9IHsgaW9zOiAhMSwgYW5kcm9pZDogITEgfSxcbiAgICAgICAgICAgIG8gPSBpLnNjcmVlbi53aWR0aCxcbiAgICAgICAgICAgIGQgPSBpLnNjcmVlbi5oZWlnaHQsXG4gICAgICAgICAgICBwID0gci5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/LyksXG4gICAgICAgICAgICB1ID0gci5tYXRjaCgvKGlQYWQpLipPU1xccyhbXFxkX10rKS8pLFxuICAgICAgICAgICAgYyA9IHIubWF0Y2goLyhpUG9kKSguKk9TXFxzKFtcXGRfXSspKT8vKSxcbiAgICAgICAgICAgIGggPSAhdSAmJiByLm1hdGNoKC8oaVBob25lXFxzT1N8aU9TKVxccyhbXFxkX10rKS8pLFxuICAgICAgICAgICAgdiA9IFwiV2luMzJcIiA9PT0gcyxcbiAgICAgICAgICAgIGYgPSBcIk1hY0ludGVsXCIgPT09IHM7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICF1ICYmXG4gICAgICAgICAgICAgIGYgJiZcbiAgICAgICAgICAgICAgYS50b3VjaCAmJlxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCIxMDI0eDEzNjZcIixcbiAgICAgICAgICAgICAgICBcIjEzNjZ4MTAyNFwiLFxuICAgICAgICAgICAgICAgIFwiODM0eDExOTRcIixcbiAgICAgICAgICAgICAgICBcIjExOTR4ODM0XCIsXG4gICAgICAgICAgICAgICAgXCI4MzR4MTExMlwiLFxuICAgICAgICAgICAgICAgIFwiMTExMng4MzRcIixcbiAgICAgICAgICAgICAgICBcIjc2OHgxMDI0XCIsXG4gICAgICAgICAgICAgICAgXCIxMDI0eDc2OFwiLFxuICAgICAgICAgICAgICAgIFwiODIweDExODBcIixcbiAgICAgICAgICAgICAgICBcIjExODB4ODIwXCIsXG4gICAgICAgICAgICAgICAgXCI4MTB4MTA4MFwiLFxuICAgICAgICAgICAgICAgIFwiMTA4MHg4MTBcIixcbiAgICAgICAgICAgICAgXS5pbmRleE9mKG8gKyBcInhcIiArIGQpID49IDAgJiZcbiAgICAgICAgICAgICAgKCh1ID0gci5tYXRjaCgvKFZlcnNpb24pXFwvKFtcXGQuXSspLykpIHx8ICh1ID0gWzAsIDEsIFwiMTNfMF8wXCJdKSxcbiAgICAgICAgICAgICAgKGYgPSAhMSkpLFxuICAgICAgICAgICAgcCAmJiAhdiAmJiAoKG4ub3MgPSBcImFuZHJvaWRcIiksIChuLmFuZHJvaWQgPSAhMCkpLFxuICAgICAgICAgICAgKHUgfHwgaCB8fCBjKSAmJiAoKG4ub3MgPSBcImlvc1wiKSwgKG4uaW9zID0gITApKSxcbiAgICAgICAgICAgIG5cbiAgICAgICAgICApO1xuICAgICAgICB9KShlKSksXG4gICAgICB5XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBrKCkge1xuICAgIHJldHVybiAoXG4gICAgICB3IHx8XG4gICAgICAgICh3ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZSxcbiAgICAgICAgICAgIHQgPSBsKCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzRWRnZTogISF0Lm5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0VkZ2UvZyksXG4gICAgICAgICAgICBpc1NhZmFyaTpcbiAgICAgICAgICAgICAgKChlID0gdC5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpLFxuICAgICAgICAgICAgICBlLmluZGV4T2YoXCJzYWZhcmlcIikgPj0gMCAmJlxuICAgICAgICAgICAgICAgIGUuaW5kZXhPZihcImNocm9tZVwiKSA8IDAgJiZcbiAgICAgICAgICAgICAgICBlLmluZGV4T2YoXCJhbmRyb2lkXCIpIDwgMCksXG4gICAgICAgICAgICBpc1dlYlZpZXc6IC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpL2kudGVzdChcbiAgICAgICAgICAgICAgdC5uYXZpZ2F0b3IudXNlckFnZW50XG4gICAgICAgICAgICApLFxuICAgICAgICAgIH07XG4gICAgICAgIH0pKCkpLFxuICAgICAgd1xuICAgICk7XG4gIH1cbiAgT2JqZWN0LmtleXMoYikuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgIG0uZm5bZV0gPSBiW2VdO1xuICB9KTtcbiAgdmFyIEwgPSB7XG4gICAgICBuYW1lOiBcInJlc2l6ZVwiLFxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgUyhlLCB7XG4gICAgICAgICAgcmVzaXplOiB7XG4gICAgICAgICAgICByZXNpemVIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGUgJiZcbiAgICAgICAgICAgICAgICAhZS5kZXN0cm95ZWQgJiZcbiAgICAgICAgICAgICAgICBlLmluaXRpYWxpemVkICYmXG4gICAgICAgICAgICAgICAgKGUuZW1pdChcImJlZm9yZVJlc2l6ZVwiKSwgZS5lbWl0KFwicmVzaXplXCIpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcmllbnRhdGlvbkNoYW5nZUhhbmRsZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZSAmJiAhZS5kZXN0cm95ZWQgJiYgZS5pbml0aWFsaXplZCAmJiBlLmVtaXQoXCJvcmllbnRhdGlvbmNoYW5nZVwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgdCA9IGwoKTtcbiAgICAgICAgICB0LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZS5yZXNpemUucmVzaXplSGFuZGxlciksXG4gICAgICAgICAgICB0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgIFwib3JpZW50YXRpb25jaGFuZ2VcIixcbiAgICAgICAgICAgICAgZS5yZXNpemUub3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciB0ID0gbCgpO1xuICAgICAgICAgIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBlLnJlc2l6ZS5yZXNpemVIYW5kbGVyKSxcbiAgICAgICAgICAgIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgXCJvcmllbnRhdGlvbmNoYW5nZVwiLFxuICAgICAgICAgICAgICBlLnJlc2l6ZS5vcmllbnRhdGlvbkNoYW5nZUhhbmRsZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgJCA9IHtcbiAgICAgIGF0dGFjaDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgdm9pZCAwID09PSB0ICYmICh0ID0ge30pO1xuICAgICAgICB2YXIgYSA9IGwoKSxcbiAgICAgICAgICBpID0gdGhpcyxcbiAgICAgICAgICBzID0gbmV3IChhLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYS5XZWJraXRNdXRhdGlvbk9ic2VydmVyKShmdW5jdGlvbiAoXG4gICAgICAgICAgICBlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoMSAhPT0gZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaS5lbWl0KFwib2JzZXJ2ZXJVcGRhdGVcIiwgZVswXSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGEucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgPyBhLnJlcXVlc3RBbmltYXRpb25GcmFtZSh0KVxuICAgICAgICAgICAgICAgIDogYS5zZXRUaW1lb3V0KHQsIDApO1xuICAgICAgICAgICAgfSBlbHNlIGkuZW1pdChcIm9ic2VydmVyVXBkYXRlXCIsIGVbMF0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICBzLm9ic2VydmUoZSwge1xuICAgICAgICAgIGF0dHJpYnV0ZXM6IHZvaWQgMCA9PT0gdC5hdHRyaWJ1dGVzIHx8IHQuYXR0cmlidXRlcyxcbiAgICAgICAgICBjaGlsZExpc3Q6IHZvaWQgMCA9PT0gdC5jaGlsZExpc3QgfHwgdC5jaGlsZExpc3QsXG4gICAgICAgICAgY2hhcmFjdGVyRGF0YTogdm9pZCAwID09PSB0LmNoYXJhY3RlckRhdGEgfHwgdC5jaGFyYWN0ZXJEYXRhLFxuICAgICAgICB9KSxcbiAgICAgICAgICBpLm9ic2VydmVyLm9ic2VydmVycy5wdXNoKHMpO1xuICAgICAgfSxcbiAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICBpZiAoZS5zdXBwb3J0Lm9ic2VydmVyICYmIGUucGFyYW1zLm9ic2VydmVyKSB7XG4gICAgICAgICAgaWYgKGUucGFyYW1zLm9ic2VydmVQYXJlbnRzKVxuICAgICAgICAgICAgZm9yICh2YXIgdCA9IGUuJGVsLnBhcmVudHMoKSwgYSA9IDA7IGEgPCB0Lmxlbmd0aDsgYSArPSAxKVxuICAgICAgICAgICAgICBlLm9ic2VydmVyLmF0dGFjaCh0W2FdKTtcbiAgICAgICAgICBlLm9ic2VydmVyLmF0dGFjaChlLiRlbFswXSwge1xuICAgICAgICAgICAgY2hpbGRMaXN0OiBlLnBhcmFtcy5vYnNlcnZlU2xpZGVDaGlsZHJlbixcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGUub2JzZXJ2ZXIuYXR0YWNoKGUuJHdyYXBwZXJFbFswXSwgeyBhdHRyaWJ1dGVzOiAhMSB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KSxcbiAgICAgICAgICAodGhpcy5vYnNlcnZlci5vYnNlcnZlcnMgPSBbXSk7XG4gICAgICB9LFxuICAgIH0sXG4gICAgSSA9IHtcbiAgICAgIG5hbWU6IFwib2JzZXJ2ZXJcIixcbiAgICAgIHBhcmFtczogeyBvYnNlcnZlcjogITEsIG9ic2VydmVQYXJlbnRzOiAhMSwgb2JzZXJ2ZVNsaWRlQ2hpbGRyZW46ICExIH0sXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgTSh0aGlzLCB7IG9ic2VydmVyOiB0KHt9LCAkLCB7IG9ic2VydmVyczogW10gfSkgfSk7XG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLm9ic2VydmVyLmluaXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLm9ic2VydmVyLmRlc3Ryb3koKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcbiAgZnVuY3Rpb24gTyhlKSB7XG4gICAgdmFyIHQgPSB0aGlzLFxuICAgICAgYSA9IHIoKSxcbiAgICAgIGkgPSBsKCksXG4gICAgICBzID0gdC50b3VjaEV2ZW50c0RhdGEsXG4gICAgICBuID0gdC5wYXJhbXMsXG4gICAgICBvID0gdC50b3VjaGVzO1xuICAgIGlmICghdC5hbmltYXRpbmcgfHwgIW4ucHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uKSB7XG4gICAgICB2YXIgZCA9IGU7XG4gICAgICBkLm9yaWdpbmFsRXZlbnQgJiYgKGQgPSBkLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgdmFyIHAgPSBtKGQudGFyZ2V0KTtcbiAgICAgIGlmIChcIndyYXBwZXJcIiAhPT0gbi50b3VjaEV2ZW50c1RhcmdldCB8fCBwLmNsb3Nlc3QodC53cmFwcGVyRWwpLmxlbmd0aClcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgocy5pc1RvdWNoRXZlbnQgPSBcInRvdWNoc3RhcnRcIiA9PT0gZC50eXBlKSxcbiAgICAgICAgICBzLmlzVG91Y2hFdmVudCB8fCAhKFwid2hpY2hcIiBpbiBkKSB8fCAzICE9PSBkLndoaWNoKVxuICAgICAgICApXG4gICAgICAgICAgaWYgKCEoIXMuaXNUb3VjaEV2ZW50ICYmIFwiYnV0dG9uXCIgaW4gZCAmJiBkLmJ1dHRvbiA+IDApKVxuICAgICAgICAgICAgaWYgKCFzLmlzVG91Y2hlZCB8fCAhcy5pc01vdmVkKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKCEhbi5ub1N3aXBpbmdDbGFzcyAmJlxuICAgICAgICAgICAgICAgICAgXCJcIiAhPT0gbi5ub1N3aXBpbmdDbGFzcyAmJlxuICAgICAgICAgICAgICAgICAgZC50YXJnZXQgJiZcbiAgICAgICAgICAgICAgICAgIGQudGFyZ2V0LnNoYWRvd1Jvb3QgJiZcbiAgICAgICAgICAgICAgICAgIGUucGF0aCAmJlxuICAgICAgICAgICAgICAgICAgZS5wYXRoWzBdICYmXG4gICAgICAgICAgICAgICAgICAocCA9IG0oZS5wYXRoWzBdKSksXG4gICAgICAgICAgICAgICAgbi5ub1N3aXBpbmcgJiZcbiAgICAgICAgICAgICAgICAgIHAuY2xvc2VzdChcbiAgICAgICAgICAgICAgICAgICAgbi5ub1N3aXBpbmdTZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgID8gbi5ub1N3aXBpbmdTZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgIDogXCIuXCIgKyBuLm5vU3dpcGluZ0NsYXNzXG4gICAgICAgICAgICAgICAgICApWzBdKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdC5hbGxvd0NsaWNrID0gITA7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKCFuLnN3aXBlSGFuZGxlciB8fCBwLmNsb3Nlc3Qobi5zd2lwZUhhbmRsZXIpWzBdKSB7XG4gICAgICAgICAgICAgICAgKG8uY3VycmVudFggPVxuICAgICAgICAgICAgICAgICAgXCJ0b3VjaHN0YXJ0XCIgPT09IGQudHlwZSA/IGQudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGQucGFnZVgpLFxuICAgICAgICAgICAgICAgICAgKG8uY3VycmVudFkgPVxuICAgICAgICAgICAgICAgICAgICBcInRvdWNoc3RhcnRcIiA9PT0gZC50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgPyBkLnRhcmdldFRvdWNoZXNbMF0ucGFnZVlcbiAgICAgICAgICAgICAgICAgICAgICA6IGQucGFnZVkpO1xuICAgICAgICAgICAgICAgIHZhciB1ID0gby5jdXJyZW50WCxcbiAgICAgICAgICAgICAgICAgIGMgPSBvLmN1cnJlbnRZLFxuICAgICAgICAgICAgICAgICAgaCA9IG4uZWRnZVN3aXBlRGV0ZWN0aW9uIHx8IG4uaU9TRWRnZVN3aXBlRGV0ZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgdiA9IG4uZWRnZVN3aXBlVGhyZXNob2xkIHx8IG4uaU9TRWRnZVN3aXBlVGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIGlmICghaCB8fCAhKHUgPD0gdiB8fCB1ID49IGkuaW5uZXJXaWR0aCAtIHYpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChTKHMsIHtcbiAgICAgICAgICAgICAgICAgICAgICBpc1RvdWNoZWQ6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgIGlzTW92ZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgIGFsbG93VG91Y2hDYWxsYmFja3M6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgIGlzU2Nyb2xsaW5nOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnRNb3Zpbmc6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIChvLnN0YXJ0WCA9IHUpLFxuICAgICAgICAgICAgICAgICAgICAoby5zdGFydFkgPSBjKSxcbiAgICAgICAgICAgICAgICAgICAgKHMudG91Y2hTdGFydFRpbWUgPSB4KCkpLFxuICAgICAgICAgICAgICAgICAgICAodC5hbGxvd0NsaWNrID0gITApLFxuICAgICAgICAgICAgICAgICAgICB0LnVwZGF0ZVNpemUoKSxcbiAgICAgICAgICAgICAgICAgICAgKHQuc3dpcGVEaXJlY3Rpb24gPSB2b2lkIDApLFxuICAgICAgICAgICAgICAgICAgICBuLnRocmVzaG9sZCA+IDAgJiYgKHMuYWxsb3dUaHJlc2hvbGRNb3ZlID0gITEpLFxuICAgICAgICAgICAgICAgICAgICBcInRvdWNoc3RhcnRcIiAhPT0gZC50eXBlKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gITA7XG4gICAgICAgICAgICAgICAgICAgIHAuaXMocy5mb3JtRWxlbWVudHMpICYmIChmID0gITEpLFxuICAgICAgICAgICAgICAgICAgICAgIGEuYWN0aXZlRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbShhLmFjdGl2ZUVsZW1lbnQpLmlzKHMuZm9ybUVsZW1lbnRzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYS5hY3RpdmVFbGVtZW50ICE9PSBwWzBdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhLmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IGYgJiYgdC5hbGxvd1RvdWNoTW92ZSAmJiBuLnRvdWNoU3RhcnRQcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgKCFuLnRvdWNoU3RhcnRGb3JjZVByZXZlbnREZWZhdWx0ICYmICFnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIHBbMF0uaXNDb250ZW50RWRpdGFibGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICBkLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0LmVtaXQoXCJ0b3VjaFN0YXJ0XCIsIGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBBKGUpIHtcbiAgICB2YXIgdCA9IHIoKSxcbiAgICAgIGEgPSB0aGlzLFxuICAgICAgaSA9IGEudG91Y2hFdmVudHNEYXRhLFxuICAgICAgcyA9IGEucGFyYW1zLFxuICAgICAgbiA9IGEudG91Y2hlcyxcbiAgICAgIGwgPSBhLnJ0bFRyYW5zbGF0ZSxcbiAgICAgIG8gPSBlO1xuICAgIGlmICgoby5vcmlnaW5hbEV2ZW50ICYmIChvID0gby5vcmlnaW5hbEV2ZW50KSwgaS5pc1RvdWNoZWQpKSB7XG4gICAgICBpZiAoIWkuaXNUb3VjaEV2ZW50IHx8IFwidG91Y2htb3ZlXCIgPT09IG8udHlwZSkge1xuICAgICAgICB2YXIgZCA9XG4gICAgICAgICAgICBcInRvdWNobW92ZVwiID09PSBvLnR5cGUgJiZcbiAgICAgICAgICAgIG8udGFyZ2V0VG91Y2hlcyAmJlxuICAgICAgICAgICAgKG8udGFyZ2V0VG91Y2hlc1swXSB8fCBvLmNoYW5nZWRUb3VjaGVzWzBdKSxcbiAgICAgICAgICBwID0gXCJ0b3VjaG1vdmVcIiA9PT0gby50eXBlID8gZC5wYWdlWCA6IG8ucGFnZVgsXG4gICAgICAgICAgdSA9IFwidG91Y2htb3ZlXCIgPT09IG8udHlwZSA/IGQucGFnZVkgOiBvLnBhZ2VZO1xuICAgICAgICBpZiAoby5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlcilcbiAgICAgICAgICByZXR1cm4gKG4uc3RhcnRYID0gcCksIHZvaWQgKG4uc3RhcnRZID0gdSk7XG4gICAgICAgIGlmICghYS5hbGxvd1RvdWNoTW92ZSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGEuYWxsb3dDbGljayA9ICExKSxcbiAgICAgICAgICAgIHZvaWQgKFxuICAgICAgICAgICAgICBpLmlzVG91Y2hlZCAmJlxuICAgICAgICAgICAgICAoUyhuLCB7IHN0YXJ0WDogcCwgc3RhcnRZOiB1LCBjdXJyZW50WDogcCwgY3VycmVudFk6IHUgfSksXG4gICAgICAgICAgICAgIChpLnRvdWNoU3RhcnRUaW1lID0geCgpKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoaS5pc1RvdWNoRXZlbnQgJiYgcy50b3VjaFJlbGVhc2VPbkVkZ2VzICYmICFzLmxvb3ApXG4gICAgICAgICAgaWYgKGEuaXNWZXJ0aWNhbCgpKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICh1IDwgbi5zdGFydFkgJiYgYS50cmFuc2xhdGUgPD0gYS5tYXhUcmFuc2xhdGUoKSkgfHxcbiAgICAgICAgICAgICAgKHUgPiBuLnN0YXJ0WSAmJiBhLnRyYW5zbGF0ZSA+PSBhLm1pblRyYW5zbGF0ZSgpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm4gKGkuaXNUb3VjaGVkID0gITEpLCB2b2lkIChpLmlzTW92ZWQgPSAhMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIChwIDwgbi5zdGFydFggJiYgYS50cmFuc2xhdGUgPD0gYS5tYXhUcmFuc2xhdGUoKSkgfHxcbiAgICAgICAgICAgIChwID4gbi5zdGFydFggJiYgYS50cmFuc2xhdGUgPj0gYS5taW5UcmFuc2xhdGUoKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChcbiAgICAgICAgICBpLmlzVG91Y2hFdmVudCAmJlxuICAgICAgICAgIHQuYWN0aXZlRWxlbWVudCAmJlxuICAgICAgICAgIG8udGFyZ2V0ID09PSB0LmFjdGl2ZUVsZW1lbnQgJiZcbiAgICAgICAgICBtKG8udGFyZ2V0KS5pcyhpLmZvcm1FbGVtZW50cylcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoaS5pc01vdmVkID0gITApLCB2b2lkIChhLmFsbG93Q2xpY2sgPSAhMSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoaS5hbGxvd1RvdWNoQ2FsbGJhY2tzICYmIGEuZW1pdChcInRvdWNoTW92ZVwiLCBvKSxcbiAgICAgICAgICAhKG8udGFyZ2V0VG91Y2hlcyAmJiBvLnRhcmdldFRvdWNoZXMubGVuZ3RoID4gMSkpXG4gICAgICAgICkge1xuICAgICAgICAgIChuLmN1cnJlbnRYID0gcCksIChuLmN1cnJlbnRZID0gdSk7XG4gICAgICAgICAgdmFyIGMgPSBuLmN1cnJlbnRYIC0gbi5zdGFydFgsXG4gICAgICAgICAgICBoID0gbi5jdXJyZW50WSAtIG4uc3RhcnRZO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgIGEucGFyYW1zLnRocmVzaG9sZCAmJlxuICAgICAgICAgICAgICBNYXRoLnNxcnQoTWF0aC5wb3coYywgMikgKyBNYXRoLnBvdyhoLCAyKSkgPCBhLnBhcmFtcy50aHJlc2hvbGRcbiAgICAgICAgICAgIClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciB2O1xuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gaS5pc1Njcm9sbGluZylcbiAgICAgICAgICAgICAgKGEuaXNIb3Jpem9udGFsKCkgJiYgbi5jdXJyZW50WSA9PT0gbi5zdGFydFkpIHx8XG4gICAgICAgICAgICAgIChhLmlzVmVydGljYWwoKSAmJiBuLmN1cnJlbnRYID09PSBuLnN0YXJ0WClcbiAgICAgICAgICAgICAgICA/IChpLmlzU2Nyb2xsaW5nID0gITEpXG4gICAgICAgICAgICAgICAgOiBjICogYyArIGggKiBoID49IDI1ICYmXG4gICAgICAgICAgICAgICAgICAoKHYgPSAoMTgwICogTWF0aC5hdGFuMihNYXRoLmFicyhoKSwgTWF0aC5hYnMoYykpKSAvIE1hdGguUEkpLFxuICAgICAgICAgICAgICAgICAgKGkuaXNTY3JvbGxpbmcgPSBhLmlzSG9yaXpvbnRhbCgpXG4gICAgICAgICAgICAgICAgICAgID8gdiA+IHMudG91Y2hBbmdsZVxuICAgICAgICAgICAgICAgICAgICA6IDkwIC0gdiA+IHMudG91Y2hBbmdsZSkpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoaS5pc1Njcm9sbGluZyAmJiBhLmVtaXQoXCJ0b3VjaE1vdmVPcHBvc2l0ZVwiLCBvKSxcbiAgICAgICAgICAgICAgdm9pZCAwID09PSBpLnN0YXJ0TW92aW5nICYmXG4gICAgICAgICAgICAgICAgKChuLmN1cnJlbnRYID09PSBuLnN0YXJ0WCAmJiBuLmN1cnJlbnRZID09PSBuLnN0YXJ0WSkgfHxcbiAgICAgICAgICAgICAgICAgIChpLnN0YXJ0TW92aW5nID0gITApKSxcbiAgICAgICAgICAgICAgaS5pc1Njcm9sbGluZylcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgaS5pc1RvdWNoZWQgPSAhMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGkuc3RhcnRNb3ZpbmcpIHtcbiAgICAgICAgICAgICAgKGEuYWxsb3dDbGljayA9ICExKSxcbiAgICAgICAgICAgICAgICAhcy5jc3NNb2RlICYmIG8uY2FuY2VsYWJsZSAmJiBvLnByZXZlbnREZWZhdWx0KCksXG4gICAgICAgICAgICAgICAgcy50b3VjaE1vdmVTdG9wUHJvcGFnYXRpb24gJiYgIXMubmVzdGVkICYmIG8uc3RvcFByb3BhZ2F0aW9uKCksXG4gICAgICAgICAgICAgICAgaS5pc01vdmVkIHx8XG4gICAgICAgICAgICAgICAgICAocy5sb29wICYmIGEubG9vcEZpeCgpLFxuICAgICAgICAgICAgICAgICAgKGkuc3RhcnRUcmFuc2xhdGUgPSBhLmdldFRyYW5zbGF0ZSgpKSxcbiAgICAgICAgICAgICAgICAgIGEuc2V0VHJhbnNpdGlvbigwKSxcbiAgICAgICAgICAgICAgICAgIGEuYW5pbWF0aW5nICYmXG4gICAgICAgICAgICAgICAgICAgIGEuJHdyYXBwZXJFbC50cmlnZ2VyKFwid2Via2l0VHJhbnNpdGlvbkVuZCB0cmFuc2l0aW9uZW5kXCIpLFxuICAgICAgICAgICAgICAgICAgKGkuYWxsb3dNb21lbnR1bUJvdW5jZSA9ICExKSxcbiAgICAgICAgICAgICAgICAgICFzLmdyYWJDdXJzb3IgfHxcbiAgICAgICAgICAgICAgICAgICAgKCEwICE9PSBhLmFsbG93U2xpZGVOZXh0ICYmICEwICE9PSBhLmFsbG93U2xpZGVQcmV2KSB8fFxuICAgICAgICAgICAgICAgICAgICBhLnNldEdyYWJDdXJzb3IoITApLFxuICAgICAgICAgICAgICAgICAgYS5lbWl0KFwic2xpZGVyRmlyc3RNb3ZlXCIsIG8pKSxcbiAgICAgICAgICAgICAgICBhLmVtaXQoXCJzbGlkZXJNb3ZlXCIsIG8pLFxuICAgICAgICAgICAgICAgIChpLmlzTW92ZWQgPSAhMCk7XG4gICAgICAgICAgICAgIHZhciBmID0gYS5pc0hvcml6b250YWwoKSA/IGMgOiBoO1xuICAgICAgICAgICAgICAobi5kaWZmID0gZiksXG4gICAgICAgICAgICAgICAgKGYgKj0gcy50b3VjaFJhdGlvKSxcbiAgICAgICAgICAgICAgICBsICYmIChmID0gLWYpLFxuICAgICAgICAgICAgICAgIChhLnN3aXBlRGlyZWN0aW9uID0gZiA+IDAgPyBcInByZXZcIiA6IFwibmV4dFwiKSxcbiAgICAgICAgICAgICAgICAoaS5jdXJyZW50VHJhbnNsYXRlID0gZiArIGkuc3RhcnRUcmFuc2xhdGUpO1xuICAgICAgICAgICAgICB2YXIgZyA9ICEwLFxuICAgICAgICAgICAgICAgIHkgPSBzLnJlc2lzdGFuY2VSYXRpbztcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChzLnRvdWNoUmVsZWFzZU9uRWRnZXMgJiYgKHkgPSAwKSxcbiAgICAgICAgICAgICAgICBmID4gMCAmJiBpLmN1cnJlbnRUcmFuc2xhdGUgPiBhLm1pblRyYW5zbGF0ZSgpXG4gICAgICAgICAgICAgICAgICA/ICgoZyA9ICExKSxcbiAgICAgICAgICAgICAgICAgICAgcy5yZXNpc3RhbmNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgKGkuY3VycmVudFRyYW5zbGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBhLm1pblRyYW5zbGF0ZSgpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3coLWEubWluVHJhbnNsYXRlKCkgKyBpLnN0YXJ0VHJhbnNsYXRlICsgZiwgeSkpKVxuICAgICAgICAgICAgICAgICAgOiBmIDwgMCAmJlxuICAgICAgICAgICAgICAgICAgICBpLmN1cnJlbnRUcmFuc2xhdGUgPCBhLm1heFRyYW5zbGF0ZSgpICYmXG4gICAgICAgICAgICAgICAgICAgICgoZyA9ICExKSxcbiAgICAgICAgICAgICAgICAgICAgcy5yZXNpc3RhbmNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgKGkuY3VycmVudFRyYW5zbGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBhLm1heFRyYW5zbGF0ZSgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDEgLVxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3coYS5tYXhUcmFuc2xhdGUoKSAtIGkuc3RhcnRUcmFuc2xhdGUgLSBmLCB5KSkpLFxuICAgICAgICAgICAgICAgIGcgJiYgKG8ucHJldmVudGVkQnlOZXN0ZWRTd2lwZXIgPSAhMCksXG4gICAgICAgICAgICAgICAgIWEuYWxsb3dTbGlkZU5leHQgJiZcbiAgICAgICAgICAgICAgICAgIFwibmV4dFwiID09PSBhLnN3aXBlRGlyZWN0aW9uICYmXG4gICAgICAgICAgICAgICAgICBpLmN1cnJlbnRUcmFuc2xhdGUgPCBpLnN0YXJ0VHJhbnNsYXRlICYmXG4gICAgICAgICAgICAgICAgICAoaS5jdXJyZW50VHJhbnNsYXRlID0gaS5zdGFydFRyYW5zbGF0ZSksXG4gICAgICAgICAgICAgICAgIWEuYWxsb3dTbGlkZVByZXYgJiZcbiAgICAgICAgICAgICAgICAgIFwicHJldlwiID09PSBhLnN3aXBlRGlyZWN0aW9uICYmXG4gICAgICAgICAgICAgICAgICBpLmN1cnJlbnRUcmFuc2xhdGUgPiBpLnN0YXJ0VHJhbnNsYXRlICYmXG4gICAgICAgICAgICAgICAgICAoaS5jdXJyZW50VHJhbnNsYXRlID0gaS5zdGFydFRyYW5zbGF0ZSksXG4gICAgICAgICAgICAgICAgcy50aHJlc2hvbGQgPiAwKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoIShNYXRoLmFicyhmKSA+IHMudGhyZXNob2xkIHx8IGkuYWxsb3dUaHJlc2hvbGRNb3ZlKSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIChpLmN1cnJlbnRUcmFuc2xhdGUgPSBpLnN0YXJ0VHJhbnNsYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWkuYWxsb3dUaHJlc2hvbGRNb3ZlKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgKGkuYWxsb3dUaHJlc2hvbGRNb3ZlID0gITApLFxuICAgICAgICAgICAgICAgICAgICAobi5zdGFydFggPSBuLmN1cnJlbnRYKSxcbiAgICAgICAgICAgICAgICAgICAgKG4uc3RhcnRZID0gbi5jdXJyZW50WSksXG4gICAgICAgICAgICAgICAgICAgIChpLmN1cnJlbnRUcmFuc2xhdGUgPSBpLnN0YXJ0VHJhbnNsYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAobi5kaWZmID0gYS5pc0hvcml6b250YWwoKVxuICAgICAgICAgICAgICAgICAgICAgID8gbi5jdXJyZW50WCAtIG4uc3RhcnRYXG4gICAgICAgICAgICAgICAgICAgICAgOiBuLmN1cnJlbnRZIC0gbi5zdGFydFkpXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHMuZm9sbG93RmluZ2VyICYmXG4gICAgICAgICAgICAgICAgIXMuY3NzTW9kZSAmJlxuICAgICAgICAgICAgICAgICgocy5mcmVlTW9kZSB8fFxuICAgICAgICAgICAgICAgICAgcy53YXRjaFNsaWRlc1Byb2dyZXNzIHx8XG4gICAgICAgICAgICAgICAgICBzLndhdGNoU2xpZGVzVmlzaWJpbGl0eSkgJiZcbiAgICAgICAgICAgICAgICAgIChhLnVwZGF0ZUFjdGl2ZUluZGV4KCksIGEudXBkYXRlU2xpZGVzQ2xhc3NlcygpKSxcbiAgICAgICAgICAgICAgICBzLmZyZWVNb2RlICYmXG4gICAgICAgICAgICAgICAgICAoMCA9PT0gaS52ZWxvY2l0aWVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBpLnZlbG9jaXRpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5bYS5pc0hvcml6b250YWwoKSA/IFwic3RhcnRYXCIgOiBcInN0YXJ0WVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBpLnRvdWNoU3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIGkudmVsb2NpdGllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5bYS5pc0hvcml6b250YWwoKSA/IFwiY3VycmVudFhcIiA6IFwiY3VycmVudFlcIl0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IHgoKSxcbiAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICBhLnVwZGF0ZVByb2dyZXNzKGkuY3VycmVudFRyYW5zbGF0ZSksXG4gICAgICAgICAgICAgICAgYS5zZXRUcmFuc2xhdGUoaS5jdXJyZW50VHJhbnNsYXRlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGkuc3RhcnRNb3ZpbmcgJiYgaS5pc1Njcm9sbGluZyAmJiBhLmVtaXQoXCJ0b3VjaE1vdmVPcHBvc2l0ZVwiLCBvKTtcbiAgfVxuICBmdW5jdGlvbiBEKGUpIHtcbiAgICB2YXIgdCA9IHRoaXMsXG4gICAgICBhID0gdC50b3VjaEV2ZW50c0RhdGEsXG4gICAgICBpID0gdC5wYXJhbXMsXG4gICAgICBzID0gdC50b3VjaGVzLFxuICAgICAgciA9IHQucnRsVHJhbnNsYXRlLFxuICAgICAgbiA9IHQuJHdyYXBwZXJFbCxcbiAgICAgIGwgPSB0LnNsaWRlc0dyaWQsXG4gICAgICBvID0gdC5zbmFwR3JpZCxcbiAgICAgIGQgPSBlO1xuICAgIGlmIChcbiAgICAgIChkLm9yaWdpbmFsRXZlbnQgJiYgKGQgPSBkLm9yaWdpbmFsRXZlbnQpLFxuICAgICAgYS5hbGxvd1RvdWNoQ2FsbGJhY2tzICYmIHQuZW1pdChcInRvdWNoRW5kXCIsIGQpLFxuICAgICAgKGEuYWxsb3dUb3VjaENhbGxiYWNrcyA9ICExKSxcbiAgICAgICFhLmlzVG91Y2hlZClcbiAgICApXG4gICAgICByZXR1cm4gKFxuICAgICAgICBhLmlzTW92ZWQgJiYgaS5ncmFiQ3Vyc29yICYmIHQuc2V0R3JhYkN1cnNvcighMSksXG4gICAgICAgIChhLmlzTW92ZWQgPSAhMSksXG4gICAgICAgIHZvaWQgKGEuc3RhcnRNb3ZpbmcgPSAhMSlcbiAgICAgICk7XG4gICAgaS5ncmFiQ3Vyc29yICYmXG4gICAgICBhLmlzTW92ZWQgJiZcbiAgICAgIGEuaXNUb3VjaGVkICYmXG4gICAgICAoITAgPT09IHQuYWxsb3dTbGlkZU5leHQgfHwgITAgPT09IHQuYWxsb3dTbGlkZVByZXYpICYmXG4gICAgICB0LnNldEdyYWJDdXJzb3IoITEpO1xuICAgIHZhciBwLFxuICAgICAgdSA9IHgoKSxcbiAgICAgIGMgPSB1IC0gYS50b3VjaFN0YXJ0VGltZTtcbiAgICBpZiAoXG4gICAgICAodC5hbGxvd0NsaWNrICYmXG4gICAgICAgICh0LnVwZGF0ZUNsaWNrZWRTbGlkZShkKSxcbiAgICAgICAgdC5lbWl0KFwidGFwIGNsaWNrXCIsIGQpLFxuICAgICAgICBjIDwgMzAwICYmXG4gICAgICAgICAgdSAtIGEubGFzdENsaWNrVGltZSA8IDMwMCAmJlxuICAgICAgICAgIHQuZW1pdChcImRvdWJsZVRhcCBkb3VibGVDbGlja1wiLCBkKSksXG4gICAgICAoYS5sYXN0Q2xpY2tUaW1lID0geCgpKSxcbiAgICAgIEUoZnVuY3Rpb24gKCkge1xuICAgICAgICB0LmRlc3Ryb3llZCB8fCAodC5hbGxvd0NsaWNrID0gITApO1xuICAgICAgfSksXG4gICAgICAhYS5pc1RvdWNoZWQgfHxcbiAgICAgICAgIWEuaXNNb3ZlZCB8fFxuICAgICAgICAhdC5zd2lwZURpcmVjdGlvbiB8fFxuICAgICAgICAwID09PSBzLmRpZmYgfHxcbiAgICAgICAgYS5jdXJyZW50VHJhbnNsYXRlID09PSBhLnN0YXJ0VHJhbnNsYXRlKVxuICAgIClcbiAgICAgIHJldHVybiAoYS5pc1RvdWNoZWQgPSAhMSksIChhLmlzTW92ZWQgPSAhMSksIHZvaWQgKGEuc3RhcnRNb3ZpbmcgPSAhMSk7XG4gICAgaWYgKFxuICAgICAgKChhLmlzVG91Y2hlZCA9ICExKSxcbiAgICAgIChhLmlzTW92ZWQgPSAhMSksXG4gICAgICAoYS5zdGFydE1vdmluZyA9ICExKSxcbiAgICAgIChwID0gaS5mb2xsb3dGaW5nZXJcbiAgICAgICAgPyByXG4gICAgICAgICAgPyB0LnRyYW5zbGF0ZVxuICAgICAgICAgIDogLXQudHJhbnNsYXRlXG4gICAgICAgIDogLWEuY3VycmVudFRyYW5zbGF0ZSksXG4gICAgICAhaS5jc3NNb2RlKVxuICAgIClcbiAgICAgIGlmIChpLmZyZWVNb2RlKSB7XG4gICAgICAgIGlmIChwIDwgLXQubWluVHJhbnNsYXRlKCkpIHJldHVybiB2b2lkIHQuc2xpZGVUbyh0LmFjdGl2ZUluZGV4KTtcbiAgICAgICAgaWYgKHAgPiAtdC5tYXhUcmFuc2xhdGUoKSlcbiAgICAgICAgICByZXR1cm4gdm9pZCAodC5zbGlkZXMubGVuZ3RoIDwgby5sZW5ndGhcbiAgICAgICAgICAgID8gdC5zbGlkZVRvKG8ubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIDogdC5zbGlkZVRvKHQuc2xpZGVzLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgaWYgKGkuZnJlZU1vZGVNb21lbnR1bSkge1xuICAgICAgICAgIGlmIChhLnZlbG9jaXRpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIGggPSBhLnZlbG9jaXRpZXMucG9wKCksXG4gICAgICAgICAgICAgIHYgPSBhLnZlbG9jaXRpZXMucG9wKCksXG4gICAgICAgICAgICAgIGYgPSBoLnBvc2l0aW9uIC0gdi5wb3NpdGlvbixcbiAgICAgICAgICAgICAgbSA9IGgudGltZSAtIHYudGltZTtcbiAgICAgICAgICAgICh0LnZlbG9jaXR5ID0gZiAvIG0pLFxuICAgICAgICAgICAgICAodC52ZWxvY2l0eSAvPSAyKSxcbiAgICAgICAgICAgICAgTWF0aC5hYnModC52ZWxvY2l0eSkgPCBpLmZyZWVNb2RlTWluaW11bVZlbG9jaXR5ICYmXG4gICAgICAgICAgICAgICAgKHQudmVsb2NpdHkgPSAwKSxcbiAgICAgICAgICAgICAgKG0gPiAxNTAgfHwgeCgpIC0gaC50aW1lID4gMzAwKSAmJiAodC52ZWxvY2l0eSA9IDApO1xuICAgICAgICAgIH0gZWxzZSB0LnZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAodC52ZWxvY2l0eSAqPSBpLmZyZWVNb2RlTW9tZW50dW1WZWxvY2l0eVJhdGlvKSxcbiAgICAgICAgICAgIChhLnZlbG9jaXRpZXMubGVuZ3RoID0gMCk7XG4gICAgICAgICAgdmFyIGcgPSAxZTMgKiBpLmZyZWVNb2RlTW9tZW50dW1SYXRpbyxcbiAgICAgICAgICAgIHkgPSB0LnZlbG9jaXR5ICogZyxcbiAgICAgICAgICAgIHcgPSB0LnRyYW5zbGF0ZSArIHk7XG4gICAgICAgICAgciAmJiAodyA9IC13KTtcbiAgICAgICAgICB2YXIgYixcbiAgICAgICAgICAgIFQsXG4gICAgICAgICAgICBDID0gITEsXG4gICAgICAgICAgICBTID0gMjAgKiBNYXRoLmFicyh0LnZlbG9jaXR5KSAqIGkuZnJlZU1vZGVNb21lbnR1bUJvdW5jZVJhdGlvO1xuICAgICAgICAgIGlmICh3IDwgdC5tYXhUcmFuc2xhdGUoKSlcbiAgICAgICAgICAgIGkuZnJlZU1vZGVNb21lbnR1bUJvdW5jZVxuICAgICAgICAgICAgICA/ICh3ICsgdC5tYXhUcmFuc2xhdGUoKSA8IC1TICYmICh3ID0gdC5tYXhUcmFuc2xhdGUoKSAtIFMpLFxuICAgICAgICAgICAgICAgIChiID0gdC5tYXhUcmFuc2xhdGUoKSksXG4gICAgICAgICAgICAgICAgKEMgPSAhMCksXG4gICAgICAgICAgICAgICAgKGEuYWxsb3dNb21lbnR1bUJvdW5jZSA9ICEwKSlcbiAgICAgICAgICAgICAgOiAodyA9IHQubWF4VHJhbnNsYXRlKCkpLFxuICAgICAgICAgICAgICBpLmxvb3AgJiYgaS5jZW50ZXJlZFNsaWRlcyAmJiAoVCA9ICEwKTtcbiAgICAgICAgICBlbHNlIGlmICh3ID4gdC5taW5UcmFuc2xhdGUoKSlcbiAgICAgICAgICAgIGkuZnJlZU1vZGVNb21lbnR1bUJvdW5jZVxuICAgICAgICAgICAgICA/ICh3IC0gdC5taW5UcmFuc2xhdGUoKSA+IFMgJiYgKHcgPSB0Lm1pblRyYW5zbGF0ZSgpICsgUyksXG4gICAgICAgICAgICAgICAgKGIgPSB0Lm1pblRyYW5zbGF0ZSgpKSxcbiAgICAgICAgICAgICAgICAoQyA9ICEwKSxcbiAgICAgICAgICAgICAgICAoYS5hbGxvd01vbWVudHVtQm91bmNlID0gITApKVxuICAgICAgICAgICAgICA6ICh3ID0gdC5taW5UcmFuc2xhdGUoKSksXG4gICAgICAgICAgICAgIGkubG9vcCAmJiBpLmNlbnRlcmVkU2xpZGVzICYmIChUID0gITApO1xuICAgICAgICAgIGVsc2UgaWYgKGkuZnJlZU1vZGVTdGlja3kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIE0sIHogPSAwOyB6IDwgby5sZW5ndGg7IHogKz0gMSlcbiAgICAgICAgICAgICAgaWYgKG9bel0gPiAtdykge1xuICAgICAgICAgICAgICAgIE0gPSB6O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB3ID0gLSh3ID1cbiAgICAgICAgICAgICAgTWF0aC5hYnMob1tNXSAtIHcpIDwgTWF0aC5hYnMob1tNIC0gMV0gLSB3KSB8fFxuICAgICAgICAgICAgICBcIm5leHRcIiA9PT0gdC5zd2lwZURpcmVjdGlvblxuICAgICAgICAgICAgICAgID8gb1tNXVxuICAgICAgICAgICAgICAgIDogb1tNIC0gMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoVCAmJlxuICAgICAgICAgICAgICB0Lm9uY2UoXCJ0cmFuc2l0aW9uRW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0Lmxvb3BGaXgoKTtcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAwICE9PSB0LnZlbG9jaXR5KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKGcgPSByXG4gICAgICAgICAgICAgICAgPyBNYXRoLmFicygoLXcgLSB0LnRyYW5zbGF0ZSkgLyB0LnZlbG9jaXR5KVxuICAgICAgICAgICAgICAgIDogTWF0aC5hYnMoKHcgLSB0LnRyYW5zbGF0ZSkgLyB0LnZlbG9jaXR5KSksXG4gICAgICAgICAgICAgIGkuZnJlZU1vZGVTdGlja3kpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIFAgPSBNYXRoLmFicygociA/IC13IDogdykgLSB0LnRyYW5zbGF0ZSksXG4gICAgICAgICAgICAgICAgayA9IHQuc2xpZGVzU2l6ZXNHcmlkW3QuYWN0aXZlSW5kZXhdO1xuICAgICAgICAgICAgICBnID0gUCA8IGsgPyBpLnNwZWVkIDogUCA8IDIgKiBrID8gMS41ICogaS5zcGVlZCA6IDIuNSAqIGkuc3BlZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpLmZyZWVNb2RlU3RpY2t5KSByZXR1cm4gdm9pZCB0LnNsaWRlVG9DbG9zZXN0KCk7XG4gICAgICAgICAgaS5mcmVlTW9kZU1vbWVudHVtQm91bmNlICYmIENcbiAgICAgICAgICAgID8gKHQudXBkYXRlUHJvZ3Jlc3MoYiksXG4gICAgICAgICAgICAgIHQuc2V0VHJhbnNpdGlvbihnKSxcbiAgICAgICAgICAgICAgdC5zZXRUcmFuc2xhdGUodyksXG4gICAgICAgICAgICAgIHQudHJhbnNpdGlvblN0YXJ0KCEwLCB0LnN3aXBlRGlyZWN0aW9uKSxcbiAgICAgICAgICAgICAgKHQuYW5pbWF0aW5nID0gITApLFxuICAgICAgICAgICAgICBuLnRyYW5zaXRpb25FbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHQgJiZcbiAgICAgICAgICAgICAgICAgICF0LmRlc3Ryb3llZCAmJlxuICAgICAgICAgICAgICAgICAgYS5hbGxvd01vbWVudHVtQm91bmNlICYmXG4gICAgICAgICAgICAgICAgICAodC5lbWl0KFwibW9tZW50dW1Cb3VuY2VcIiksXG4gICAgICAgICAgICAgICAgICB0LnNldFRyYW5zaXRpb24oaS5zcGVlZCksXG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5zZXRUcmFuc2xhdGUoYiksXG4gICAgICAgICAgICAgICAgICAgICAgbi50cmFuc2l0aW9uRW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgJiYgIXQuZGVzdHJveWVkICYmIHQudHJhbnNpdGlvbkVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSwgMCkpO1xuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIDogdC52ZWxvY2l0eVxuICAgICAgICAgICAgPyAodC51cGRhdGVQcm9ncmVzcyh3KSxcbiAgICAgICAgICAgICAgdC5zZXRUcmFuc2l0aW9uKGcpLFxuICAgICAgICAgICAgICB0LnNldFRyYW5zbGF0ZSh3KSxcbiAgICAgICAgICAgICAgdC50cmFuc2l0aW9uU3RhcnQoITAsIHQuc3dpcGVEaXJlY3Rpb24pLFxuICAgICAgICAgICAgICB0LmFuaW1hdGluZyB8fFxuICAgICAgICAgICAgICAgICgodC5hbmltYXRpbmcgPSAhMCksXG4gICAgICAgICAgICAgICAgbi50cmFuc2l0aW9uRW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHQgJiYgIXQuZGVzdHJveWVkICYmIHQudHJhbnNpdGlvbkVuZCgpO1xuICAgICAgICAgICAgICAgIH0pKSlcbiAgICAgICAgICAgIDogdC51cGRhdGVQcm9ncmVzcyh3KSxcbiAgICAgICAgICAgIHQudXBkYXRlQWN0aXZlSW5kZXgoKSxcbiAgICAgICAgICAgIHQudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgICAgICB9IGVsc2UgaWYgKGkuZnJlZU1vZGVTdGlja3kpIHJldHVybiB2b2lkIHQuc2xpZGVUb0Nsb3Nlc3QoKTtcbiAgICAgICAgKCFpLmZyZWVNb2RlTW9tZW50dW0gfHwgYyA+PSBpLmxvbmdTd2lwZXNNcykgJiZcbiAgICAgICAgICAodC51cGRhdGVQcm9ncmVzcygpLCB0LnVwZGF0ZUFjdGl2ZUluZGV4KCksIHQudXBkYXRlU2xpZGVzQ2xhc3NlcygpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIEwgPSAwLCAkID0gdC5zbGlkZXNTaXplc0dyaWRbMF0sIEkgPSAwO1xuICAgICAgICAgIEkgPCBsLmxlbmd0aDtcbiAgICAgICAgICBJICs9IEkgPCBpLnNsaWRlc1Blckdyb3VwU2tpcCA/IDEgOiBpLnNsaWRlc1Blckdyb3VwXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBPID0gSSA8IGkuc2xpZGVzUGVyR3JvdXBTa2lwIC0gMSA/IDEgOiBpLnNsaWRlc1Blckdyb3VwO1xuICAgICAgICAgIHZvaWQgMCAhPT0gbFtJICsgT11cbiAgICAgICAgICAgID8gcCA+PSBsW0ldICYmIHAgPCBsW0kgKyBPXSAmJiAoKEwgPSBJKSwgKCQgPSBsW0kgKyBPXSAtIGxbSV0pKVxuICAgICAgICAgICAgOiBwID49IGxbSV0gJiYgKChMID0gSSksICgkID0gbFtsLmxlbmd0aCAtIDFdIC0gbFtsLmxlbmd0aCAtIDJdKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIEEgPSAocCAtIGxbTF0pIC8gJCxcbiAgICAgICAgICBEID0gTCA8IGkuc2xpZGVzUGVyR3JvdXBTa2lwIC0gMSA/IDEgOiBpLnNsaWRlc1Blckdyb3VwO1xuICAgICAgICBpZiAoYyA+IGkubG9uZ1N3aXBlc01zKSB7XG4gICAgICAgICAgaWYgKCFpLmxvbmdTd2lwZXMpIHJldHVybiB2b2lkIHQuc2xpZGVUbyh0LmFjdGl2ZUluZGV4KTtcbiAgICAgICAgICBcIm5leHRcIiA9PT0gdC5zd2lwZURpcmVjdGlvbiAmJlxuICAgICAgICAgICAgKEEgPj0gaS5sb25nU3dpcGVzUmF0aW8gPyB0LnNsaWRlVG8oTCArIEQpIDogdC5zbGlkZVRvKEwpKSxcbiAgICAgICAgICAgIFwicHJldlwiID09PSB0LnN3aXBlRGlyZWN0aW9uICYmXG4gICAgICAgICAgICAgIChBID4gMSAtIGkubG9uZ1N3aXBlc1JhdGlvID8gdC5zbGlkZVRvKEwgKyBEKSA6IHQuc2xpZGVUbyhMKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFpLnNob3J0U3dpcGVzKSByZXR1cm4gdm9pZCB0LnNsaWRlVG8odC5hY3RpdmVJbmRleCk7XG4gICAgICAgICAgdC5uYXZpZ2F0aW9uICYmXG4gICAgICAgICAgKGQudGFyZ2V0ID09PSB0Lm5hdmlnYXRpb24ubmV4dEVsIHx8IGQudGFyZ2V0ID09PSB0Lm5hdmlnYXRpb24ucHJldkVsKVxuICAgICAgICAgICAgPyBkLnRhcmdldCA9PT0gdC5uYXZpZ2F0aW9uLm5leHRFbFxuICAgICAgICAgICAgICA/IHQuc2xpZGVUbyhMICsgRClcbiAgICAgICAgICAgICAgOiB0LnNsaWRlVG8oTClcbiAgICAgICAgICAgIDogKFwibmV4dFwiID09PSB0LnN3aXBlRGlyZWN0aW9uICYmIHQuc2xpZGVUbyhMICsgRCksXG4gICAgICAgICAgICAgIFwicHJldlwiID09PSB0LnN3aXBlRGlyZWN0aW9uICYmIHQuc2xpZGVUbyhMKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBHKCkge1xuICAgIHZhciBlID0gdGhpcyxcbiAgICAgIHQgPSBlLnBhcmFtcyxcbiAgICAgIGEgPSBlLmVsO1xuICAgIGlmICghYSB8fCAwICE9PSBhLm9mZnNldFdpZHRoKSB7XG4gICAgICB0LmJyZWFrcG9pbnRzICYmIGUuc2V0QnJlYWtwb2ludCgpO1xuICAgICAgdmFyIGkgPSBlLmFsbG93U2xpZGVOZXh0LFxuICAgICAgICBzID0gZS5hbGxvd1NsaWRlUHJldixcbiAgICAgICAgciA9IGUuc25hcEdyaWQ7XG4gICAgICAoZS5hbGxvd1NsaWRlTmV4dCA9ICEwKSxcbiAgICAgICAgKGUuYWxsb3dTbGlkZVByZXYgPSAhMCksXG4gICAgICAgIGUudXBkYXRlU2l6ZSgpLFxuICAgICAgICBlLnVwZGF0ZVNsaWRlcygpLFxuICAgICAgICBlLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSxcbiAgICAgICAgKFwiYXV0b1wiID09PSB0LnNsaWRlc1BlclZpZXcgfHwgdC5zbGlkZXNQZXJWaWV3ID4gMSkgJiZcbiAgICAgICAgZS5pc0VuZCAmJlxuICAgICAgICAhZS5pc0JlZ2lubmluZyAmJlxuICAgICAgICAhZS5wYXJhbXMuY2VudGVyZWRTbGlkZXNcbiAgICAgICAgICA/IGUuc2xpZGVUbyhlLnNsaWRlcy5sZW5ndGggLSAxLCAwLCAhMSwgITApXG4gICAgICAgICAgOiBlLnNsaWRlVG8oZS5hY3RpdmVJbmRleCwgMCwgITEsICEwKSxcbiAgICAgICAgZS5hdXRvcGxheSAmJlxuICAgICAgICAgIGUuYXV0b3BsYXkucnVubmluZyAmJlxuICAgICAgICAgIGUuYXV0b3BsYXkucGF1c2VkICYmXG4gICAgICAgICAgZS5hdXRvcGxheS5ydW4oKSxcbiAgICAgICAgKGUuYWxsb3dTbGlkZVByZXYgPSBzKSxcbiAgICAgICAgKGUuYWxsb3dTbGlkZU5leHQgPSBpKSxcbiAgICAgICAgZS5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiByICE9PSBlLnNuYXBHcmlkICYmIGUuY2hlY2tPdmVyZmxvdygpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBOKGUpIHtcbiAgICB2YXIgdCA9IHRoaXM7XG4gICAgdC5hbGxvd0NsaWNrIHx8XG4gICAgICAodC5wYXJhbXMucHJldmVudENsaWNrcyAmJiBlLnByZXZlbnREZWZhdWx0KCksXG4gICAgICB0LnBhcmFtcy5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24gJiZcbiAgICAgICAgdC5hbmltYXRpbmcgJiZcbiAgICAgICAgKGUuc3RvcFByb3BhZ2F0aW9uKCksIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkpKTtcbiAgfVxuICBmdW5jdGlvbiBCKCkge1xuICAgIHZhciBlID0gdGhpcyxcbiAgICAgIHQgPSBlLndyYXBwZXJFbCxcbiAgICAgIGEgPSBlLnJ0bFRyYW5zbGF0ZTtcbiAgICAoZS5wcmV2aW91c1RyYW5zbGF0ZSA9IGUudHJhbnNsYXRlKSxcbiAgICAgIGUuaXNIb3Jpem9udGFsKClcbiAgICAgICAgPyAoZS50cmFuc2xhdGUgPSBhXG4gICAgICAgICAgICA/IHQuc2Nyb2xsV2lkdGggLSB0Lm9mZnNldFdpZHRoIC0gdC5zY3JvbGxMZWZ0XG4gICAgICAgICAgICA6IC10LnNjcm9sbExlZnQpXG4gICAgICAgIDogKGUudHJhbnNsYXRlID0gLXQuc2Nyb2xsVG9wKSxcbiAgICAgIC0wID09PSBlLnRyYW5zbGF0ZSAmJiAoZS50cmFuc2xhdGUgPSAwKSxcbiAgICAgIGUudXBkYXRlQWN0aXZlSW5kZXgoKSxcbiAgICAgIGUudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgIHZhciBpID0gZS5tYXhUcmFuc2xhdGUoKSAtIGUubWluVHJhbnNsYXRlKCk7XG4gICAgKDAgPT09IGkgPyAwIDogKGUudHJhbnNsYXRlIC0gZS5taW5UcmFuc2xhdGUoKSkgLyBpKSAhPT0gZS5wcm9ncmVzcyAmJlxuICAgICAgZS51cGRhdGVQcm9ncmVzcyhhID8gLWUudHJhbnNsYXRlIDogZS50cmFuc2xhdGUpLFxuICAgICAgZS5lbWl0KFwic2V0VHJhbnNsYXRlXCIsIGUudHJhbnNsYXRlLCAhMSk7XG4gIH1cbiAgdmFyIEggPSAhMTtcbiAgZnVuY3Rpb24gWCgpIHt9XG4gIHZhciBZID0ge1xuICAgICAgaW5pdDogITAsXG4gICAgICBkaXJlY3Rpb246IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgdG91Y2hFdmVudHNUYXJnZXQ6IFwiY29udGFpbmVyXCIsXG4gICAgICBpbml0aWFsU2xpZGU6IDAsXG4gICAgICBzcGVlZDogMzAwLFxuICAgICAgY3NzTW9kZTogITEsXG4gICAgICB1cGRhdGVPbldpbmRvd1Jlc2l6ZTogITAsXG4gICAgICBuZXN0ZWQ6ICExLFxuICAgICAgd2lkdGg6IG51bGwsXG4gICAgICBoZWlnaHQ6IG51bGwsXG4gICAgICBwcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb246ICExLFxuICAgICAgdXNlckFnZW50OiBudWxsLFxuICAgICAgdXJsOiBudWxsLFxuICAgICAgZWRnZVN3aXBlRGV0ZWN0aW9uOiAhMSxcbiAgICAgIGVkZ2VTd2lwZVRocmVzaG9sZDogMjAsXG4gICAgICBmcmVlTW9kZTogITEsXG4gICAgICBmcmVlTW9kZU1vbWVudHVtOiAhMCxcbiAgICAgIGZyZWVNb2RlTW9tZW50dW1SYXRpbzogMSxcbiAgICAgIGZyZWVNb2RlTW9tZW50dW1Cb3VuY2U6ICEwLFxuICAgICAgZnJlZU1vZGVNb21lbnR1bUJvdW5jZVJhdGlvOiAxLFxuICAgICAgZnJlZU1vZGVNb21lbnR1bVZlbG9jaXR5UmF0aW86IDEsXG4gICAgICBmcmVlTW9kZVN0aWNreTogITEsXG4gICAgICBmcmVlTW9kZU1pbmltdW1WZWxvY2l0eTogMC4wMixcbiAgICAgIGF1dG9IZWlnaHQ6ICExLFxuICAgICAgc2V0V3JhcHBlclNpemU6ICExLFxuICAgICAgdmlydHVhbFRyYW5zbGF0ZTogITEsXG4gICAgICBlZmZlY3Q6IFwic2xpZGVcIixcbiAgICAgIGJyZWFrcG9pbnRzOiB2b2lkIDAsXG4gICAgICBzcGFjZUJldHdlZW46IDAsXG4gICAgICBzbGlkZXNQZXJWaWV3OiAxLFxuICAgICAgc2xpZGVzUGVyQ29sdW1uOiAxLFxuICAgICAgc2xpZGVzUGVyQ29sdW1uRmlsbDogXCJjb2x1bW5cIixcbiAgICAgIHNsaWRlc1Blckdyb3VwOiAxLFxuICAgICAgc2xpZGVzUGVyR3JvdXBTa2lwOiAwLFxuICAgICAgY2VudGVyZWRTbGlkZXM6ICExLFxuICAgICAgY2VudGVyZWRTbGlkZXNCb3VuZHM6ICExLFxuICAgICAgc2xpZGVzT2Zmc2V0QmVmb3JlOiAwLFxuICAgICAgc2xpZGVzT2Zmc2V0QWZ0ZXI6IDAsXG4gICAgICBub3JtYWxpemVTbGlkZUluZGV4OiAhMCxcbiAgICAgIGNlbnRlckluc3VmZmljaWVudFNsaWRlczogITEsXG4gICAgICB3YXRjaE92ZXJmbG93OiAhMSxcbiAgICAgIHJvdW5kTGVuZ3RoczogITEsXG4gICAgICB0b3VjaFJhdGlvOiAxLFxuICAgICAgdG91Y2hBbmdsZTogNDUsXG4gICAgICBzaW11bGF0ZVRvdWNoOiAhMCxcbiAgICAgIHNob3J0U3dpcGVzOiAhMCxcbiAgICAgIGxvbmdTd2lwZXM6ICEwLFxuICAgICAgbG9uZ1N3aXBlc1JhdGlvOiAwLjUsXG4gICAgICBsb25nU3dpcGVzTXM6IDMwMCxcbiAgICAgIGZvbGxvd0ZpbmdlcjogITAsXG4gICAgICBhbGxvd1RvdWNoTW92ZTogITAsXG4gICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICB0b3VjaE1vdmVTdG9wUHJvcGFnYXRpb246ICExLFxuICAgICAgdG91Y2hTdGFydFByZXZlbnREZWZhdWx0OiAhMCxcbiAgICAgIHRvdWNoU3RhcnRGb3JjZVByZXZlbnREZWZhdWx0OiAhMSxcbiAgICAgIHRvdWNoUmVsZWFzZU9uRWRnZXM6ICExLFxuICAgICAgdW5pcXVlTmF2RWxlbWVudHM6ICEwLFxuICAgICAgcmVzaXN0YW5jZTogITAsXG4gICAgICByZXNpc3RhbmNlUmF0aW86IDAuODUsXG4gICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiAhMSxcbiAgICAgIHdhdGNoU2xpZGVzVmlzaWJpbGl0eTogITEsXG4gICAgICBncmFiQ3Vyc29yOiAhMSxcbiAgICAgIHByZXZlbnRDbGlja3M6ICEwLFxuICAgICAgcHJldmVudENsaWNrc1Byb3BhZ2F0aW9uOiAhMCxcbiAgICAgIHNsaWRlVG9DbGlja2VkU2xpZGU6ICExLFxuICAgICAgcHJlbG9hZEltYWdlczogITAsXG4gICAgICB1cGRhdGVPbkltYWdlc1JlYWR5OiAhMCxcbiAgICAgIGxvb3A6ICExLFxuICAgICAgbG9vcEFkZGl0aW9uYWxTbGlkZXM6IDAsXG4gICAgICBsb29wZWRTbGlkZXM6IG51bGwsXG4gICAgICBsb29wRmlsbEdyb3VwV2l0aEJsYW5rOiAhMSxcbiAgICAgIGxvb3BQcmV2ZW50c1NsaWRlOiAhMCxcbiAgICAgIGFsbG93U2xpZGVQcmV2OiAhMCxcbiAgICAgIGFsbG93U2xpZGVOZXh0OiAhMCxcbiAgICAgIHN3aXBlSGFuZGxlcjogbnVsbCxcbiAgICAgIG5vU3dpcGluZzogITAsXG4gICAgICBub1N3aXBpbmdDbGFzczogXCJzd2lwZXItbm8tc3dpcGluZ1wiLFxuICAgICAgbm9Td2lwaW5nU2VsZWN0b3I6IG51bGwsXG4gICAgICBwYXNzaXZlTGlzdGVuZXJzOiAhMCxcbiAgICAgIGNvbnRhaW5lck1vZGlmaWVyQ2xhc3M6IFwic3dpcGVyLWNvbnRhaW5lci1cIixcbiAgICAgIHNsaWRlQ2xhc3M6IFwic3dpcGVyLXNsaWRlXCIsXG4gICAgICBzbGlkZUJsYW5rQ2xhc3M6IFwic3dpcGVyLXNsaWRlLWludmlzaWJsZS1ibGFua1wiLFxuICAgICAgc2xpZGVBY3RpdmVDbGFzczogXCJzd2lwZXItc2xpZGUtYWN0aXZlXCIsXG4gICAgICBzbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzOiBcInN3aXBlci1zbGlkZS1kdXBsaWNhdGUtYWN0aXZlXCIsXG4gICAgICBzbGlkZVZpc2libGVDbGFzczogXCJzd2lwZXItc2xpZGUtdmlzaWJsZVwiLFxuICAgICAgc2xpZGVEdXBsaWNhdGVDbGFzczogXCJzd2lwZXItc2xpZGUtZHVwbGljYXRlXCIsXG4gICAgICBzbGlkZU5leHRDbGFzczogXCJzd2lwZXItc2xpZGUtbmV4dFwiLFxuICAgICAgc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3M6IFwic3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1uZXh0XCIsXG4gICAgICBzbGlkZVByZXZDbGFzczogXCJzd2lwZXItc2xpZGUtcHJldlwiLFxuICAgICAgc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3M6IFwic3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1wcmV2XCIsXG4gICAgICB3cmFwcGVyQ2xhc3M6IFwic3dpcGVyLXdyYXBwZXJcIixcbiAgICAgIHJ1bkNhbGxiYWNrc09uSW5pdDogITAsXG4gICAgICBfZW1pdENsYXNzZXM6ICExLFxuICAgIH0sXG4gICAgViA9IHtcbiAgICAgIG1vZHVsYXI6IHtcbiAgICAgICAgdXNlUGFyYW1zOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgICAgICB0Lm1vZHVsZXMgJiZcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHQubW9kdWxlcykuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICB2YXIgaSA9IHQubW9kdWxlc1thXTtcbiAgICAgICAgICAgICAgaS5wYXJhbXMgJiYgUyhlLCBpLnBhcmFtcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlTW9kdWxlczogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSB7fSk7XG4gICAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICAgIHQubW9kdWxlcyAmJlxuICAgICAgICAgICAgT2JqZWN0LmtleXModC5tb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgIHZhciBpID0gdC5tb2R1bGVzW2FdLFxuICAgICAgICAgICAgICAgIHMgPSBlW2FdIHx8IHt9O1xuICAgICAgICAgICAgICBpLm9uICYmXG4gICAgICAgICAgICAgICAgdC5vbiAmJlxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGkub24pLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIHQub24oZSwgaS5vbltlXSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaS5jcmVhdGUgJiYgaS5jcmVhdGUuYmluZCh0KShzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGV2ZW50c0VtaXR0ZXI6IHtcbiAgICAgICAgb246IGZ1bmN0aW9uIChlLCB0LCBhKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQpIHJldHVybiBpO1xuICAgICAgICAgIHZhciBzID0gYSA/IFwidW5zaGlmdFwiIDogXCJwdXNoXCI7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGUuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgaS5ldmVudHNMaXN0ZW5lcnNbZV0gfHwgKGkuZXZlbnRzTGlzdGVuZXJzW2VdID0gW10pLFxuICAgICAgICAgICAgICAgIGkuZXZlbnRzTGlzdGVuZXJzW2VdW3NdKHQpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25jZTogZnVuY3Rpb24gKGUsIHQsIGEpIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXM7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCkgcmV0dXJuIGk7XG4gICAgICAgICAgZnVuY3Rpb24gcygpIHtcbiAgICAgICAgICAgIGkub2ZmKGUsIHMpLCBzLl9fZW1pdHRlclByb3h5ICYmIGRlbGV0ZSBzLl9fZW1pdHRlclByb3h5O1xuICAgICAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBuZXcgQXJyYXkoYSksIG4gPSAwOyBuIDwgYTsgbisrKVxuICAgICAgICAgICAgICByW25dID0gYXJndW1lbnRzW25dO1xuICAgICAgICAgICAgdC5hcHBseShpLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIChzLl9fZW1pdHRlclByb3h5ID0gdCksIGkub24oZSwgcywgYSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQW55OiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4gYTtcbiAgICAgICAgICB2YXIgaSA9IHQgPyBcInVuc2hpZnRcIiA6IFwicHVzaFwiO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBhLmV2ZW50c0FueUxpc3RlbmVycy5pbmRleE9mKGUpIDwgMCAmJiBhLmV2ZW50c0FueUxpc3RlbmVyc1tpXShlKSwgYVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIG9mZkFueTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICAgICAgaWYgKCF0LmV2ZW50c0FueUxpc3RlbmVycykgcmV0dXJuIHQ7XG4gICAgICAgICAgdmFyIGEgPSB0LmV2ZW50c0FueUxpc3RlbmVycy5pbmRleE9mKGUpO1xuICAgICAgICAgIHJldHVybiBhID49IDAgJiYgdC5ldmVudHNBbnlMaXN0ZW5lcnMuc3BsaWNlKGEsIDEpLCB0O1xuICAgICAgICB9LFxuICAgICAgICBvZmY6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBhLmV2ZW50c0xpc3RlbmVyc1xuICAgICAgICAgICAgPyAoZS5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gdFxuICAgICAgICAgICAgICAgICAgPyAoYS5ldmVudHNMaXN0ZW5lcnNbZV0gPSBbXSlcbiAgICAgICAgICAgICAgICAgIDogYS5ldmVudHNMaXN0ZW5lcnNbZV0gJiZcbiAgICAgICAgICAgICAgICAgICAgYS5ldmVudHNMaXN0ZW5lcnNbZV0uZm9yRWFjaChmdW5jdGlvbiAoaSwgcykge1xuICAgICAgICAgICAgICAgICAgICAgIChpID09PSB0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoaS5fX2VtaXR0ZXJQcm94eSAmJiBpLl9fZW1pdHRlclByb3h5ID09PSB0KSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuZXZlbnRzTGlzdGVuZXJzW2VdLnNwbGljZShzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBhKVxuICAgICAgICAgICAgOiBhO1xuICAgICAgICB9LFxuICAgICAgICBlbWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGUsXG4gICAgICAgICAgICB0LFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGkgPSB0aGlzO1xuICAgICAgICAgIGlmICghaS5ldmVudHNMaXN0ZW5lcnMpIHJldHVybiBpO1xuICAgICAgICAgIGZvciAodmFyIHMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gbmV3IEFycmF5KHMpLCBuID0gMDsgbiA8IHM7IG4rKylcbiAgICAgICAgICAgIHJbbl0gPSBhcmd1bWVudHNbbl07XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgclswXSB8fCBBcnJheS5pc0FycmF5KHJbMF0pXG4gICAgICAgICAgICA/ICgoZSA9IHJbMF0pLCAodCA9IHIuc2xpY2UoMSwgci5sZW5ndGgpKSwgKGEgPSBpKSlcbiAgICAgICAgICAgIDogKChlID0gclswXS5ldmVudHMpLCAodCA9IHJbMF0uZGF0YSksIChhID0gclswXS5jb250ZXh0IHx8IGkpKSxcbiAgICAgICAgICAgIHQudW5zaGlmdChhKTtcbiAgICAgICAgICB2YXIgbCA9IEFycmF5LmlzQXJyYXkoZSkgPyBlIDogZS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGwuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBpLmV2ZW50c0FueUxpc3RlbmVycyAmJlxuICAgICAgICAgICAgICAgIGkuZXZlbnRzQW55TGlzdGVuZXJzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGkuZXZlbnRzQW55TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgIGkuYXBwbHkoYSwgW2VdLmNvbmNhdCh0KSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaS5ldmVudHNMaXN0ZW5lcnMgJiZcbiAgICAgICAgICAgICAgICAgIGkuZXZlbnRzTGlzdGVuZXJzW2VdICYmXG4gICAgICAgICAgICAgICAgICBpLmV2ZW50c0xpc3RlbmVyc1tlXS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwbHkoYSwgdCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHVwZGF0ZVNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZSxcbiAgICAgICAgICAgIHQsXG4gICAgICAgICAgICBhID0gdGhpcyxcbiAgICAgICAgICAgIGkgPSBhLiRlbDtcbiAgICAgICAgICAoZSA9XG4gICAgICAgICAgICB2b2lkIDAgIT09IGEucGFyYW1zLndpZHRoICYmIG51bGwgIT09IGEucGFyYW1zLndpZHRoXG4gICAgICAgICAgICAgID8gYS5wYXJhbXMud2lkdGhcbiAgICAgICAgICAgICAgOiBpWzBdLmNsaWVudFdpZHRoKSxcbiAgICAgICAgICAgICh0ID1cbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBhLnBhcmFtcy5oZWlnaHQgJiYgbnVsbCAhPT0gYS5wYXJhbXMuaGVpZ2h0XG4gICAgICAgICAgICAgICAgPyBhLnBhcmFtcy5oZWlnaHRcbiAgICAgICAgICAgICAgICA6IGlbMF0uY2xpZW50SGVpZ2h0KSxcbiAgICAgICAgICAgICgwID09PSBlICYmIGEuaXNIb3Jpem9udGFsKCkpIHx8XG4gICAgICAgICAgICAgICgwID09PSB0ICYmIGEuaXNWZXJ0aWNhbCgpKSB8fFxuICAgICAgICAgICAgICAoKGUgPVxuICAgICAgICAgICAgICAgIGUgLVxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGkuY3NzKFwicGFkZGluZy1sZWZ0XCIpIHx8IDAsIDEwKSAtXG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoaS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIpIHx8IDAsIDEwKSksXG4gICAgICAgICAgICAgICh0ID1cbiAgICAgICAgICAgICAgICB0IC1cbiAgICAgICAgICAgICAgICBwYXJzZUludChpLmNzcyhcInBhZGRpbmctdG9wXCIpIHx8IDAsIDEwKSAtXG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoaS5jc3MoXCJwYWRkaW5nLWJvdHRvbVwiKSB8fCAwLCAxMCkpLFxuICAgICAgICAgICAgICBOdW1iZXIuaXNOYU4oZSkgJiYgKGUgPSAwKSxcbiAgICAgICAgICAgICAgTnVtYmVyLmlzTmFOKHQpICYmICh0ID0gMCksXG4gICAgICAgICAgICAgIFMoYSwgeyB3aWR0aDogZSwgaGVpZ2h0OiB0LCBzaXplOiBhLmlzSG9yaXpvbnRhbCgpID8gZSA6IHQgfSkpO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVTbGlkZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgICB0ID0gbCgpLFxuICAgICAgICAgICAgYSA9IGUucGFyYW1zLFxuICAgICAgICAgICAgaSA9IGUuJHdyYXBwZXJFbCxcbiAgICAgICAgICAgIHMgPSBlLnNpemUsXG4gICAgICAgICAgICByID0gZS5ydGxUcmFuc2xhdGUsXG4gICAgICAgICAgICBuID0gZS53cm9uZ1JUTCxcbiAgICAgICAgICAgIG8gPSBlLnZpcnR1YWwgJiYgYS52aXJ0dWFsLmVuYWJsZWQsXG4gICAgICAgICAgICBkID0gbyA/IGUudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogZS5zbGlkZXMubGVuZ3RoLFxuICAgICAgICAgICAgcCA9IGkuY2hpbGRyZW4oXCIuXCIgKyBlLnBhcmFtcy5zbGlkZUNsYXNzKSxcbiAgICAgICAgICAgIHUgPSBvID8gZS52aXJ0dWFsLnNsaWRlcy5sZW5ndGggOiBwLmxlbmd0aCxcbiAgICAgICAgICAgIGMgPSBbXSxcbiAgICAgICAgICAgIGggPSBbXSxcbiAgICAgICAgICAgIHYgPSBbXTtcbiAgICAgICAgICBmdW5jdGlvbiBmKGUsIHQpIHtcbiAgICAgICAgICAgIHJldHVybiAhYS5jc3NNb2RlIHx8IHQgIT09IHAubGVuZ3RoIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG0gPSBhLnNsaWRlc09mZnNldEJlZm9yZTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG0gJiYgKG0gPSBhLnNsaWRlc09mZnNldEJlZm9yZS5jYWxsKGUpKTtcbiAgICAgICAgICB2YXIgZyA9IGEuc2xpZGVzT2Zmc2V0QWZ0ZXI7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09IHR5cGVvZiBnICYmIChnID0gYS5zbGlkZXNPZmZzZXRBZnRlci5jYWxsKGUpKTtcbiAgICAgICAgICB2YXIgeSA9IGUuc25hcEdyaWQubGVuZ3RoLFxuICAgICAgICAgICAgdyA9IGUuc2xpZGVzR3JpZC5sZW5ndGgsXG4gICAgICAgICAgICBiID0gYS5zcGFjZUJldHdlZW4sXG4gICAgICAgICAgICBFID0gLW0sXG4gICAgICAgICAgICB4ID0gMCxcbiAgICAgICAgICAgIFQgPSAwO1xuICAgICAgICAgIGlmICh2b2lkIDAgIT09IHMpIHtcbiAgICAgICAgICAgIHZhciBDLCBNO1xuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgYiAmJlxuICAgICAgICAgICAgICBiLmluZGV4T2YoXCIlXCIpID49IDAgJiZcbiAgICAgICAgICAgICAgKGIgPSAocGFyc2VGbG9hdChiLnJlcGxhY2UoXCIlXCIsIFwiXCIpKSAvIDEwMCkgKiBzKSxcbiAgICAgICAgICAgICAgKGUudmlydHVhbFNpemUgPSAtYiksXG4gICAgICAgICAgICAgIHJcbiAgICAgICAgICAgICAgICA/IHAuY3NzKHsgbWFyZ2luTGVmdDogXCJcIiwgbWFyZ2luVG9wOiBcIlwiIH0pXG4gICAgICAgICAgICAgICAgOiBwLmNzcyh7IG1hcmdpblJpZ2h0OiBcIlwiLCBtYXJnaW5Cb3R0b206IFwiXCIgfSksXG4gICAgICAgICAgICAgIGEuc2xpZGVzUGVyQ29sdW1uID4gMSAmJlxuICAgICAgICAgICAgICAgICgoQyA9XG4gICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKHUgLyBhLnNsaWRlc1BlckNvbHVtbikgPT09XG4gICAgICAgICAgICAgICAgICB1IC8gZS5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgID8gdVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGguY2VpbCh1IC8gYS5zbGlkZXNQZXJDb2x1bW4pICogYS5zbGlkZXNQZXJDb2x1bW4pLFxuICAgICAgICAgICAgICAgIFwiYXV0b1wiICE9PSBhLnNsaWRlc1BlclZpZXcgJiZcbiAgICAgICAgICAgICAgICAgIFwicm93XCIgPT09IGEuc2xpZGVzUGVyQ29sdW1uRmlsbCAmJlxuICAgICAgICAgICAgICAgICAgKEMgPSBNYXRoLm1heChDLCBhLnNsaWRlc1BlclZpZXcgKiBhLnNsaWRlc1BlckNvbHVtbikpKTtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIHZhciB6LFxuICAgICAgICAgICAgICAgIFAgPSBhLnNsaWRlc1BlckNvbHVtbixcbiAgICAgICAgICAgICAgICBrID0gQyAvIFAsXG4gICAgICAgICAgICAgICAgTCA9IE1hdGguZmxvb3IodSAvIGEuc2xpZGVzUGVyQ29sdW1uKSxcbiAgICAgICAgICAgICAgICAkID0gMDtcbiAgICAgICAgICAgICAgJCA8IHU7XG4gICAgICAgICAgICAgICQgKz0gMVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIE0gPSAwO1xuICAgICAgICAgICAgICB2YXIgSSA9IHAuZXEoJCk7XG4gICAgICAgICAgICAgIGlmIChhLnNsaWRlc1BlckNvbHVtbiA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgTyA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgIEEgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICBEID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChcInJvd1wiID09PSBhLnNsaWRlc1BlckNvbHVtbkZpbGwgJiYgYS5zbGlkZXNQZXJHcm91cCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBHID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAgICAgICAgICAgICAkIC8gKGEuc2xpZGVzUGVyR3JvdXAgKiBhLnNsaWRlc1BlckNvbHVtbilcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgTiA9ICQgLSBhLnNsaWRlc1BlckNvbHVtbiAqIGEuc2xpZGVzUGVyR3JvdXAgKiBHLFxuICAgICAgICAgICAgICAgICAgICBCID1cbiAgICAgICAgICAgICAgICAgICAgICAwID09PSBHXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGEuc2xpZGVzUGVyR3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKCh1IC0gRyAqIFAgKiBhLnNsaWRlc1Blckdyb3VwKSAvIFApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuc2xpZGVzUGVyR3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIChPID1cbiAgICAgICAgICAgICAgICAgICAgKEEgPVxuICAgICAgICAgICAgICAgICAgICAgIE4gLSAoRCA9IE1hdGguZmxvb3IoTiAvIEIpKSAqIEIgKyBHICogYS5zbGlkZXNQZXJHcm91cCkgK1xuICAgICAgICAgICAgICAgICAgICAoRCAqIEMpIC8gUCksXG4gICAgICAgICAgICAgICAgICAgIEkuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICBcIi13ZWJraXQtYm94LW9yZGluYWwtZ3JvdXBcIjogTyxcbiAgICAgICAgICAgICAgICAgICAgICBcIi1tb3otYm94LW9yZGluYWwtZ3JvdXBcIjogTyxcbiAgICAgICAgICAgICAgICAgICAgICBcIi1tcy1mbGV4LW9yZGVyXCI6IE8sXG4gICAgICAgICAgICAgICAgICAgICAgXCItd2Via2l0LW9yZGVyXCI6IE8sXG4gICAgICAgICAgICAgICAgICAgICAgb3JkZXI6IE8sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgXCJjb2x1bW5cIiA9PT0gYS5zbGlkZXNQZXJDb2x1bW5GaWxsXG4gICAgICAgICAgICAgICAgICAgID8gKChEID0gJCAtIChBID0gTWF0aC5mbG9vcigkIC8gUCkpICogUCksXG4gICAgICAgICAgICAgICAgICAgICAgKEEgPiBMIHx8IChBID09PSBMICYmIEQgPT09IFAgLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChEICs9IDEpID49IFAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICgoRCA9IDApLCAoQSArPSAxKSkpXG4gICAgICAgICAgICAgICAgICAgIDogKEEgPSAkIC0gKEQgPSBNYXRoLmZsb29yKCQgLyBrKSkgKiBrKTtcbiAgICAgICAgICAgICAgICBJLmNzcyhcbiAgICAgICAgICAgICAgICAgIFwibWFyZ2luLVwiICsgKGUuaXNIb3Jpem9udGFsKCkgPyBcInRvcFwiIDogXCJsZWZ0XCIpLFxuICAgICAgICAgICAgICAgICAgMCAhPT0gRCAmJiBhLnNwYWNlQmV0d2VlbiAmJiBhLnNwYWNlQmV0d2VlbiArIFwicHhcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKFwibm9uZVwiICE9PSBJLmNzcyhcImRpc3BsYXlcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJhdXRvXCIgPT09IGEuc2xpZGVzUGVyVmlldykge1xuICAgICAgICAgICAgICAgICAgdmFyIEggPSB0LmdldENvbXB1dGVkU3R5bGUoSVswXSwgbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIFggPSBJWzBdLnN0eWxlLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgWSA9IElbMF0uc3R5bGUud2Via2l0VHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAoWCAmJiAoSVswXS5zdHlsZS50cmFuc2Zvcm0gPSBcIm5vbmVcIiksXG4gICAgICAgICAgICAgICAgICAgIFkgJiYgKElbMF0uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gXCJub25lXCIpLFxuICAgICAgICAgICAgICAgICAgICBhLnJvdW5kTGVuZ3RocylcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgTSA9IGUuaXNIb3Jpem9udGFsKCkgPyBJLm91dGVyV2lkdGgoITApIDogSS5vdXRlckhlaWdodCghMCk7XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChlLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBWID0gcGFyc2VGbG9hdChILmdldFByb3BlcnR5VmFsdWUoXCJ3aWR0aFwiKSB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICBGID0gcGFyc2VGbG9hdChILmdldFByb3BlcnR5VmFsdWUoXCJwYWRkaW5nLWxlZnRcIikgfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgUiA9IHBhcnNlRmxvYXQoSC5nZXRQcm9wZXJ0eVZhbHVlKFwicGFkZGluZy1yaWdodFwiKSB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICBXID0gcGFyc2VGbG9hdChILmdldFByb3BlcnR5VmFsdWUoXCJtYXJnaW4tbGVmdFwiKSB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICBxID0gcGFyc2VGbG9hdChILmdldFByb3BlcnR5VmFsdWUoXCJtYXJnaW4tcmlnaHRcIikgfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgaiA9IEguZ2V0UHJvcGVydHlWYWx1ZShcImJveC1zaXppbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqICYmIFwiYm9yZGVyLWJveFwiID09PSBqKSBNID0gViArIFcgKyBxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgXyA9IElbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBVID0gXy5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICBNID0gViArIEYgKyBSICsgVyArIHEgKyAoXy5vZmZzZXRXaWR0aCAtIFUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgSyA9IHBhcnNlRmxvYXQoSC5nZXRQcm9wZXJ0eVZhbHVlKFwiaGVpZ2h0XCIpIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgIFogPSBwYXJzZUZsb2F0KEguZ2V0UHJvcGVydHlWYWx1ZShcInBhZGRpbmctdG9wXCIpIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgIEogPSBwYXJzZUZsb2F0KEguZ2V0UHJvcGVydHlWYWx1ZShcInBhZGRpbmctYm90dG9tXCIpIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgIFEgPSBwYXJzZUZsb2F0KEguZ2V0UHJvcGVydHlWYWx1ZShcIm1hcmdpbi10b3BcIikgfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgZWUgPSBwYXJzZUZsb2F0KEguZ2V0UHJvcGVydHlWYWx1ZShcIm1hcmdpbi1ib3R0b21cIikgfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgdGUgPSBILmdldFByb3BlcnR5VmFsdWUoXCJib3gtc2l6aW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGUgJiYgXCJib3JkZXItYm94XCIgPT09IHRlKSBNID0gSyArIFEgKyBlZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGFlID0gSVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGllID0gYWUuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgIE0gPSBLICsgWiArIEogKyBRICsgZWUgKyAoYWUub2Zmc2V0SGVpZ2h0IC0gaWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBYICYmIChJWzBdLnN0eWxlLnRyYW5zZm9ybSA9IFgpLFxuICAgICAgICAgICAgICAgICAgICBZICYmIChJWzBdLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IFkpLFxuICAgICAgICAgICAgICAgICAgICBhLnJvdW5kTGVuZ3RocyAmJiAoTSA9IE1hdGguZmxvb3IoTSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgKE0gPSAocyAtIChhLnNsaWRlc1BlclZpZXcgLSAxKSAqIGIpIC8gYS5zbGlkZXNQZXJWaWV3KSxcbiAgICAgICAgICAgICAgICAgICAgYS5yb3VuZExlbmd0aHMgJiYgKE0gPSBNYXRoLmZsb29yKE0pKSxcbiAgICAgICAgICAgICAgICAgICAgcFskXSAmJlxuICAgICAgICAgICAgICAgICAgICAgIChlLmlzSG9yaXpvbnRhbCgpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChwWyRdLnN0eWxlLndpZHRoID0gTSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKHBbJF0uc3R5bGUuaGVpZ2h0ID0gTSArIFwicHhcIikpO1xuICAgICAgICAgICAgICAgIHBbJF0gJiYgKHBbJF0uc3dpcGVyU2xpZGVTaXplID0gTSksXG4gICAgICAgICAgICAgICAgICB2LnB1c2goTSksXG4gICAgICAgICAgICAgICAgICBhLmNlbnRlcmVkU2xpZGVzXG4gICAgICAgICAgICAgICAgICAgID8gKChFID0gRSArIE0gLyAyICsgeCAvIDIgKyBiKSxcbiAgICAgICAgICAgICAgICAgICAgICAwID09PSB4ICYmIDAgIT09ICQgJiYgKEUgPSBFIC0gcyAvIDIgLSBiKSxcbiAgICAgICAgICAgICAgICAgICAgICAwID09PSAkICYmIChFID0gRSAtIHMgLyAyIC0gYiksXG4gICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoRSkgPCAwLjAwMSAmJiAoRSA9IDApLFxuICAgICAgICAgICAgICAgICAgICAgIGEucm91bmRMZW5ndGhzICYmIChFID0gTWF0aC5mbG9vcihFKSksXG4gICAgICAgICAgICAgICAgICAgICAgVCAlIGEuc2xpZGVzUGVyR3JvdXAgPT0gMCAmJiBjLnB1c2goRSksXG4gICAgICAgICAgICAgICAgICAgICAgaC5wdXNoKEUpKVxuICAgICAgICAgICAgICAgICAgICA6IChhLnJvdW5kTGVuZ3RocyAmJiAoRSA9IE1hdGguZmxvb3IoRSkpLFxuICAgICAgICAgICAgICAgICAgICAgIChUIC0gTWF0aC5taW4oZS5wYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLCBUKSkgJVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wYXJhbXMuc2xpZGVzUGVyR3JvdXAgPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIDAgJiYgYy5wdXNoKEUpLFxuICAgICAgICAgICAgICAgICAgICAgIGgucHVzaChFKSxcbiAgICAgICAgICAgICAgICAgICAgICAoRSA9IEUgKyBNICsgYikpLFxuICAgICAgICAgICAgICAgICAgKGUudmlydHVhbFNpemUgKz0gTSArIGIpLFxuICAgICAgICAgICAgICAgICAgKHggPSBNKSxcbiAgICAgICAgICAgICAgICAgIChUICs9IDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgoZS52aXJ0dWFsU2l6ZSA9IE1hdGgubWF4KGUudmlydHVhbFNpemUsIHMpICsgZyksXG4gICAgICAgICAgICAgIHIgJiZcbiAgICAgICAgICAgICAgICBuICYmXG4gICAgICAgICAgICAgICAgKFwic2xpZGVcIiA9PT0gYS5lZmZlY3QgfHwgXCJjb3ZlcmZsb3dcIiA9PT0gYS5lZmZlY3QpICYmXG4gICAgICAgICAgICAgICAgaS5jc3MoeyB3aWR0aDogZS52aXJ0dWFsU2l6ZSArIGEuc3BhY2VCZXR3ZWVuICsgXCJweFwiIH0pLFxuICAgICAgICAgICAgICBhLnNldFdyYXBwZXJTaXplICYmXG4gICAgICAgICAgICAgICAgKGUuaXNIb3Jpem9udGFsKClcbiAgICAgICAgICAgICAgICAgID8gaS5jc3MoeyB3aWR0aDogZS52aXJ0dWFsU2l6ZSArIGEuc3BhY2VCZXR3ZWVuICsgXCJweFwiIH0pXG4gICAgICAgICAgICAgICAgICA6IGkuY3NzKHsgaGVpZ2h0OiBlLnZpcnR1YWxTaXplICsgYS5zcGFjZUJldHdlZW4gKyBcInB4XCIgfSkpLFxuICAgICAgICAgICAgICBhLnNsaWRlc1BlckNvbHVtbiA+IDEgJiZcbiAgICAgICAgICAgICAgICAoKGUudmlydHVhbFNpemUgPSAoTSArIGEuc3BhY2VCZXR3ZWVuKSAqIEMpLFxuICAgICAgICAgICAgICAgIChlLnZpcnR1YWxTaXplID1cbiAgICAgICAgICAgICAgICAgIE1hdGguY2VpbChlLnZpcnR1YWxTaXplIC8gYS5zbGlkZXNQZXJDb2x1bW4pIC1cbiAgICAgICAgICAgICAgICAgIGEuc3BhY2VCZXR3ZWVuKSxcbiAgICAgICAgICAgICAgICBlLmlzSG9yaXpvbnRhbCgpXG4gICAgICAgICAgICAgICAgICA/IGkuY3NzKHsgd2lkdGg6IGUudmlydHVhbFNpemUgKyBhLnNwYWNlQmV0d2VlbiArIFwicHhcIiB9KVxuICAgICAgICAgICAgICAgICAgOiBpLmNzcyh7IGhlaWdodDogZS52aXJ0dWFsU2l6ZSArIGEuc3BhY2VCZXR3ZWVuICsgXCJweFwiIH0pLFxuICAgICAgICAgICAgICAgIGEuY2VudGVyZWRTbGlkZXMpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHogPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2UgPSAwOyBzZSA8IGMubGVuZ3RoOyBzZSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlID0gY1tzZV07XG4gICAgICAgICAgICAgICAgYS5yb3VuZExlbmd0aHMgJiYgKHJlID0gTWF0aC5mbG9vcihyZSkpLFxuICAgICAgICAgICAgICAgICAgY1tzZV0gPCBlLnZpcnR1YWxTaXplICsgY1swXSAmJiB6LnB1c2gocmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGMgPSB6O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAgICAgICAgIHogPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgbmUgPSAwOyBuZSA8IGMubGVuZ3RoOyBuZSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlID0gY1tuZV07XG4gICAgICAgICAgICAgICAgYS5yb3VuZExlbmd0aHMgJiYgKGxlID0gTWF0aC5mbG9vcihsZSkpLFxuICAgICAgICAgICAgICAgICAgY1tuZV0gPD0gZS52aXJ0dWFsU2l6ZSAtIHMgJiYgei5wdXNoKGxlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAoYyA9IHopLFxuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoZS52aXJ0dWFsU2l6ZSAtIHMpIC0gTWF0aC5mbG9vcihjW2MubGVuZ3RoIC0gMV0pID5cbiAgICAgICAgICAgICAgICAgIDEgJiYgYy5wdXNoKGUudmlydHVhbFNpemUgLSBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKDAgPT09IGMubGVuZ3RoICYmIChjID0gWzBdKSxcbiAgICAgICAgICAgICAgMCAhPT0gYS5zcGFjZUJldHdlZW4gJiZcbiAgICAgICAgICAgICAgICAoZS5pc0hvcml6b250YWwoKVxuICAgICAgICAgICAgICAgICAgPyByXG4gICAgICAgICAgICAgICAgICAgID8gcC5maWx0ZXIoZikuY3NzKHsgbWFyZ2luTGVmdDogYiArIFwicHhcIiB9KVxuICAgICAgICAgICAgICAgICAgICA6IHAuZmlsdGVyKGYpLmNzcyh7IG1hcmdpblJpZ2h0OiBiICsgXCJweFwiIH0pXG4gICAgICAgICAgICAgICAgICA6IHAuZmlsdGVyKGYpLmNzcyh7IG1hcmdpbkJvdHRvbTogYiArIFwicHhcIiB9KSksXG4gICAgICAgICAgICAgIGEuY2VudGVyZWRTbGlkZXMgJiYgYS5jZW50ZXJlZFNsaWRlc0JvdW5kcylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgb2UgPSAwO1xuICAgICAgICAgICAgICB2LmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBvZSArPSBlICsgKGEuc3BhY2VCZXR3ZWVuID8gYS5zcGFjZUJldHdlZW4gOiAwKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHZhciBkZSA9IChvZSAtPSBhLnNwYWNlQmV0d2VlbikgLSBzO1xuICAgICAgICAgICAgICBjID0gYy5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZSA8IDAgPyAtbSA6IGUgPiBkZSA/IGRlICsgZyA6IGU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEuY2VudGVySW5zdWZmaWNpZW50U2xpZGVzKSB7XG4gICAgICAgICAgICAgIHZhciBwZSA9IDA7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAodi5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBwZSArPSBlICsgKGEuc3BhY2VCZXR3ZWVuID8gYS5zcGFjZUJldHdlZW4gOiAwKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAocGUgLT0gYS5zcGFjZUJldHdlZW4pIDwgcylcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVlID0gKHMgLSBwZSkgLyAyO1xuICAgICAgICAgICAgICAgIGMuZm9yRWFjaChmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgY1t0XSA9IGUgLSB1ZTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIGguZm9yRWFjaChmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBoW3RdID0gZSArIHVlO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFMoZSwgeyBzbGlkZXM6IHAsIHNuYXBHcmlkOiBjLCBzbGlkZXNHcmlkOiBoLCBzbGlkZXNTaXplc0dyaWQ6IHYgfSksXG4gICAgICAgICAgICAgIHUgIT09IGQgJiYgZS5lbWl0KFwic2xpZGVzTGVuZ3RoQ2hhbmdlXCIpLFxuICAgICAgICAgICAgICBjLmxlbmd0aCAhPT0geSAmJlxuICAgICAgICAgICAgICAgIChlLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIGUuY2hlY2tPdmVyZmxvdygpLFxuICAgICAgICAgICAgICAgIGUuZW1pdChcInNuYXBHcmlkTGVuZ3RoQ2hhbmdlXCIpKSxcbiAgICAgICAgICAgICAgaC5sZW5ndGggIT09IHcgJiYgZS5lbWl0KFwic2xpZGVzR3JpZExlbmd0aENoYW5nZVwiKSxcbiAgICAgICAgICAgICAgKGEud2F0Y2hTbGlkZXNQcm9ncmVzcyB8fCBhLndhdGNoU2xpZGVzVmlzaWJpbGl0eSkgJiZcbiAgICAgICAgICAgICAgICBlLnVwZGF0ZVNsaWRlc09mZnNldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlQXV0b0hlaWdodDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgdCxcbiAgICAgICAgICAgIGEgPSB0aGlzLFxuICAgICAgICAgICAgaSA9IFtdLFxuICAgICAgICAgICAgcyA9IDA7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGVcbiAgICAgICAgICAgICAgPyBhLnNldFRyYW5zaXRpb24oZSlcbiAgICAgICAgICAgICAgOiAhMCA9PT0gZSAmJiBhLnNldFRyYW5zaXRpb24oYS5wYXJhbXMuc3BlZWQpLFxuICAgICAgICAgICAgXCJhdXRvXCIgIT09IGEucGFyYW1zLnNsaWRlc1BlclZpZXcgJiYgYS5wYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKGEucGFyYW1zLmNlbnRlcmVkU2xpZGVzKVxuICAgICAgICAgICAgICBhLnZpc2libGVTbGlkZXMuZWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGkucHVzaChlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGZvciAodCA9IDA7IHQgPCBNYXRoLmNlaWwoYS5wYXJhbXMuc2xpZGVzUGVyVmlldyk7IHQgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciByID0gYS5hY3RpdmVJbmRleCArIHQ7XG4gICAgICAgICAgICAgICAgaWYgKHIgPiBhLnNsaWRlcy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgIGkucHVzaChhLnNsaWRlcy5lcShyKVswXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGkucHVzaChhLnNsaWRlcy5lcShhLmFjdGl2ZUluZGV4KVswXSk7XG4gICAgICAgICAgZm9yICh0ID0gMDsgdCA8IGkubGVuZ3RoOyB0ICs9IDEpXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBpW3RdKSB7XG4gICAgICAgICAgICAgIHZhciBuID0gaVt0XS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgIHMgPSBuID4gcyA/IG4gOiBzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHMgJiYgYS4kd3JhcHBlckVsLmNzcyhcImhlaWdodFwiLCBzICsgXCJweFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlU2xpZGVzT2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMuc2xpZGVzLCB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0ICs9IDEpXG4gICAgICAgICAgICBlW3RdLnN3aXBlclNsaWRlT2Zmc2V0ID0gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgICAgICAgICA/IGVbdF0ub2Zmc2V0TGVmdFxuICAgICAgICAgICAgICA6IGVbdF0ub2Zmc2V0VG9wO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVTbGlkZXNQcm9ncmVzczogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSAodGhpcyAmJiB0aGlzLnRyYW5zbGF0ZSkgfHwgMCk7XG4gICAgICAgICAgdmFyIHQgPSB0aGlzLFxuICAgICAgICAgICAgYSA9IHQucGFyYW1zLFxuICAgICAgICAgICAgaSA9IHQuc2xpZGVzLFxuICAgICAgICAgICAgcyA9IHQucnRsVHJhbnNsYXRlO1xuICAgICAgICAgIGlmICgwICE9PSBpLmxlbmd0aCkge1xuICAgICAgICAgICAgdm9pZCAwID09PSBpWzBdLnN3aXBlclNsaWRlT2Zmc2V0ICYmIHQudXBkYXRlU2xpZGVzT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgciA9IC1lO1xuICAgICAgICAgICAgcyAmJiAociA9IGUpLFxuICAgICAgICAgICAgICBpLnJlbW92ZUNsYXNzKGEuc2xpZGVWaXNpYmxlQ2xhc3MpLFxuICAgICAgICAgICAgICAodC52aXNpYmxlU2xpZGVzSW5kZXhlcyA9IFtdKSxcbiAgICAgICAgICAgICAgKHQudmlzaWJsZVNsaWRlcyA9IFtdKTtcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgbCA9IGlbbl0sXG4gICAgICAgICAgICAgICAgbyA9XG4gICAgICAgICAgICAgICAgICAociArXG4gICAgICAgICAgICAgICAgICAgIChhLmNlbnRlcmVkU2xpZGVzID8gdC5taW5UcmFuc2xhdGUoKSA6IDApIC1cbiAgICAgICAgICAgICAgICAgICAgbC5zd2lwZXJTbGlkZU9mZnNldCkgL1xuICAgICAgICAgICAgICAgICAgKGwuc3dpcGVyU2xpZGVTaXplICsgYS5zcGFjZUJldHdlZW4pO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgYS53YXRjaFNsaWRlc1Zpc2liaWxpdHkgfHxcbiAgICAgICAgICAgICAgICAoYS5jZW50ZXJlZFNsaWRlcyAmJiBhLmF1dG9IZWlnaHQpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gLShyIC0gbC5zd2lwZXJTbGlkZU9mZnNldCksXG4gICAgICAgICAgICAgICAgICBwID0gZCArIHQuc2xpZGVzU2l6ZXNHcmlkW25dO1xuICAgICAgICAgICAgICAgICgoZCA+PSAwICYmIGQgPCB0LnNpemUgLSAxKSB8fFxuICAgICAgICAgICAgICAgICAgKHAgPiAxICYmIHAgPD0gdC5zaXplKSB8fFxuICAgICAgICAgICAgICAgICAgKGQgPD0gMCAmJiBwID49IHQuc2l6ZSkpICYmXG4gICAgICAgICAgICAgICAgICAodC52aXNpYmxlU2xpZGVzLnB1c2gobCksXG4gICAgICAgICAgICAgICAgICB0LnZpc2libGVTbGlkZXNJbmRleGVzLnB1c2gobiksXG4gICAgICAgICAgICAgICAgICBpLmVxKG4pLmFkZENsYXNzKGEuc2xpZGVWaXNpYmxlQ2xhc3MpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsLnByb2dyZXNzID0gcyA/IC1vIDogbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQudmlzaWJsZVNsaWRlcyA9IG0odC52aXNpYmxlU2xpZGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVByb2dyZXNzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgICAgICBpZiAodm9pZCAwID09PSBlKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHQucnRsVHJhbnNsYXRlID8gLTEgOiAxO1xuICAgICAgICAgICAgZSA9ICh0ICYmIHQudHJhbnNsYXRlICYmIHQudHJhbnNsYXRlICogYSkgfHwgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGkgPSB0LnBhcmFtcyxcbiAgICAgICAgICAgIHMgPSB0Lm1heFRyYW5zbGF0ZSgpIC0gdC5taW5UcmFuc2xhdGUoKSxcbiAgICAgICAgICAgIHIgPSB0LnByb2dyZXNzLFxuICAgICAgICAgICAgbiA9IHQuaXNCZWdpbm5pbmcsXG4gICAgICAgICAgICBsID0gdC5pc0VuZCxcbiAgICAgICAgICAgIG8gPSBuLFxuICAgICAgICAgICAgZCA9IGw7XG4gICAgICAgICAgMCA9PT0gc1xuICAgICAgICAgICAgPyAoKHIgPSAwKSwgKG4gPSAhMCksIChsID0gITApKVxuICAgICAgICAgICAgOiAoKG4gPSAociA9IChlIC0gdC5taW5UcmFuc2xhdGUoKSkgLyBzKSA8PSAwKSwgKGwgPSByID49IDEpKSxcbiAgICAgICAgICAgIFModCwgeyBwcm9ncmVzczogciwgaXNCZWdpbm5pbmc6IG4sIGlzRW5kOiBsIH0pLFxuICAgICAgICAgICAgKGkud2F0Y2hTbGlkZXNQcm9ncmVzcyB8fFxuICAgICAgICAgICAgICBpLndhdGNoU2xpZGVzVmlzaWJpbGl0eSB8fFxuICAgICAgICAgICAgICAoaS5jZW50ZXJlZFNsaWRlcyAmJiBpLmF1dG9IZWlnaHQpKSAmJlxuICAgICAgICAgICAgICB0LnVwZGF0ZVNsaWRlc1Byb2dyZXNzKGUpLFxuICAgICAgICAgICAgbiAmJiAhbyAmJiB0LmVtaXQoXCJyZWFjaEJlZ2lubmluZyB0b0VkZ2VcIiksXG4gICAgICAgICAgICBsICYmICFkICYmIHQuZW1pdChcInJlYWNoRW5kIHRvRWRnZVwiKSxcbiAgICAgICAgICAgICgobyAmJiAhbikgfHwgKGQgJiYgIWwpKSAmJiB0LmVtaXQoXCJmcm9tRWRnZVwiKSxcbiAgICAgICAgICAgIHQuZW1pdChcInByb2dyZXNzXCIsIHIpO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVTbGlkZXNDbGFzc2VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGUsXG4gICAgICAgICAgICB0ID0gdGhpcyxcbiAgICAgICAgICAgIGEgPSB0LnNsaWRlcyxcbiAgICAgICAgICAgIGkgPSB0LnBhcmFtcyxcbiAgICAgICAgICAgIHMgPSB0LiR3cmFwcGVyRWwsXG4gICAgICAgICAgICByID0gdC5hY3RpdmVJbmRleCxcbiAgICAgICAgICAgIG4gPSB0LnJlYWxJbmRleCxcbiAgICAgICAgICAgIGwgPSB0LnZpcnR1YWwgJiYgaS52aXJ0dWFsLmVuYWJsZWQ7XG4gICAgICAgICAgYS5yZW1vdmVDbGFzcyhcbiAgICAgICAgICAgIGkuc2xpZGVBY3RpdmVDbGFzcyArXG4gICAgICAgICAgICAgIFwiIFwiICtcbiAgICAgICAgICAgICAgaS5zbGlkZU5leHRDbGFzcyArXG4gICAgICAgICAgICAgIFwiIFwiICtcbiAgICAgICAgICAgICAgaS5zbGlkZVByZXZDbGFzcyArXG4gICAgICAgICAgICAgIFwiIFwiICtcbiAgICAgICAgICAgICAgaS5zbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzICtcbiAgICAgICAgICAgICAgXCIgXCIgK1xuICAgICAgICAgICAgICBpLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzICtcbiAgICAgICAgICAgICAgXCIgXCIgK1xuICAgICAgICAgICAgICBpLnNsaWRlRHVwbGljYXRlUHJldkNsYXNzXG4gICAgICAgICAgKSxcbiAgICAgICAgICAgIChlID0gbFxuICAgICAgICAgICAgICA/IHQuJHdyYXBwZXJFbC5maW5kKFxuICAgICAgICAgICAgICAgICAgXCIuXCIgKyBpLnNsaWRlQ2xhc3MgKyAnW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJyArIHIgKyAnXCJdJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBhLmVxKHIpKS5hZGRDbGFzcyhpLnNsaWRlQWN0aXZlQ2xhc3MpLFxuICAgICAgICAgICAgaS5sb29wICYmXG4gICAgICAgICAgICAgIChlLmhhc0NsYXNzKGkuc2xpZGVEdXBsaWNhdGVDbGFzcylcbiAgICAgICAgICAgICAgICA/IHNcbiAgICAgICAgICAgICAgICAgICAgLmNoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgICAgIFwiLlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkuc2xpZGVDbGFzcyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjpub3QoLlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkuc2xpZGVEdXBsaWNhdGVDbGFzcyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbiArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXCJdJ1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhpLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3MpXG4gICAgICAgICAgICAgICAgOiBzXG4gICAgICAgICAgICAgICAgICAgIC5jaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgICBcIi5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBpLnNsaWRlQ2xhc3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaS5zbGlkZUR1cGxpY2F0ZUNsYXNzICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1wiXSdcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoaS5zbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzKSk7XG4gICAgICAgICAgdmFyIG8gPSBlXG4gICAgICAgICAgICAubmV4dEFsbChcIi5cIiArIGkuc2xpZGVDbGFzcylcbiAgICAgICAgICAgIC5lcSgwKVxuICAgICAgICAgICAgLmFkZENsYXNzKGkuc2xpZGVOZXh0Q2xhc3MpO1xuICAgICAgICAgIGkubG9vcCAmJiAwID09PSBvLmxlbmd0aCAmJiAobyA9IGEuZXEoMCkpLmFkZENsYXNzKGkuc2xpZGVOZXh0Q2xhc3MpO1xuICAgICAgICAgIHZhciBkID0gZVxuICAgICAgICAgICAgLnByZXZBbGwoXCIuXCIgKyBpLnNsaWRlQ2xhc3MpXG4gICAgICAgICAgICAuZXEoMClcbiAgICAgICAgICAgIC5hZGRDbGFzcyhpLnNsaWRlUHJldkNsYXNzKTtcbiAgICAgICAgICBpLmxvb3AgJiYgMCA9PT0gZC5sZW5ndGggJiYgKGQgPSBhLmVxKC0xKSkuYWRkQ2xhc3MoaS5zbGlkZVByZXZDbGFzcyksXG4gICAgICAgICAgICBpLmxvb3AgJiZcbiAgICAgICAgICAgICAgKG8uaGFzQ2xhc3MoaS5zbGlkZUR1cGxpY2F0ZUNsYXNzKVxuICAgICAgICAgICAgICAgID8gc1xuICAgICAgICAgICAgICAgICAgICAuY2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgXCIuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaS5zbGlkZUNsYXNzICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiOm5vdCguXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaS5zbGlkZUR1cGxpY2F0ZUNsYXNzICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcpW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBvLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXCJdJ1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhpLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzKVxuICAgICAgICAgICAgICAgIDogc1xuICAgICAgICAgICAgICAgICAgICAuY2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgXCIuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaS5zbGlkZUNsYXNzICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiLlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkuc2xpZGVEdXBsaWNhdGVDbGFzcyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBvLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXCJdJ1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhpLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzKSxcbiAgICAgICAgICAgICAgZC5oYXNDbGFzcyhpLnNsaWRlRHVwbGljYXRlQ2xhc3MpXG4gICAgICAgICAgICAgICAgPyBzXG4gICAgICAgICAgICAgICAgICAgIC5jaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgICBcIi5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBpLnNsaWRlQ2xhc3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCI6bm90KC5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBpLnNsaWRlRHVwbGljYXRlQ2xhc3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJylbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcIl0nXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGkuc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3MpXG4gICAgICAgICAgICAgICAgOiBzXG4gICAgICAgICAgICAgICAgICAgIC5jaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgICBcIi5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBpLnNsaWRlQ2xhc3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaS5zbGlkZUR1cGxpY2F0ZUNsYXNzICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcIl0nXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGkuc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3MpKSxcbiAgICAgICAgICAgIHQuZW1pdFNsaWRlc0NsYXNzZXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlQWN0aXZlSW5kZXg6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIHQsXG4gICAgICAgICAgICBhID0gdGhpcyxcbiAgICAgICAgICAgIGkgPSBhLnJ0bFRyYW5zbGF0ZSA/IGEudHJhbnNsYXRlIDogLWEudHJhbnNsYXRlLFxuICAgICAgICAgICAgcyA9IGEuc2xpZGVzR3JpZCxcbiAgICAgICAgICAgIHIgPSBhLnNuYXBHcmlkLFxuICAgICAgICAgICAgbiA9IGEucGFyYW1zLFxuICAgICAgICAgICAgbCA9IGEuYWN0aXZlSW5kZXgsXG4gICAgICAgICAgICBvID0gYS5yZWFsSW5kZXgsXG4gICAgICAgICAgICBkID0gYS5zbmFwSW5kZXgsXG4gICAgICAgICAgICBwID0gZTtcbiAgICAgICAgICBpZiAodm9pZCAwID09PSBwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IHMubGVuZ3RoOyB1ICs9IDEpXG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gc1t1ICsgMV1cbiAgICAgICAgICAgICAgICA/IGkgPj0gc1t1XSAmJiBpIDwgc1t1ICsgMV0gLSAoc1t1ICsgMV0gLSBzW3VdKSAvIDJcbiAgICAgICAgICAgICAgICAgID8gKHAgPSB1KVxuICAgICAgICAgICAgICAgICAgOiBpID49IHNbdV0gJiYgaSA8IHNbdSArIDFdICYmIChwID0gdSArIDEpXG4gICAgICAgICAgICAgICAgOiBpID49IHNbdV0gJiYgKHAgPSB1KTtcbiAgICAgICAgICAgIG4ubm9ybWFsaXplU2xpZGVJbmRleCAmJiAocCA8IDAgfHwgdm9pZCAwID09PSBwKSAmJiAocCA9IDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoci5pbmRleE9mKGkpID49IDApIHQgPSByLmluZGV4T2YoaSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYyA9IE1hdGgubWluKG4uc2xpZGVzUGVyR3JvdXBTa2lwLCBwKTtcbiAgICAgICAgICAgIHQgPSBjICsgTWF0aC5mbG9vcigocCAtIGMpIC8gbi5zbGlkZXNQZXJHcm91cCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgodCA+PSByLmxlbmd0aCAmJiAodCA9IHIubGVuZ3RoIC0gMSksIHAgIT09IGwpKSB7XG4gICAgICAgICAgICB2YXIgaCA9IHBhcnNlSW50KFxuICAgICAgICAgICAgICBhLnNsaWRlcy5lcShwKS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIikgfHwgcCxcbiAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBTKGEsIHtcbiAgICAgICAgICAgICAgc25hcEluZGV4OiB0LFxuICAgICAgICAgICAgICByZWFsSW5kZXg6IGgsXG4gICAgICAgICAgICAgIHByZXZpb3VzSW5kZXg6IGwsXG4gICAgICAgICAgICAgIGFjdGl2ZUluZGV4OiBwLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGEuZW1pdChcImFjdGl2ZUluZGV4Q2hhbmdlXCIpLFxuICAgICAgICAgICAgICBhLmVtaXQoXCJzbmFwSW5kZXhDaGFuZ2VcIiksXG4gICAgICAgICAgICAgIG8gIT09IGggJiYgYS5lbWl0KFwicmVhbEluZGV4Q2hhbmdlXCIpLFxuICAgICAgICAgICAgICAoYS5pbml0aWFsaXplZCB8fCBhLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpICYmXG4gICAgICAgICAgICAgICAgYS5lbWl0KFwic2xpZGVDaGFuZ2VcIik7XG4gICAgICAgICAgfSBlbHNlIHQgIT09IGQgJiYgKChhLnNuYXBJbmRleCA9IHQpLCBhLmVtaXQoXCJzbmFwSW5kZXhDaGFuZ2VcIikpO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVDbGlja2VkU2xpZGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIHQgPSB0aGlzLFxuICAgICAgICAgICAgYSA9IHQucGFyYW1zLFxuICAgICAgICAgICAgaSA9IG0oZS50YXJnZXQpLmNsb3Nlc3QoXCIuXCIgKyBhLnNsaWRlQ2xhc3MpWzBdLFxuICAgICAgICAgICAgcyA9ICExO1xuICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0LnNsaWRlcy5sZW5ndGg7IHIgKz0gMSlcbiAgICAgICAgICAgICAgdC5zbGlkZXNbcl0gPT09IGkgJiYgKHMgPSAhMCk7XG4gICAgICAgICAgaWYgKCFpIHx8ICFzKVxuICAgICAgICAgICAgcmV0dXJuICh0LmNsaWNrZWRTbGlkZSA9IHZvaWQgMCksIHZvaWQgKHQuY2xpY2tlZEluZGV4ID0gdm9pZCAwKTtcbiAgICAgICAgICAodC5jbGlja2VkU2xpZGUgPSBpKSxcbiAgICAgICAgICAgIHQudmlydHVhbCAmJiB0LnBhcmFtcy52aXJ0dWFsLmVuYWJsZWRcbiAgICAgICAgICAgICAgPyAodC5jbGlja2VkSW5kZXggPSBwYXJzZUludChcbiAgICAgICAgICAgICAgICAgIG0oaSkuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpLFxuICAgICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA6ICh0LmNsaWNrZWRJbmRleCA9IG0oaSkuaW5kZXgoKSksXG4gICAgICAgICAgICBhLnNsaWRlVG9DbGlja2VkU2xpZGUgJiZcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSB0LmNsaWNrZWRJbmRleCAmJlxuICAgICAgICAgICAgICB0LmNsaWNrZWRJbmRleCAhPT0gdC5hY3RpdmVJbmRleCAmJlxuICAgICAgICAgICAgICB0LnNsaWRlVG9DbGlja2VkU2xpZGUoKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB0cmFuc2xhdGU6IHtcbiAgICAgICAgZ2V0VHJhbnNsYXRlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IHRoaXMuaXNIb3Jpem9udGFsKCkgPyBcInhcIiA6IFwieVwiKTtcbiAgICAgICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgICBhID0gdC5wYXJhbXMsXG4gICAgICAgICAgICBpID0gdC5ydGxUcmFuc2xhdGUsXG4gICAgICAgICAgICBzID0gdC50cmFuc2xhdGUsXG4gICAgICAgICAgICByID0gdC4kd3JhcHBlckVsO1xuICAgICAgICAgIGlmIChhLnZpcnR1YWxUcmFuc2xhdGUpIHJldHVybiBpID8gLXMgOiBzO1xuICAgICAgICAgIGlmIChhLmNzc01vZGUpIHJldHVybiBzO1xuICAgICAgICAgIHZhciBuID0gVChyWzBdLCBlKTtcbiAgICAgICAgICByZXR1cm4gaSAmJiAobiA9IC1uKSwgbiB8fCAwO1xuICAgICAgICB9LFxuICAgICAgICBzZXRUcmFuc2xhdGU6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgaSA9IGEucnRsVHJhbnNsYXRlLFxuICAgICAgICAgICAgcyA9IGEucGFyYW1zLFxuICAgICAgICAgICAgciA9IGEuJHdyYXBwZXJFbCxcbiAgICAgICAgICAgIG4gPSBhLndyYXBwZXJFbCxcbiAgICAgICAgICAgIGwgPSBhLnByb2dyZXNzLFxuICAgICAgICAgICAgbyA9IDAsXG4gICAgICAgICAgICBkID0gMDtcbiAgICAgICAgICBhLmlzSG9yaXpvbnRhbCgpID8gKG8gPSBpID8gLWUgOiBlKSA6IChkID0gZSksXG4gICAgICAgICAgICBzLnJvdW5kTGVuZ3RocyAmJiAoKG8gPSBNYXRoLmZsb29yKG8pKSwgKGQgPSBNYXRoLmZsb29yKGQpKSksXG4gICAgICAgICAgICBzLmNzc01vZGVcbiAgICAgICAgICAgICAgPyAobltcbiAgICAgICAgICAgICAgICAgIGEuaXNIb3Jpem9udGFsKCkgPyBcInNjcm9sbExlZnRcIiA6IFwic2Nyb2xsVG9wXCJcbiAgICAgICAgICAgICAgICBdID0gYS5pc0hvcml6b250YWwoKSA/IC1vIDogLWQpXG4gICAgICAgICAgICAgIDogcy52aXJ0dWFsVHJhbnNsYXRlIHx8XG4gICAgICAgICAgICAgICAgci50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZChcIiArIG8gKyBcInB4LCBcIiArIGQgKyBcInB4LCAwcHgpXCIpLFxuICAgICAgICAgICAgKGEucHJldmlvdXNUcmFuc2xhdGUgPSBhLnRyYW5zbGF0ZSksXG4gICAgICAgICAgICAoYS50cmFuc2xhdGUgPSBhLmlzSG9yaXpvbnRhbCgpID8gbyA6IGQpO1xuICAgICAgICAgIHZhciBwID0gYS5tYXhUcmFuc2xhdGUoKSAtIGEubWluVHJhbnNsYXRlKCk7XG4gICAgICAgICAgKDAgPT09IHAgPyAwIDogKGUgLSBhLm1pblRyYW5zbGF0ZSgpKSAvIHApICE9PSBsICYmXG4gICAgICAgICAgICBhLnVwZGF0ZVByb2dyZXNzKGUpLFxuICAgICAgICAgICAgYS5lbWl0KFwic2V0VHJhbnNsYXRlXCIsIGEudHJhbnNsYXRlLCB0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWluVHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIC10aGlzLnNuYXBHcmlkWzBdO1xuICAgICAgICB9LFxuICAgICAgICBtYXhUcmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gLXRoaXMuc25hcEdyaWRbdGhpcy5zbmFwR3JpZC5sZW5ndGggLSAxXTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNsYXRlVG86IGZ1bmN0aW9uIChlLCB0LCBhLCBpLCBzKSB7XG4gICAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gMCksXG4gICAgICAgICAgICB2b2lkIDAgPT09IHQgJiYgKHQgPSB0aGlzLnBhcmFtcy5zcGVlZCksXG4gICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSAhMCksXG4gICAgICAgICAgICB2b2lkIDAgPT09IGkgJiYgKGkgPSAhMCk7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLFxuICAgICAgICAgICAgbiA9IHIucGFyYW1zLFxuICAgICAgICAgICAgbCA9IHIud3JhcHBlckVsO1xuICAgICAgICAgIGlmIChyLmFuaW1hdGluZyAmJiBuLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbikgcmV0dXJuICExO1xuICAgICAgICAgIHZhciBvLFxuICAgICAgICAgICAgZCA9IHIubWluVHJhbnNsYXRlKCksXG4gICAgICAgICAgICBwID0gci5tYXhUcmFuc2xhdGUoKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoKG8gPSBpICYmIGUgPiBkID8gZCA6IGkgJiYgZSA8IHAgPyBwIDogZSksXG4gICAgICAgICAgICByLnVwZGF0ZVByb2dyZXNzKG8pLFxuICAgICAgICAgICAgbi5jc3NNb2RlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHUsXG4gICAgICAgICAgICAgIGMgPSByLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgICAgICAgaWYgKDAgPT09IHQpIGxbYyA/IFwic2Nyb2xsTGVmdFwiIDogXCJzY3JvbGxUb3BcIl0gPSAtbztcbiAgICAgICAgICAgIGVsc2UgaWYgKGwuc2Nyb2xsVG8pXG4gICAgICAgICAgICAgIGwuc2Nyb2xsVG8oXG4gICAgICAgICAgICAgICAgKCgodSA9IHt9KVtjID8gXCJsZWZ0XCIgOiBcInRvcFwiXSA9IC1vKSxcbiAgICAgICAgICAgICAgICAodS5iZWhhdmlvciA9IFwic21vb3RoXCIpLFxuICAgICAgICAgICAgICAgIHUpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbHNlIGxbYyA/IFwic2Nyb2xsTGVmdFwiIDogXCJzY3JvbGxUb3BcIl0gPSAtbztcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDAgPT09IHRcbiAgICAgICAgICAgICAgPyAoci5zZXRUcmFuc2l0aW9uKDApLFxuICAgICAgICAgICAgICAgIHIuc2V0VHJhbnNsYXRlKG8pLFxuICAgICAgICAgICAgICAgIGEgJiZcbiAgICAgICAgICAgICAgICAgIChyLmVtaXQoXCJiZWZvcmVUcmFuc2l0aW9uU3RhcnRcIiwgdCwgcyksXG4gICAgICAgICAgICAgICAgICByLmVtaXQoXCJ0cmFuc2l0aW9uRW5kXCIpKSlcbiAgICAgICAgICAgICAgOiAoci5zZXRUcmFuc2l0aW9uKHQpLFxuICAgICAgICAgICAgICAgIHIuc2V0VHJhbnNsYXRlKG8pLFxuICAgICAgICAgICAgICAgIGEgJiZcbiAgICAgICAgICAgICAgICAgIChyLmVtaXQoXCJiZWZvcmVUcmFuc2l0aW9uU3RhcnRcIiwgdCwgcyksXG4gICAgICAgICAgICAgICAgICByLmVtaXQoXCJ0cmFuc2l0aW9uU3RhcnRcIikpLFxuICAgICAgICAgICAgICAgIHIuYW5pbWF0aW5nIHx8XG4gICAgICAgICAgICAgICAgICAoKHIuYW5pbWF0aW5nID0gITApLFxuICAgICAgICAgICAgICAgICAgci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgfHxcbiAgICAgICAgICAgICAgICAgICAgKHIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhci5kZXN0cm95ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0ID09PSB0aGlzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwidHJhbnNpdGlvbmVuZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIndlYmtpdFRyYW5zaXRpb25FbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAoci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgJiYgci5lbWl0KFwidHJhbnNpdGlvbkVuZFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgICAgIFwidHJhbnNpdGlvbmVuZFwiLFxuICAgICAgICAgICAgICAgICAgICByLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHIuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICAgICAgICBcIndlYmtpdFRyYW5zaXRpb25FbmRcIixcbiAgICAgICAgICAgICAgICAgICAgci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmRcbiAgICAgICAgICAgICAgICAgICkpKSxcbiAgICAgICAgICAgICEwXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB0cmFuc2l0aW9uOiB7XG4gICAgICAgIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgIGEucGFyYW1zLmNzc01vZGUgfHwgYS4kd3JhcHBlckVsLnRyYW5zaXRpb24oZSksXG4gICAgICAgICAgICBhLmVtaXQoXCJzZXRUcmFuc2l0aW9uXCIsIGUsIHQpO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2l0aW9uU3RhcnQ6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gITApO1xuICAgICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGkgPSBhLmFjdGl2ZUluZGV4LFxuICAgICAgICAgICAgcyA9IGEucGFyYW1zLFxuICAgICAgICAgICAgciA9IGEucHJldmlvdXNJbmRleDtcbiAgICAgICAgICBpZiAoIXMuY3NzTW9kZSkge1xuICAgICAgICAgICAgcy5hdXRvSGVpZ2h0ICYmIGEudXBkYXRlQXV0b0hlaWdodCgpO1xuICAgICAgICAgICAgdmFyIG4gPSB0O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAobiB8fCAobiA9IGkgPiByID8gXCJuZXh0XCIgOiBpIDwgciA/IFwicHJldlwiIDogXCJyZXNldFwiKSxcbiAgICAgICAgICAgICAgYS5lbWl0KFwidHJhbnNpdGlvblN0YXJ0XCIpLFxuICAgICAgICAgICAgICBlICYmIGkgIT09IHIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKFwicmVzZXRcIiA9PT0gbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCBhLmVtaXQoXCJzbGlkZVJlc2V0VHJhbnNpdGlvblN0YXJ0XCIpO1xuICAgICAgICAgICAgICBhLmVtaXQoXCJzbGlkZUNoYW5nZVRyYW5zaXRpb25TdGFydFwiKSxcbiAgICAgICAgICAgICAgICBcIm5leHRcIiA9PT0gblxuICAgICAgICAgICAgICAgICAgPyBhLmVtaXQoXCJzbGlkZU5leHRUcmFuc2l0aW9uU3RhcnRcIilcbiAgICAgICAgICAgICAgICAgIDogYS5lbWl0KFwic2xpZGVQcmV2VHJhbnNpdGlvblN0YXJ0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSAhMCk7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgaSA9IGEuYWN0aXZlSW5kZXgsXG4gICAgICAgICAgICBzID0gYS5wcmV2aW91c0luZGV4LFxuICAgICAgICAgICAgciA9IGEucGFyYW1zO1xuICAgICAgICAgIGlmICgoKGEuYW5pbWF0aW5nID0gITEpLCAhci5jc3NNb2RlKSkge1xuICAgICAgICAgICAgYS5zZXRUcmFuc2l0aW9uKDApO1xuICAgICAgICAgICAgdmFyIG4gPSB0O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAobiB8fCAobiA9IGkgPiBzID8gXCJuZXh0XCIgOiBpIDwgcyA/IFwicHJldlwiIDogXCJyZXNldFwiKSxcbiAgICAgICAgICAgICAgYS5lbWl0KFwidHJhbnNpdGlvbkVuZFwiKSxcbiAgICAgICAgICAgICAgZSAmJiBpICE9PSBzKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmIChcInJlc2V0XCIgPT09IG4pIHJldHVybiB2b2lkIGEuZW1pdChcInNsaWRlUmVzZXRUcmFuc2l0aW9uRW5kXCIpO1xuICAgICAgICAgICAgICBhLmVtaXQoXCJzbGlkZUNoYW5nZVRyYW5zaXRpb25FbmRcIiksXG4gICAgICAgICAgICAgICAgXCJuZXh0XCIgPT09IG5cbiAgICAgICAgICAgICAgICAgID8gYS5lbWl0KFwic2xpZGVOZXh0VHJhbnNpdGlvbkVuZFwiKVxuICAgICAgICAgICAgICAgICAgOiBhLmVtaXQoXCJzbGlkZVByZXZUcmFuc2l0aW9uRW5kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBzbGlkZToge1xuICAgICAgICBzbGlkZVRvOiBmdW5jdGlvbiAoZSwgdCwgYSwgaSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICh2b2lkIDAgPT09IGUgJiYgKGUgPSAwKSxcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gdCAmJiAodCA9IHRoaXMucGFyYW1zLnNwZWVkKSxcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gYSAmJiAoYSA9ICEwKSxcbiAgICAgICAgICAgIFwibnVtYmVyXCIgIT0gdHlwZW9mIGUgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlICdpbmRleCcgYXJndW1lbnQgY2Fubm90IGhhdmUgdHlwZSBvdGhlciB0aGFuICdudW1iZXInIG9yICdzdHJpbmcnLiBbXCIgK1xuICAgICAgICAgICAgICAgIHR5cGVvZiBlICtcbiAgICAgICAgICAgICAgICBcIl0gZ2l2ZW4uXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICAgICAgICAgIHZhciBzID0gcGFyc2VJbnQoZSwgMTApO1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShzKSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiVGhlIHBhc3NlZC1pbiAnaW5kZXgnIChzdHJpbmcpIGNvdWxkbid0IGJlIGNvbnZlcnRlZCB0byAnbnVtYmVyJy4gW1wiICtcbiAgICAgICAgICAgICAgICAgIGUgK1xuICAgICAgICAgICAgICAgICAgXCJdIGdpdmVuLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlID0gcztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLFxuICAgICAgICAgICAgbiA9IGU7XG4gICAgICAgICAgbiA8IDAgJiYgKG4gPSAwKTtcbiAgICAgICAgICB2YXIgbCA9IHIucGFyYW1zLFxuICAgICAgICAgICAgbyA9IHIuc25hcEdyaWQsXG4gICAgICAgICAgICBkID0gci5zbGlkZXNHcmlkLFxuICAgICAgICAgICAgcCA9IHIucHJldmlvdXNJbmRleCxcbiAgICAgICAgICAgIHUgPSByLmFjdGl2ZUluZGV4LFxuICAgICAgICAgICAgYyA9IHIucnRsVHJhbnNsYXRlLFxuICAgICAgICAgICAgaCA9IHIud3JhcHBlckVsO1xuICAgICAgICAgIGlmIChyLmFuaW1hdGluZyAmJiBsLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbikgcmV0dXJuICExO1xuICAgICAgICAgIHZhciB2ID0gTWF0aC5taW4oci5wYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLCBuKSxcbiAgICAgICAgICAgIGYgPSB2ICsgTWF0aC5mbG9vcigobiAtIHYpIC8gci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICAgICAgICAgIGYgPj0gby5sZW5ndGggJiYgKGYgPSBvLmxlbmd0aCAtIDEpLFxuICAgICAgICAgICAgKHUgfHwgbC5pbml0aWFsU2xpZGUgfHwgMCkgPT09IChwIHx8IDApICYmXG4gICAgICAgICAgICAgIGEgJiZcbiAgICAgICAgICAgICAgci5lbWl0KFwiYmVmb3JlU2xpZGVDaGFuZ2VTdGFydFwiKTtcbiAgICAgICAgICB2YXIgbSxcbiAgICAgICAgICAgIGcgPSAtb1tmXTtcbiAgICAgICAgICBpZiAoKHIudXBkYXRlUHJvZ3Jlc3MoZyksIGwubm9ybWFsaXplU2xpZGVJbmRleCkpXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGQubGVuZ3RoOyB5ICs9IDEpXG4gICAgICAgICAgICAgIC1NYXRoLmZsb29yKDEwMCAqIGcpID49IE1hdGguZmxvb3IoMTAwICogZFt5XSkgJiYgKG4gPSB5KTtcbiAgICAgICAgICBpZiAoci5pbml0aWFsaXplZCAmJiBuICE9PSB1KSB7XG4gICAgICAgICAgICBpZiAoIXIuYWxsb3dTbGlkZU5leHQgJiYgZyA8IHIudHJhbnNsYXRlICYmIGcgPCByLm1pblRyYW5zbGF0ZSgpKVxuICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICFyLmFsbG93U2xpZGVQcmV2ICYmXG4gICAgICAgICAgICAgIGcgPiByLnRyYW5zbGF0ZSAmJlxuICAgICAgICAgICAgICBnID4gci5tYXhUcmFuc2xhdGUoKSAmJlxuICAgICAgICAgICAgICAodSB8fCAwKSAhPT0gblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICgobSA9IG4gPiB1ID8gXCJuZXh0XCIgOiBuIDwgdSA/IFwicHJldlwiIDogXCJyZXNldFwiKSxcbiAgICAgICAgICAgIChjICYmIC1nID09PSByLnRyYW5zbGF0ZSkgfHwgKCFjICYmIGcgPT09IHIudHJhbnNsYXRlKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICByLnVwZGF0ZUFjdGl2ZUluZGV4KG4pLFxuICAgICAgICAgICAgICBsLmF1dG9IZWlnaHQgJiYgci51cGRhdGVBdXRvSGVpZ2h0KCksXG4gICAgICAgICAgICAgIHIudXBkYXRlU2xpZGVzQ2xhc3NlcygpLFxuICAgICAgICAgICAgICBcInNsaWRlXCIgIT09IGwuZWZmZWN0ICYmIHIuc2V0VHJhbnNsYXRlKGcpLFxuICAgICAgICAgICAgICBcInJlc2V0XCIgIT09IG0gJiYgKHIudHJhbnNpdGlvblN0YXJ0KGEsIG0pLCByLnRyYW5zaXRpb25FbmQoYSwgbSkpLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobC5jc3NNb2RlKSB7XG4gICAgICAgICAgICB2YXIgdyxcbiAgICAgICAgICAgICAgYiA9IHIuaXNIb3Jpem9udGFsKCksXG4gICAgICAgICAgICAgIEUgPSAtZztcbiAgICAgICAgICAgIGlmICgoYyAmJiAoRSA9IGguc2Nyb2xsV2lkdGggLSBoLm9mZnNldFdpZHRoIC0gRSksIDAgPT09IHQpKVxuICAgICAgICAgICAgICBoW2IgPyBcInNjcm9sbExlZnRcIiA6IFwic2Nyb2xsVG9wXCJdID0gRTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGguc2Nyb2xsVG8pXG4gICAgICAgICAgICAgIGguc2Nyb2xsVG8oXG4gICAgICAgICAgICAgICAgKCgodyA9IHt9KVtiID8gXCJsZWZ0XCIgOiBcInRvcFwiXSA9IEUpLCAody5iZWhhdmlvciA9IFwic21vb3RoXCIpLCB3KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxzZSBoW2IgPyBcInNjcm9sbExlZnRcIiA6IFwic2Nyb2xsVG9wXCJdID0gRTtcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDAgPT09IHRcbiAgICAgICAgICAgICAgPyAoci5zZXRUcmFuc2l0aW9uKDApLFxuICAgICAgICAgICAgICAgIHIuc2V0VHJhbnNsYXRlKGcpLFxuICAgICAgICAgICAgICAgIHIudXBkYXRlQWN0aXZlSW5kZXgobiksXG4gICAgICAgICAgICAgICAgci51cGRhdGVTbGlkZXNDbGFzc2VzKCksXG4gICAgICAgICAgICAgICAgci5lbWl0KFwiYmVmb3JlVHJhbnNpdGlvblN0YXJ0XCIsIHQsIGkpLFxuICAgICAgICAgICAgICAgIHIudHJhbnNpdGlvblN0YXJ0KGEsIG0pLFxuICAgICAgICAgICAgICAgIHIudHJhbnNpdGlvbkVuZChhLCBtKSlcbiAgICAgICAgICAgICAgOiAoci5zZXRUcmFuc2l0aW9uKHQpLFxuICAgICAgICAgICAgICAgIHIuc2V0VHJhbnNsYXRlKGcpLFxuICAgICAgICAgICAgICAgIHIudXBkYXRlQWN0aXZlSW5kZXgobiksXG4gICAgICAgICAgICAgICAgci51cGRhdGVTbGlkZXNDbGFzc2VzKCksXG4gICAgICAgICAgICAgICAgci5lbWl0KFwiYmVmb3JlVHJhbnNpdGlvblN0YXJ0XCIsIHQsIGkpLFxuICAgICAgICAgICAgICAgIHIudHJhbnNpdGlvblN0YXJ0KGEsIG0pLFxuICAgICAgICAgICAgICAgIHIuYW5pbWF0aW5nIHx8XG4gICAgICAgICAgICAgICAgICAoKHIuYW5pbWF0aW5nID0gITApLFxuICAgICAgICAgICAgICAgICAgci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCB8fFxuICAgICAgICAgICAgICAgICAgICAoci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXIuZGVzdHJveWVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldCA9PT0gdGhpcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHIuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInRyYW5zaXRpb25lbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIndlYmtpdFRyYW5zaXRpb25FbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIudHJhbnNpdGlvbkVuZChhLCBtKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgICAgIFwidHJhbnNpdGlvbmVuZFwiLFxuICAgICAgICAgICAgICAgICAgICByLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgICAgIFwid2Via2l0VHJhbnNpdGlvbkVuZFwiLFxuICAgICAgICAgICAgICAgICAgICByLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kXG4gICAgICAgICAgICAgICAgICApKSksXG4gICAgICAgICAgICAhMFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHNsaWRlVG9Mb29wOiBmdW5jdGlvbiAoZSwgdCwgYSwgaSkge1xuICAgICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IDApLFxuICAgICAgICAgICAgdm9pZCAwID09PSB0ICYmICh0ID0gdGhpcy5wYXJhbXMuc3BlZWQpLFxuICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gITApO1xuICAgICAgICAgIHZhciBzID0gdGhpcyxcbiAgICAgICAgICAgIHIgPSBlO1xuICAgICAgICAgIHJldHVybiBzLnBhcmFtcy5sb29wICYmIChyICs9IHMubG9vcGVkU2xpZGVzKSwgcy5zbGlkZVRvKHIsIHQsIGEsIGkpO1xuICAgICAgICB9LFxuICAgICAgICBzbGlkZU5leHQ6IGZ1bmN0aW9uIChlLCB0LCBhKSB7XG4gICAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gdGhpcy5wYXJhbXMuc3BlZWQpLCB2b2lkIDAgPT09IHQgJiYgKHQgPSAhMCk7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLFxuICAgICAgICAgICAgcyA9IGkucGFyYW1zLFxuICAgICAgICAgICAgciA9IGkuYW5pbWF0aW5nLFxuICAgICAgICAgICAgbiA9IGkuYWN0aXZlSW5kZXggPCBzLnNsaWRlc1Blckdyb3VwU2tpcCA/IDEgOiBzLnNsaWRlc1Blckdyb3VwO1xuICAgICAgICAgIGlmIChzLmxvb3ApIHtcbiAgICAgICAgICAgIGlmIChyICYmIHMubG9vcFByZXZlbnRzU2xpZGUpIHJldHVybiAhMTtcbiAgICAgICAgICAgIGkubG9vcEZpeCgpLCAoaS5fY2xpZW50TGVmdCA9IGkuJHdyYXBwZXJFbFswXS5jbGllbnRMZWZ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGkuc2xpZGVUbyhpLmFjdGl2ZUluZGV4ICsgbiwgZSwgdCwgYSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNsaWRlUHJldjogZnVuY3Rpb24gKGUsIHQsIGEpIHtcbiAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSB0aGlzLnBhcmFtcy5zcGVlZCksIHZvaWQgMCA9PT0gdCAmJiAodCA9ICEwKTtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMsXG4gICAgICAgICAgICBzID0gaS5wYXJhbXMsXG4gICAgICAgICAgICByID0gaS5hbmltYXRpbmcsXG4gICAgICAgICAgICBuID0gaS5zbmFwR3JpZCxcbiAgICAgICAgICAgIGwgPSBpLnNsaWRlc0dyaWQsXG4gICAgICAgICAgICBvID0gaS5ydGxUcmFuc2xhdGU7XG4gICAgICAgICAgaWYgKHMubG9vcCkge1xuICAgICAgICAgICAgaWYgKHIgJiYgcy5sb29wUHJldmVudHNTbGlkZSkgcmV0dXJuICExO1xuICAgICAgICAgICAgaS5sb29wRml4KCksIChpLl9jbGllbnRMZWZ0ID0gaS4kd3JhcHBlckVsWzBdLmNsaWVudExlZnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBkKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlIDwgMCA/IC1NYXRoLmZsb29yKE1hdGguYWJzKGUpKSA6IE1hdGguZmxvb3IoZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwLFxuICAgICAgICAgICAgdSA9IGQobyA/IGkudHJhbnNsYXRlIDogLWkudHJhbnNsYXRlKSxcbiAgICAgICAgICAgIGMgPSBuLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZChlKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaCA9IChuW2MuaW5kZXhPZih1KV0sIG5bYy5pbmRleE9mKHUpIC0gMV0pO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB2b2lkIDAgPT09IGggJiZcbiAgICAgICAgICAgICAgcy5jc3NNb2RlICYmXG4gICAgICAgICAgICAgIG4uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICFoICYmIHUgPj0gZSAmJiAoaCA9IGUpO1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gaCAmJiAocCA9IGwuaW5kZXhPZihoKSkgPCAwICYmIChwID0gaS5hY3RpdmVJbmRleCAtIDEpLFxuICAgICAgICAgICAgaS5zbGlkZVRvKHAsIGUsIHQsIGEpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2xpZGVSZXNldDogZnVuY3Rpb24gKGUsIHQsIGEpIHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gdGhpcy5wYXJhbXMuc3BlZWQpLFxuICAgICAgICAgICAgdm9pZCAwID09PSB0ICYmICh0ID0gITApLFxuICAgICAgICAgICAgdGhpcy5zbGlkZVRvKHRoaXMuYWN0aXZlSW5kZXgsIGUsIHQsIGEpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2xpZGVUb0Nsb3Nlc3Q6IGZ1bmN0aW9uIChlLCB0LCBhLCBpKSB7XG4gICAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gdGhpcy5wYXJhbXMuc3BlZWQpLFxuICAgICAgICAgICAgdm9pZCAwID09PSB0ICYmICh0ID0gITApLFxuICAgICAgICAgICAgdm9pZCAwID09PSBpICYmIChpID0gMC41KTtcbiAgICAgICAgICB2YXIgcyA9IHRoaXMsXG4gICAgICAgICAgICByID0gcy5hY3RpdmVJbmRleCxcbiAgICAgICAgICAgIG4gPSBNYXRoLm1pbihzLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIHIpLFxuICAgICAgICAgICAgbCA9IG4gKyBNYXRoLmZsb29yKChyIC0gbikgLyBzLnBhcmFtcy5zbGlkZXNQZXJHcm91cCksXG4gICAgICAgICAgICBvID0gcy5ydGxUcmFuc2xhdGUgPyBzLnRyYW5zbGF0ZSA6IC1zLnRyYW5zbGF0ZTtcbiAgICAgICAgICBpZiAobyA+PSBzLnNuYXBHcmlkW2xdKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHMuc25hcEdyaWRbbF07XG4gICAgICAgICAgICBvIC0gZCA+IChzLnNuYXBHcmlkW2wgKyAxXSAtIGQpICogaSAmJlxuICAgICAgICAgICAgICAociArPSBzLnBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwID0gcy5zbmFwR3JpZFtsIC0gMV07XG4gICAgICAgICAgICBvIC0gcCA8PSAocy5zbmFwR3JpZFtsXSAtIHApICogaSAmJiAociAtPSBzLnBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAociA9IE1hdGgubWF4KHIsIDApKSxcbiAgICAgICAgICAgIChyID0gTWF0aC5taW4ociwgcy5zbGlkZXNHcmlkLmxlbmd0aCAtIDEpKSxcbiAgICAgICAgICAgIHMuc2xpZGVUbyhyLCBlLCB0LCBhKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHNsaWRlVG9DbGlja2VkU2xpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZSxcbiAgICAgICAgICAgIHQgPSB0aGlzLFxuICAgICAgICAgICAgYSA9IHQucGFyYW1zLFxuICAgICAgICAgICAgaSA9IHQuJHdyYXBwZXJFbCxcbiAgICAgICAgICAgIHMgPVxuICAgICAgICAgICAgICBcImF1dG9cIiA9PT0gYS5zbGlkZXNQZXJWaWV3XG4gICAgICAgICAgICAgICAgPyB0LnNsaWRlc1BlclZpZXdEeW5hbWljKClcbiAgICAgICAgICAgICAgICA6IGEuc2xpZGVzUGVyVmlldyxcbiAgICAgICAgICAgIHIgPSB0LmNsaWNrZWRJbmRleDtcbiAgICAgICAgICBpZiAoYS5sb29wKSB7XG4gICAgICAgICAgICBpZiAodC5hbmltYXRpbmcpIHJldHVybjtcbiAgICAgICAgICAgIChlID0gcGFyc2VJbnQoXG4gICAgICAgICAgICAgIG0odC5jbGlja2VkU2xpZGUpLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSxcbiAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBhLmNlbnRlcmVkU2xpZGVzXG4gICAgICAgICAgICAgICAgPyByIDwgdC5sb29wZWRTbGlkZXMgLSBzIC8gMiB8fFxuICAgICAgICAgICAgICAgICAgciA+IHQuc2xpZGVzLmxlbmd0aCAtIHQubG9vcGVkU2xpZGVzICsgcyAvIDJcbiAgICAgICAgICAgICAgICAgID8gKHQubG9vcEZpeCgpLFxuICAgICAgICAgICAgICAgICAgICAociA9IGlcbiAgICAgICAgICAgICAgICAgICAgICAuY2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICBcIi5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGEuc2xpZGVDbGFzcyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdcIl06bm90KC4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYS5zbGlkZUR1cGxpY2F0ZUNsYXNzICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCIpXCJcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgLmVxKDApXG4gICAgICAgICAgICAgICAgICAgICAgLmluZGV4KCkpLFxuICAgICAgICAgICAgICAgICAgICBFKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0LnNsaWRlVG8ocik7XG4gICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgOiB0LnNsaWRlVG8ocilcbiAgICAgICAgICAgICAgICA6IHIgPiB0LnNsaWRlcy5sZW5ndGggLSBzXG4gICAgICAgICAgICAgICAgPyAodC5sb29wRml4KCksXG4gICAgICAgICAgICAgICAgICAociA9IGlcbiAgICAgICAgICAgICAgICAgICAgLmNoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgICAgIFwiLlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuc2xpZGVDbGFzcyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcIl06bm90KC4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuc2xpZGVEdXBsaWNhdGVDbGFzcyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIilcIlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC5lcSgwKVxuICAgICAgICAgICAgICAgICAgICAuaW5kZXgoKSksXG4gICAgICAgICAgICAgICAgICBFKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5zbGlkZVRvKHIpO1xuICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgOiB0LnNsaWRlVG8ocik7XG4gICAgICAgICAgfSBlbHNlIHQuc2xpZGVUbyhyKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBsb29wOiB7XG4gICAgICAgIGxvb3BDcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgICB0ID0gcigpLFxuICAgICAgICAgICAgYSA9IGUucGFyYW1zLFxuICAgICAgICAgICAgaSA9IGUuJHdyYXBwZXJFbDtcbiAgICAgICAgICBpLmNoaWxkcmVuKFwiLlwiICsgYS5zbGlkZUNsYXNzICsgXCIuXCIgKyBhLnNsaWRlRHVwbGljYXRlQ2xhc3MpLnJlbW92ZSgpO1xuICAgICAgICAgIHZhciBzID0gaS5jaGlsZHJlbihcIi5cIiArIGEuc2xpZGVDbGFzcyk7XG4gICAgICAgICAgaWYgKGEubG9vcEZpbGxHcm91cFdpdGhCbGFuaykge1xuICAgICAgICAgICAgdmFyIG4gPSBhLnNsaWRlc1Blckdyb3VwIC0gKHMubGVuZ3RoICUgYS5zbGlkZXNQZXJHcm91cCk7XG4gICAgICAgICAgICBpZiAobiAhPT0gYS5zbGlkZXNQZXJHcm91cCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IG47IGwgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBvID0gbSh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLmFkZENsYXNzKFxuICAgICAgICAgICAgICAgICAgYS5zbGlkZUNsYXNzICsgXCIgXCIgKyBhLnNsaWRlQmxhbmtDbGFzc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaS5hcHBlbmQobyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcyA9IGkuY2hpbGRyZW4oXCIuXCIgKyBhLnNsaWRlQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcImF1dG9cIiAhPT0gYS5zbGlkZXNQZXJWaWV3IHx8XG4gICAgICAgICAgICBhLmxvb3BlZFNsaWRlcyB8fFxuICAgICAgICAgICAgKGEubG9vcGVkU2xpZGVzID0gcy5sZW5ndGgpLFxuICAgICAgICAgICAgKGUubG9vcGVkU2xpZGVzID0gTWF0aC5jZWlsKFxuICAgICAgICAgICAgICBwYXJzZUZsb2F0KGEubG9vcGVkU2xpZGVzIHx8IGEuc2xpZGVzUGVyVmlldywgMTApXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChlLmxvb3BlZFNsaWRlcyArPSBhLmxvb3BBZGRpdGlvbmFsU2xpZGVzKSxcbiAgICAgICAgICAgIGUubG9vcGVkU2xpZGVzID4gcy5sZW5ndGggJiYgKGUubG9vcGVkU2xpZGVzID0gcy5sZW5ndGgpO1xuICAgICAgICAgIHZhciBkID0gW10sXG4gICAgICAgICAgICBwID0gW107XG4gICAgICAgICAgcy5lYWNoKGZ1bmN0aW9uICh0LCBhKSB7XG4gICAgICAgICAgICB2YXIgaSA9IG0odCk7XG4gICAgICAgICAgICBhIDwgZS5sb29wZWRTbGlkZXMgJiYgcC5wdXNoKHQpLFxuICAgICAgICAgICAgICBhIDwgcy5sZW5ndGggJiYgYSA+PSBzLmxlbmd0aCAtIGUubG9vcGVkU2xpZGVzICYmIGQucHVzaCh0KSxcbiAgICAgICAgICAgICAgaS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIiwgYSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBwLmxlbmd0aDsgdSArPSAxKVxuICAgICAgICAgICAgaS5hcHBlbmQobShwW3VdLmNsb25lTm9kZSghMCkpLmFkZENsYXNzKGEuc2xpZGVEdXBsaWNhdGVDbGFzcykpO1xuICAgICAgICAgIGZvciAodmFyIGMgPSBkLmxlbmd0aCAtIDE7IGMgPj0gMDsgYyAtPSAxKVxuICAgICAgICAgICAgaS5wcmVwZW5kKG0oZFtjXS5jbG9uZU5vZGUoITApKS5hZGRDbGFzcyhhLnNsaWRlRHVwbGljYXRlQ2xhc3MpKTtcbiAgICAgICAgfSxcbiAgICAgICAgbG9vcEZpeDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgICBlLmVtaXQoXCJiZWZvcmVMb29wRml4XCIpO1xuICAgICAgICAgIHZhciB0LFxuICAgICAgICAgICAgYSA9IGUuYWN0aXZlSW5kZXgsXG4gICAgICAgICAgICBpID0gZS5zbGlkZXMsXG4gICAgICAgICAgICBzID0gZS5sb29wZWRTbGlkZXMsXG4gICAgICAgICAgICByID0gZS5hbGxvd1NsaWRlUHJldixcbiAgICAgICAgICAgIG4gPSBlLmFsbG93U2xpZGVOZXh0LFxuICAgICAgICAgICAgbCA9IGUuc25hcEdyaWQsXG4gICAgICAgICAgICBvID0gZS5ydGxUcmFuc2xhdGU7XG4gICAgICAgICAgKGUuYWxsb3dTbGlkZVByZXYgPSAhMCksIChlLmFsbG93U2xpZGVOZXh0ID0gITApO1xuICAgICAgICAgIHZhciBkID0gLWxbYV0gLSBlLmdldFRyYW5zbGF0ZSgpO1xuICAgICAgICAgIGlmIChhIDwgcylcbiAgICAgICAgICAgICh0ID0gaS5sZW5ndGggLSAzICogcyArIGEpLFxuICAgICAgICAgICAgICAodCArPSBzKSxcbiAgICAgICAgICAgICAgZS5zbGlkZVRvKHQsIDAsICExLCAhMCkgJiZcbiAgICAgICAgICAgICAgICAwICE9PSBkICYmXG4gICAgICAgICAgICAgICAgZS5zZXRUcmFuc2xhdGUoKG8gPyAtZS50cmFuc2xhdGUgOiBlLnRyYW5zbGF0ZSkgLSBkKTtcbiAgICAgICAgICBlbHNlIGlmIChhID49IGkubGVuZ3RoIC0gcykge1xuICAgICAgICAgICAgKHQgPSAtaS5sZW5ndGggKyBhICsgcyksXG4gICAgICAgICAgICAgICh0ICs9IHMpLFxuICAgICAgICAgICAgICBlLnNsaWRlVG8odCwgMCwgITEsICEwKSAmJlxuICAgICAgICAgICAgICAgIDAgIT09IGQgJiZcbiAgICAgICAgICAgICAgICBlLnNldFRyYW5zbGF0ZSgobyA/IC1lLnRyYW5zbGF0ZSA6IGUudHJhbnNsYXRlKSAtIGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoZS5hbGxvd1NsaWRlUHJldiA9IHIpLCAoZS5hbGxvd1NsaWRlTmV4dCA9IG4pLCBlLmVtaXQoXCJsb29wRml4XCIpO1xuICAgICAgICB9LFxuICAgICAgICBsb29wRGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICAgIHQgPSBlLiR3cmFwcGVyRWwsXG4gICAgICAgICAgICBhID0gZS5wYXJhbXMsXG4gICAgICAgICAgICBpID0gZS5zbGlkZXM7XG4gICAgICAgICAgdFxuICAgICAgICAgICAgLmNoaWxkcmVuKFxuICAgICAgICAgICAgICBcIi5cIiArXG4gICAgICAgICAgICAgICAgYS5zbGlkZUNsYXNzICtcbiAgICAgICAgICAgICAgICBcIi5cIiArXG4gICAgICAgICAgICAgICAgYS5zbGlkZUR1cGxpY2F0ZUNsYXNzICtcbiAgICAgICAgICAgICAgICBcIiwuXCIgK1xuICAgICAgICAgICAgICAgIGEuc2xpZGVDbGFzcyArXG4gICAgICAgICAgICAgICAgXCIuXCIgK1xuICAgICAgICAgICAgICAgIGEuc2xpZGVCbGFua0NsYXNzXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAucmVtb3ZlKCksXG4gICAgICAgICAgICBpLnJlbW92ZUF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBncmFiQ3Vyc29yOiB7XG4gICAgICAgIHNldEdyYWJDdXJzb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgIHQuc3VwcG9ydC50b3VjaCB8fFxuICAgICAgICAgICAgICAhdC5wYXJhbXMuc2ltdWxhdGVUb3VjaCB8fFxuICAgICAgICAgICAgICAodC5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiB0LmlzTG9ja2VkKSB8fFxuICAgICAgICAgICAgICB0LnBhcmFtcy5jc3NNb2RlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHQuZWw7XG4gICAgICAgICAgICAoYS5zdHlsZS5jdXJzb3IgPSBcIm1vdmVcIiksXG4gICAgICAgICAgICAgIChhLnN0eWxlLmN1cnNvciA9IGUgPyBcIi13ZWJraXQtZ3JhYmJpbmdcIiA6IFwiLXdlYmtpdC1ncmFiXCIpLFxuICAgICAgICAgICAgICAoYS5zdHlsZS5jdXJzb3IgPSBlID8gXCItbW96LWdyYWJiaW5cIiA6IFwiLW1vei1ncmFiXCIpLFxuICAgICAgICAgICAgICAoYS5zdHlsZS5jdXJzb3IgPSBlID8gXCJncmFiYmluZ1wiIDogXCJncmFiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdW5zZXRHcmFiQ3Vyc29yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICAgIGUuc3VwcG9ydC50b3VjaCB8fFxuICAgICAgICAgICAgKGUucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgZS5pc0xvY2tlZCkgfHxcbiAgICAgICAgICAgIGUucGFyYW1zLmNzc01vZGUgfHxcbiAgICAgICAgICAgIChlLmVsLnN0eWxlLmN1cnNvciA9IFwiXCIpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIG1hbmlwdWxhdGlvbjoge1xuICAgICAgICBhcHBlbmRTbGlkZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgICBhID0gdC4kd3JhcHBlckVsLFxuICAgICAgICAgICAgaSA9IHQucGFyYW1zO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChpLmxvb3AgJiYgdC5sb29wRGVzdHJveSgpLCBcIm9iamVjdFwiID09IHR5cGVvZiBlICYmIFwibGVuZ3RoXCIgaW4gZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IGUubGVuZ3RoOyBzICs9IDEpIGVbc10gJiYgYS5hcHBlbmQoZVtzXSk7XG4gICAgICAgICAgZWxzZSBhLmFwcGVuZChlKTtcbiAgICAgICAgICBpLmxvb3AgJiYgdC5sb29wQ3JlYXRlKCksXG4gICAgICAgICAgICAoaS5vYnNlcnZlciAmJiB0LnN1cHBvcnQub2JzZXJ2ZXIpIHx8IHQudXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXBlbmRTbGlkZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgICBhID0gdC5wYXJhbXMsXG4gICAgICAgICAgICBpID0gdC4kd3JhcHBlckVsLFxuICAgICAgICAgICAgcyA9IHQuYWN0aXZlSW5kZXg7XG4gICAgICAgICAgYS5sb29wICYmIHQubG9vcERlc3Ryb3koKTtcbiAgICAgICAgICB2YXIgciA9IHMgKyAxO1xuICAgICAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBlICYmIFwibGVuZ3RoXCIgaW4gZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBlLmxlbmd0aDsgbiArPSAxKSBlW25dICYmIGkucHJlcGVuZChlW25dKTtcbiAgICAgICAgICAgIHIgPSBzICsgZS5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIGkucHJlcGVuZChlKTtcbiAgICAgICAgICBhLmxvb3AgJiYgdC5sb29wQ3JlYXRlKCksXG4gICAgICAgICAgICAoYS5vYnNlcnZlciAmJiB0LnN1cHBvcnQub2JzZXJ2ZXIpIHx8IHQudXBkYXRlKCksXG4gICAgICAgICAgICB0LnNsaWRlVG8ociwgMCwgITEpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRTbGlkZTogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBpID0gYS4kd3JhcHBlckVsLFxuICAgICAgICAgICAgcyA9IGEucGFyYW1zLFxuICAgICAgICAgICAgciA9IGEuYWN0aXZlSW5kZXg7XG4gICAgICAgICAgcy5sb29wICYmXG4gICAgICAgICAgICAoKHIgLT0gYS5sb29wZWRTbGlkZXMpLFxuICAgICAgICAgICAgYS5sb29wRGVzdHJveSgpLFxuICAgICAgICAgICAgKGEuc2xpZGVzID0gaS5jaGlsZHJlbihcIi5cIiArIHMuc2xpZGVDbGFzcykpKTtcbiAgICAgICAgICB2YXIgbiA9IGEuc2xpZGVzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoZSA8PSAwKSBhLnByZXBlbmRTbGlkZSh0KTtcbiAgICAgICAgICBlbHNlIGlmIChlID49IG4pIGEuYXBwZW5kU2xpZGUodCk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBsID0gciA+IGUgPyByICsgMSA6IHIsIG8gPSBbXSwgZCA9IG4gLSAxOyBkID49IGU7IGQgLT0gMSkge1xuICAgICAgICAgICAgICB2YXIgcCA9IGEuc2xpZGVzLmVxKGQpO1xuICAgICAgICAgICAgICBwLnJlbW92ZSgpLCBvLnVuc2hpZnQocCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgdCAmJiBcImxlbmd0aFwiIGluIHQpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCB0Lmxlbmd0aDsgdSArPSAxKSB0W3VdICYmIGkuYXBwZW5kKHRbdV0pO1xuICAgICAgICAgICAgICBsID0gciA+IGUgPyByICsgdC5sZW5ndGggOiByO1xuICAgICAgICAgICAgfSBlbHNlIGkuYXBwZW5kKHQpO1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBvLmxlbmd0aDsgYyArPSAxKSBpLmFwcGVuZChvW2NdKTtcbiAgICAgICAgICAgIHMubG9vcCAmJiBhLmxvb3BDcmVhdGUoKSxcbiAgICAgICAgICAgICAgKHMub2JzZXJ2ZXIgJiYgYS5zdXBwb3J0Lm9ic2VydmVyKSB8fCBhLnVwZGF0ZSgpLFxuICAgICAgICAgICAgICBzLmxvb3BcbiAgICAgICAgICAgICAgICA/IGEuc2xpZGVUbyhsICsgYS5sb29wZWRTbGlkZXMsIDAsICExKVxuICAgICAgICAgICAgICAgIDogYS5zbGlkZVRvKGwsIDAsICExKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVNsaWRlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciB0ID0gdGhpcyxcbiAgICAgICAgICAgIGEgPSB0LnBhcmFtcyxcbiAgICAgICAgICAgIGkgPSB0LiR3cmFwcGVyRWwsXG4gICAgICAgICAgICBzID0gdC5hY3RpdmVJbmRleDtcbiAgICAgICAgICBhLmxvb3AgJiZcbiAgICAgICAgICAgICgocyAtPSB0Lmxvb3BlZFNsaWRlcyksXG4gICAgICAgICAgICB0Lmxvb3BEZXN0cm95KCksXG4gICAgICAgICAgICAodC5zbGlkZXMgPSBpLmNoaWxkcmVuKFwiLlwiICsgYS5zbGlkZUNsYXNzKSkpO1xuICAgICAgICAgIHZhciByLFxuICAgICAgICAgICAgbiA9IHM7XG4gICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgJiYgXCJsZW5ndGhcIiBpbiBlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGUubGVuZ3RoOyBsICs9IDEpXG4gICAgICAgICAgICAgIChyID0gZVtsXSksXG4gICAgICAgICAgICAgICAgdC5zbGlkZXNbcl0gJiYgdC5zbGlkZXMuZXEocikucmVtb3ZlKCksXG4gICAgICAgICAgICAgICAgciA8IG4gJiYgKG4gLT0gMSk7XG4gICAgICAgICAgICBuID0gTWF0aC5tYXgobiwgMCk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAociA9IGUpLFxuICAgICAgICAgICAgICB0LnNsaWRlc1tyXSAmJiB0LnNsaWRlcy5lcShyKS5yZW1vdmUoKSxcbiAgICAgICAgICAgICAgciA8IG4gJiYgKG4gLT0gMSksXG4gICAgICAgICAgICAgIChuID0gTWF0aC5tYXgobiwgMCkpO1xuICAgICAgICAgIGEubG9vcCAmJiB0Lmxvb3BDcmVhdGUoKSxcbiAgICAgICAgICAgIChhLm9ic2VydmVyICYmIHQuc3VwcG9ydC5vYnNlcnZlcikgfHwgdC51cGRhdGUoKSxcbiAgICAgICAgICAgIGEubG9vcCA/IHQuc2xpZGVUbyhuICsgdC5sb29wZWRTbGlkZXMsIDAsICExKSA6IHQuc2xpZGVUbyhuLCAwLCAhMSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUFsbFNsaWRlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvciAodmFyIGUgPSBbXSwgdCA9IDA7IHQgPCB0aGlzLnNsaWRlcy5sZW5ndGg7IHQgKz0gMSkgZS5wdXNoKHQpO1xuICAgICAgICAgIHRoaXMucmVtb3ZlU2xpZGUoZSk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGF0dGFjaEV2ZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICAgIHQgPSByKCksXG4gICAgICAgICAgICBhID0gZS5wYXJhbXMsXG4gICAgICAgICAgICBpID0gZS50b3VjaEV2ZW50cyxcbiAgICAgICAgICAgIHMgPSBlLmVsLFxuICAgICAgICAgICAgbiA9IGUud3JhcHBlckVsLFxuICAgICAgICAgICAgbCA9IGUuZGV2aWNlLFxuICAgICAgICAgICAgbyA9IGUuc3VwcG9ydDtcbiAgICAgICAgICAoZS5vblRvdWNoU3RhcnQgPSBPLmJpbmQoZSkpLFxuICAgICAgICAgICAgKGUub25Ub3VjaE1vdmUgPSBBLmJpbmQoZSkpLFxuICAgICAgICAgICAgKGUub25Ub3VjaEVuZCA9IEQuYmluZChlKSksXG4gICAgICAgICAgICBhLmNzc01vZGUgJiYgKGUub25TY3JvbGwgPSBCLmJpbmQoZSkpLFxuICAgICAgICAgICAgKGUub25DbGljayA9IE4uYmluZChlKSk7XG4gICAgICAgICAgdmFyIGQgPSAhIWEubmVzdGVkO1xuICAgICAgICAgIGlmICghby50b3VjaCAmJiBvLnBvaW50ZXJFdmVudHMpXG4gICAgICAgICAgICBzLmFkZEV2ZW50TGlzdGVuZXIoaS5zdGFydCwgZS5vblRvdWNoU3RhcnQsICExKSxcbiAgICAgICAgICAgICAgdC5hZGRFdmVudExpc3RlbmVyKGkubW92ZSwgZS5vblRvdWNoTW92ZSwgZCksXG4gICAgICAgICAgICAgIHQuYWRkRXZlbnRMaXN0ZW5lcihpLmVuZCwgZS5vblRvdWNoRW5kLCAhMSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoby50b3VjaCkge1xuICAgICAgICAgICAgICB2YXIgcCA9ICEoXG4gICAgICAgICAgICAgICAgXCJ0b3VjaHN0YXJ0XCIgIT09IGkuc3RhcnQgfHxcbiAgICAgICAgICAgICAgICAhby5wYXNzaXZlTGlzdGVuZXIgfHxcbiAgICAgICAgICAgICAgICAhYS5wYXNzaXZlTGlzdGVuZXJzXG4gICAgICAgICAgICAgICkgJiYgeyBwYXNzaXZlOiAhMCwgY2FwdHVyZTogITEgfTtcbiAgICAgICAgICAgICAgcy5hZGRFdmVudExpc3RlbmVyKGkuc3RhcnQsIGUub25Ub3VjaFN0YXJ0LCBwKSxcbiAgICAgICAgICAgICAgICBzLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgICBpLm1vdmUsXG4gICAgICAgICAgICAgICAgICBlLm9uVG91Y2hNb3ZlLFxuICAgICAgICAgICAgICAgICAgby5wYXNzaXZlTGlzdGVuZXIgPyB7IHBhc3NpdmU6ICExLCBjYXB0dXJlOiBkIH0gOiBkXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBzLmFkZEV2ZW50TGlzdGVuZXIoaS5lbmQsIGUub25Ub3VjaEVuZCwgcCksXG4gICAgICAgICAgICAgICAgaS5jYW5jZWwgJiYgcy5hZGRFdmVudExpc3RlbmVyKGkuY2FuY2VsLCBlLm9uVG91Y2hFbmQsIHApLFxuICAgICAgICAgICAgICAgIEggfHwgKHQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgWCksIChIID0gITApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgoYS5zaW11bGF0ZVRvdWNoICYmICFsLmlvcyAmJiAhbC5hbmRyb2lkKSB8fFxuICAgICAgICAgICAgICAoYS5zaW11bGF0ZVRvdWNoICYmICFvLnRvdWNoICYmIGwuaW9zKSkgJiZcbiAgICAgICAgICAgICAgKHMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBlLm9uVG91Y2hTdGFydCwgITEpLFxuICAgICAgICAgICAgICB0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgZS5vblRvdWNoTW92ZSwgZCksXG4gICAgICAgICAgICAgIHQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgZS5vblRvdWNoRW5kLCAhMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoYS5wcmV2ZW50Q2xpY2tzIHx8IGEucHJldmVudENsaWNrc1Byb3BhZ2F0aW9uKSAmJlxuICAgICAgICAgICAgcy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZS5vbkNsaWNrLCAhMCksXG4gICAgICAgICAgICBhLmNzc01vZGUgJiYgbi5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGUub25TY3JvbGwpLFxuICAgICAgICAgICAgYS51cGRhdGVPbldpbmRvd1Jlc2l6ZVxuICAgICAgICAgICAgICA/IGUub24oXG4gICAgICAgICAgICAgICAgICBsLmlvcyB8fCBsLmFuZHJvaWRcbiAgICAgICAgICAgICAgICAgICAgPyBcInJlc2l6ZSBvcmllbnRhdGlvbmNoYW5nZSBvYnNlcnZlclVwZGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJyZXNpemUgb2JzZXJ2ZXJVcGRhdGVcIixcbiAgICAgICAgICAgICAgICAgIEcsXG4gICAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBlLm9uKFwib2JzZXJ2ZXJVcGRhdGVcIiwgRywgITApO1xuICAgICAgICB9LFxuICAgICAgICBkZXRhY2hFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgICB0ID0gcigpLFxuICAgICAgICAgICAgYSA9IGUucGFyYW1zLFxuICAgICAgICAgICAgaSA9IGUudG91Y2hFdmVudHMsXG4gICAgICAgICAgICBzID0gZS5lbCxcbiAgICAgICAgICAgIG4gPSBlLndyYXBwZXJFbCxcbiAgICAgICAgICAgIGwgPSBlLmRldmljZSxcbiAgICAgICAgICAgIG8gPSBlLnN1cHBvcnQsXG4gICAgICAgICAgICBkID0gISFhLm5lc3RlZDtcbiAgICAgICAgICBpZiAoIW8udG91Y2ggJiYgby5wb2ludGVyRXZlbnRzKVxuICAgICAgICAgICAgcy5yZW1vdmVFdmVudExpc3RlbmVyKGkuc3RhcnQsIGUub25Ub3VjaFN0YXJ0LCAhMSksXG4gICAgICAgICAgICAgIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihpLm1vdmUsIGUub25Ub3VjaE1vdmUsIGQpLFxuICAgICAgICAgICAgICB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoaS5lbmQsIGUub25Ub3VjaEVuZCwgITEpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG8udG91Y2gpIHtcbiAgICAgICAgICAgICAgdmFyIHAgPSAhKFxuICAgICAgICAgICAgICAgIFwib25Ub3VjaFN0YXJ0XCIgIT09IGkuc3RhcnQgfHxcbiAgICAgICAgICAgICAgICAhby5wYXNzaXZlTGlzdGVuZXIgfHxcbiAgICAgICAgICAgICAgICAhYS5wYXNzaXZlTGlzdGVuZXJzXG4gICAgICAgICAgICAgICkgJiYgeyBwYXNzaXZlOiAhMCwgY2FwdHVyZTogITEgfTtcbiAgICAgICAgICAgICAgcy5yZW1vdmVFdmVudExpc3RlbmVyKGkuc3RhcnQsIGUub25Ub3VjaFN0YXJ0LCBwKSxcbiAgICAgICAgICAgICAgICBzLnJlbW92ZUV2ZW50TGlzdGVuZXIoaS5tb3ZlLCBlLm9uVG91Y2hNb3ZlLCBkKSxcbiAgICAgICAgICAgICAgICBzLnJlbW92ZUV2ZW50TGlzdGVuZXIoaS5lbmQsIGUub25Ub3VjaEVuZCwgcCksXG4gICAgICAgICAgICAgICAgaS5jYW5jZWwgJiYgcy5yZW1vdmVFdmVudExpc3RlbmVyKGkuY2FuY2VsLCBlLm9uVG91Y2hFbmQsIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKChhLnNpbXVsYXRlVG91Y2ggJiYgIWwuaW9zICYmICFsLmFuZHJvaWQpIHx8XG4gICAgICAgICAgICAgIChhLnNpbXVsYXRlVG91Y2ggJiYgIW8udG91Y2ggJiYgbC5pb3MpKSAmJlxuICAgICAgICAgICAgICAocy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGUub25Ub3VjaFN0YXJ0LCAhMSksXG4gICAgICAgICAgICAgIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBlLm9uVG91Y2hNb3ZlLCBkKSxcbiAgICAgICAgICAgICAgdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBlLm9uVG91Y2hFbmQsICExKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIChhLnByZXZlbnRDbGlja3MgfHwgYS5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24pICYmXG4gICAgICAgICAgICBzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBlLm9uQ2xpY2ssICEwKSxcbiAgICAgICAgICAgIGEuY3NzTW9kZSAmJiBuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgZS5vblNjcm9sbCksXG4gICAgICAgICAgICBlLm9mZihcbiAgICAgICAgICAgICAgbC5pb3MgfHwgbC5hbmRyb2lkXG4gICAgICAgICAgICAgICAgPyBcInJlc2l6ZSBvcmllbnRhdGlvbmNoYW5nZSBvYnNlcnZlclVwZGF0ZVwiXG4gICAgICAgICAgICAgICAgOiBcInJlc2l6ZSBvYnNlcnZlclVwZGF0ZVwiLFxuICAgICAgICAgICAgICBHXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGJyZWFrcG9pbnRzOiB7XG4gICAgICAgIHNldEJyZWFrcG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgICB0ID0gZS5hY3RpdmVJbmRleCxcbiAgICAgICAgICAgIGEgPSBlLmluaXRpYWxpemVkLFxuICAgICAgICAgICAgaSA9IGUubG9vcGVkU2xpZGVzLFxuICAgICAgICAgICAgcyA9IHZvaWQgMCA9PT0gaSA/IDAgOiBpLFxuICAgICAgICAgICAgciA9IGUucGFyYW1zLFxuICAgICAgICAgICAgbiA9IGUuJGVsLFxuICAgICAgICAgICAgbCA9IHIuYnJlYWtwb2ludHM7XG4gICAgICAgICAgaWYgKGwgJiYgKCFsIHx8IDAgIT09IE9iamVjdC5rZXlzKGwpLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHZhciBvID0gZS5nZXRCcmVha3BvaW50KGwpO1xuICAgICAgICAgICAgaWYgKG8gJiYgZS5jdXJyZW50QnJlYWtwb2ludCAhPT0gbykge1xuICAgICAgICAgICAgICB2YXIgZCA9IG8gaW4gbCA/IGxbb10gOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGQgJiZcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBcInNsaWRlc1BlclZpZXdcIixcbiAgICAgICAgICAgICAgICAgIFwic3BhY2VCZXR3ZWVuXCIsXG4gICAgICAgICAgICAgICAgICBcInNsaWRlc1Blckdyb3VwXCIsXG4gICAgICAgICAgICAgICAgICBcInNsaWRlc1Blckdyb3VwU2tpcFwiLFxuICAgICAgICAgICAgICAgICAgXCJzbGlkZXNQZXJDb2x1bW5cIixcbiAgICAgICAgICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB0ID0gZFtlXTtcbiAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gdCAmJlxuICAgICAgICAgICAgICAgICAgICAoZFtlXSA9XG4gICAgICAgICAgICAgICAgICAgICAgXCJzbGlkZXNQZXJWaWV3XCIgIT09IGUgfHwgKFwiQVVUT1wiICE9PSB0ICYmIFwiYXV0b1wiICE9PSB0KVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcInNsaWRlc1BlclZpZXdcIiA9PT0gZVxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBhcnNlRmxvYXQodClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJzZUludCh0LCAxMClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJhdXRvXCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgcCA9IGQgfHwgZS5vcmlnaW5hbFBhcmFtcyxcbiAgICAgICAgICAgICAgICB1ID0gci5zbGlkZXNQZXJDb2x1bW4gPiAxLFxuICAgICAgICAgICAgICAgIGMgPSBwLnNsaWRlc1BlckNvbHVtbiA+IDE7XG4gICAgICAgICAgICAgIHUgJiYgIWNcbiAgICAgICAgICAgICAgICA/IChuLnJlbW92ZUNsYXNzKFxuICAgICAgICAgICAgICAgICAgICByLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgK1xuICAgICAgICAgICAgICAgICAgICAgIFwibXVsdGlyb3cgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIHIuY29udGFpbmVyTW9kaWZpZXJDbGFzcyArXG4gICAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXJvdy1jb2x1bW5cIlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIGUuZW1pdENvbnRhaW5lckNsYXNzZXMoKSlcbiAgICAgICAgICAgICAgICA6ICF1ICYmXG4gICAgICAgICAgICAgICAgICBjICYmXG4gICAgICAgICAgICAgICAgICAobi5hZGRDbGFzcyhyLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBcIm11bHRpcm93XCIpLFxuICAgICAgICAgICAgICAgICAgXCJjb2x1bW5cIiA9PT0gcC5zbGlkZXNQZXJDb2x1bW5GaWxsICYmXG4gICAgICAgICAgICAgICAgICAgIG4uYWRkQ2xhc3Moci5jb250YWluZXJNb2RpZmllckNsYXNzICsgXCJtdWx0aXJvdy1jb2x1bW5cIiksXG4gICAgICAgICAgICAgICAgICBlLmVtaXRDb250YWluZXJDbGFzc2VzKCkpO1xuICAgICAgICAgICAgICB2YXIgaCA9IHAuZGlyZWN0aW9uICYmIHAuZGlyZWN0aW9uICE9PSByLmRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICB2ID0gci5sb29wICYmIChwLnNsaWRlc1BlclZpZXcgIT09IHIuc2xpZGVzUGVyVmlldyB8fCBoKTtcbiAgICAgICAgICAgICAgaCAmJiBhICYmIGUuY2hhbmdlRGlyZWN0aW9uKCksXG4gICAgICAgICAgICAgICAgUyhlLnBhcmFtcywgcCksXG4gICAgICAgICAgICAgICAgUyhlLCB7XG4gICAgICAgICAgICAgICAgICBhbGxvd1RvdWNoTW92ZTogZS5wYXJhbXMuYWxsb3dUb3VjaE1vdmUsXG4gICAgICAgICAgICAgICAgICBhbGxvd1NsaWRlTmV4dDogZS5wYXJhbXMuYWxsb3dTbGlkZU5leHQsXG4gICAgICAgICAgICAgICAgICBhbGxvd1NsaWRlUHJldjogZS5wYXJhbXMuYWxsb3dTbGlkZVByZXYsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgKGUuY3VycmVudEJyZWFrcG9pbnQgPSBvKSxcbiAgICAgICAgICAgICAgICBlLmVtaXQoXCJfYmVmb3JlQnJlYWtwb2ludFwiLCBwKSxcbiAgICAgICAgICAgICAgICB2ICYmXG4gICAgICAgICAgICAgICAgICBhICYmXG4gICAgICAgICAgICAgICAgICAoZS5sb29wRGVzdHJveSgpLFxuICAgICAgICAgICAgICAgICAgZS5sb29wQ3JlYXRlKCksXG4gICAgICAgICAgICAgICAgICBlLnVwZGF0ZVNsaWRlcygpLFxuICAgICAgICAgICAgICAgICAgZS5zbGlkZVRvKHQgLSBzICsgZS5sb29wZWRTbGlkZXMsIDAsICExKSksXG4gICAgICAgICAgICAgICAgZS5lbWl0KFwiYnJlYWtwb2ludFwiLCBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldEJyZWFrcG9pbnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIHQgPSBsKCk7XG4gICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIHZhciBhID0gITEsXG4gICAgICAgICAgICAgIGkgPSBPYmplY3Qua2V5cyhlKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiAwID09PSBlLmluZGV4T2YoXCJAXCIpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYSA9IHBhcnNlRmxvYXQoZS5zdWJzdHIoMSkpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHQuaW5uZXJIZWlnaHQgKiBhLCBwb2ludDogZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogZSwgcG9pbnQ6IGUgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpLnNvcnQoZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGUudmFsdWUsIDEwKSAtIHBhcnNlSW50KHQudmFsdWUsIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBpLmxlbmd0aDsgcyArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciByID0gaVtzXSxcbiAgICAgICAgICAgICAgICBuID0gci5wb2ludDtcbiAgICAgICAgICAgICAgci52YWx1ZSA8PSB0LmlubmVyV2lkdGggJiYgKGEgPSBuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhIHx8IFwibWF4XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGNoZWNrT3ZlcmZsb3c6IHtcbiAgICAgICAgY2hlY2tPdmVyZmxvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICAgIHQgPSBlLnBhcmFtcyxcbiAgICAgICAgICAgIGEgPSBlLmlzTG9ja2VkLFxuICAgICAgICAgICAgaSA9XG4gICAgICAgICAgICAgIGUuc2xpZGVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgdC5zbGlkZXNPZmZzZXRCZWZvcmUgK1xuICAgICAgICAgICAgICAgIHQuc3BhY2VCZXR3ZWVuICogKGUuc2xpZGVzLmxlbmd0aCAtIDEpICtcbiAgICAgICAgICAgICAgICBlLnNsaWRlc1swXS5vZmZzZXRXaWR0aCAqIGUuc2xpZGVzLmxlbmd0aDtcbiAgICAgICAgICB0LnNsaWRlc09mZnNldEJlZm9yZSAmJiB0LnNsaWRlc09mZnNldEFmdGVyICYmIGlcbiAgICAgICAgICAgID8gKGUuaXNMb2NrZWQgPSBpIDw9IGUuc2l6ZSlcbiAgICAgICAgICAgIDogKGUuaXNMb2NrZWQgPSAxID09PSBlLnNuYXBHcmlkLmxlbmd0aCksXG4gICAgICAgICAgICAoZS5hbGxvd1NsaWRlTmV4dCA9ICFlLmlzTG9ja2VkKSxcbiAgICAgICAgICAgIChlLmFsbG93U2xpZGVQcmV2ID0gIWUuaXNMb2NrZWQpLFxuICAgICAgICAgICAgYSAhPT0gZS5pc0xvY2tlZCAmJiBlLmVtaXQoZS5pc0xvY2tlZCA/IFwibG9ja1wiIDogXCJ1bmxvY2tcIiksXG4gICAgICAgICAgICBhICYmXG4gICAgICAgICAgICAgIGEgIT09IGUuaXNMb2NrZWQgJiZcbiAgICAgICAgICAgICAgKChlLmlzRW5kID0gITEpLCBlLm5hdmlnYXRpb24gJiYgZS5uYXZpZ2F0aW9uLnVwZGF0ZSgpKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgIGFkZENsYXNzZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgICB0ID0gZS5jbGFzc05hbWVzLFxuICAgICAgICAgICAgYSA9IGUucGFyYW1zLFxuICAgICAgICAgICAgaSA9IGUucnRsLFxuICAgICAgICAgICAgcyA9IGUuJGVsLFxuICAgICAgICAgICAgciA9IGUuZGV2aWNlLFxuICAgICAgICAgICAgbiA9IFtdO1xuICAgICAgICAgIG4ucHVzaChcImluaXRpYWxpemVkXCIpLFxuICAgICAgICAgICAgbi5wdXNoKGEuZGlyZWN0aW9uKSxcbiAgICAgICAgICAgIGEuZnJlZU1vZGUgJiYgbi5wdXNoKFwiZnJlZS1tb2RlXCIpLFxuICAgICAgICAgICAgYS5hdXRvSGVpZ2h0ICYmIG4ucHVzaChcImF1dG9oZWlnaHRcIiksXG4gICAgICAgICAgICBpICYmIG4ucHVzaChcInJ0bFwiKSxcbiAgICAgICAgICAgIGEuc2xpZGVzUGVyQ29sdW1uID4gMSAmJlxuICAgICAgICAgICAgICAobi5wdXNoKFwibXVsdGlyb3dcIiksXG4gICAgICAgICAgICAgIFwiY29sdW1uXCIgPT09IGEuc2xpZGVzUGVyQ29sdW1uRmlsbCAmJiBuLnB1c2goXCJtdWx0aXJvdy1jb2x1bW5cIikpLFxuICAgICAgICAgICAgci5hbmRyb2lkICYmIG4ucHVzaChcImFuZHJvaWRcIiksXG4gICAgICAgICAgICByLmlvcyAmJiBuLnB1c2goXCJpb3NcIiksXG4gICAgICAgICAgICBhLmNzc01vZGUgJiYgbi5wdXNoKFwiY3NzLW1vZGVcIiksXG4gICAgICAgICAgICBuLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgdC5wdXNoKGEuY29udGFpbmVyTW9kaWZpZXJDbGFzcyArIGUpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzLmFkZENsYXNzKHQuam9pbihcIiBcIikpLFxuICAgICAgICAgICAgZS5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDbGFzc2VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgICAgdCA9IGUuJGVsLFxuICAgICAgICAgICAgYSA9IGUuY2xhc3NOYW1lcztcbiAgICAgICAgICB0LnJlbW92ZUNsYXNzKGEuam9pbihcIiBcIikpLCBlLmVtaXRDb250YWluZXJDbGFzc2VzKCk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgaW1hZ2VzOiB7XG4gICAgICAgIGxvYWRJbWFnZTogZnVuY3Rpb24gKGUsIHQsIGEsIGksIHMsIHIpIHtcbiAgICAgICAgICB2YXIgbixcbiAgICAgICAgICAgIG8gPSBsKCk7XG4gICAgICAgICAgZnVuY3Rpb24gZCgpIHtcbiAgICAgICAgICAgIHIgJiYgcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtKGUpLnBhcmVudChcInBpY3R1cmVcIilbMF0gfHwgKGUuY29tcGxldGUgJiYgcylcbiAgICAgICAgICAgID8gZCgpXG4gICAgICAgICAgICA6IHRcbiAgICAgICAgICAgID8gKCgobiA9IG5ldyBvLkltYWdlKCkpLm9ubG9hZCA9IGQpLFxuICAgICAgICAgICAgICAobi5vbmVycm9yID0gZCksXG4gICAgICAgICAgICAgIGkgJiYgKG4uc2l6ZXMgPSBpKSxcbiAgICAgICAgICAgICAgYSAmJiAobi5zcmNzZXQgPSBhKSxcbiAgICAgICAgICAgICAgdCAmJiAobi5zcmMgPSB0KSlcbiAgICAgICAgICAgIDogZCgpO1xuICAgICAgICB9LFxuICAgICAgICBwcmVsb2FkSW1hZ2VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICAgIGZ1bmN0aW9uIHQoKSB7XG4gICAgICAgICAgICBudWxsICE9IGUgJiZcbiAgICAgICAgICAgICAgZSAmJlxuICAgICAgICAgICAgICAhZS5kZXN0cm95ZWQgJiZcbiAgICAgICAgICAgICAgKHZvaWQgMCAhPT0gZS5pbWFnZXNMb2FkZWQgJiYgKGUuaW1hZ2VzTG9hZGVkICs9IDEpLFxuICAgICAgICAgICAgICBlLmltYWdlc0xvYWRlZCA9PT0gZS5pbWFnZXNUb0xvYWQubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgKGUucGFyYW1zLnVwZGF0ZU9uSW1hZ2VzUmVhZHkgJiYgZS51cGRhdGUoKSxcbiAgICAgICAgICAgICAgICBlLmVtaXQoXCJpbWFnZXNSZWFkeVwiKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlLmltYWdlc1RvTG9hZCA9IGUuJGVsLmZpbmQoXCJpbWdcIik7XG4gICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBlLmltYWdlc1RvTG9hZC5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGkgPSBlLmltYWdlc1RvTG9hZFthXTtcbiAgICAgICAgICAgIGUubG9hZEltYWdlKFxuICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICBpLmN1cnJlbnRTcmMgfHwgaS5nZXRBdHRyaWJ1dGUoXCJzcmNcIiksXG4gICAgICAgICAgICAgIGkuc3Jjc2V0IHx8IGkuZ2V0QXR0cmlidXRlKFwic3Jjc2V0XCIpLFxuICAgICAgICAgICAgICBpLnNpemVzIHx8IGkuZ2V0QXR0cmlidXRlKFwic2l6ZXNcIiksXG4gICAgICAgICAgICAgICEwLFxuICAgICAgICAgICAgICB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBGID0ge30sXG4gICAgUiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiB0KCkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBlLCBhLCBpID0gYXJndW1lbnRzLmxlbmd0aCwgcyA9IG5ldyBBcnJheShpKSwgciA9IDA7XG4gICAgICAgICAgciA8IGk7XG4gICAgICAgICAgcisrXG4gICAgICAgIClcbiAgICAgICAgICBzW3JdID0gYXJndW1lbnRzW3JdO1xuICAgICAgICAxID09PSBzLmxlbmd0aCAmJiBzWzBdLmNvbnN0cnVjdG9yICYmIHNbMF0uY29uc3RydWN0b3IgPT09IE9iamVjdFxuICAgICAgICAgID8gKGEgPSBzWzBdKVxuICAgICAgICAgIDogKChlID0gc1swXSksIChhID0gc1sxXSkpLFxuICAgICAgICAgIGEgfHwgKGEgPSB7fSksXG4gICAgICAgICAgKGEgPSBTKHt9LCBhKSksXG4gICAgICAgICAgZSAmJiAhYS5lbCAmJiAoYS5lbCA9IGUpO1xuICAgICAgICB2YXIgbiA9IHRoaXM7XG4gICAgICAgIChuLnN1cHBvcnQgPSB6KCkpLFxuICAgICAgICAgIChuLmRldmljZSA9IFAoeyB1c2VyQWdlbnQ6IGEudXNlckFnZW50IH0pKSxcbiAgICAgICAgICAobi5icm93c2VyID0gaygpKSxcbiAgICAgICAgICAobi5ldmVudHNMaXN0ZW5lcnMgPSB7fSksXG4gICAgICAgICAgKG4uZXZlbnRzQW55TGlzdGVuZXJzID0gW10pLFxuICAgICAgICAgIHZvaWQgMCA9PT0gbi5tb2R1bGVzICYmIChuLm1vZHVsZXMgPSB7fSksXG4gICAgICAgICAgT2JqZWN0LmtleXMobi5tb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IG4ubW9kdWxlc1tlXTtcbiAgICAgICAgICAgIGlmICh0LnBhcmFtcykge1xuICAgICAgICAgICAgICB2YXIgaSA9IE9iamVjdC5rZXlzKHQucGFyYW1zKVswXSxcbiAgICAgICAgICAgICAgICBzID0gdC5wYXJhbXNbaV07XG4gICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBzIHx8IG51bGwgPT09IHMpIHJldHVybjtcbiAgICAgICAgICAgICAgaWYgKCEoaSBpbiBhKSB8fCAhKFwiZW5hYmxlZFwiIGluIHMpKSByZXR1cm47XG4gICAgICAgICAgICAgICEwID09PSBhW2ldICYmIChhW2ldID0geyBlbmFibGVkOiAhMCB9KSxcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiICE9IHR5cGVvZiBhW2ldIHx8XG4gICAgICAgICAgICAgICAgICBcImVuYWJsZWRcIiBpbiBhW2ldIHx8XG4gICAgICAgICAgICAgICAgICAoYVtpXS5lbmFibGVkID0gITApLFxuICAgICAgICAgICAgICAgIGFbaV0gfHwgKGFbaV0gPSB7IGVuYWJsZWQ6ICExIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB2YXIgbCA9IFMoe30sIFkpO1xuICAgICAgICBuLnVzZVBhcmFtcyhsKSxcbiAgICAgICAgICAobi5wYXJhbXMgPSBTKHt9LCBsLCBGLCBhKSksXG4gICAgICAgICAgKG4ub3JpZ2luYWxQYXJhbXMgPSBTKHt9LCBuLnBhcmFtcykpLFxuICAgICAgICAgIChuLnBhc3NlZFBhcmFtcyA9IFMoe30sIGEpKSxcbiAgICAgICAgICBuLnBhcmFtcyAmJlxuICAgICAgICAgICAgbi5wYXJhbXMub24gJiZcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG4ucGFyYW1zLm9uKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIG4ub24oZSwgbi5wYXJhbXMub25bZV0pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgbi5wYXJhbXMgJiYgbi5wYXJhbXMub25BbnkgJiYgbi5vbkFueShuLnBhcmFtcy5vbkFueSksXG4gICAgICAgICAgKG4uJCA9IG0pO1xuICAgICAgICB2YXIgbyA9IG0obi5wYXJhbXMuZWwpO1xuICAgICAgICBpZiAoKGUgPSBvWzBdKSkge1xuICAgICAgICAgIGlmIChvLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBkID0gW107XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBvLmVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IFMoe30sIGEsIHsgZWw6IGUgfSk7XG4gICAgICAgICAgICAgICAgZC5wdXNoKG5ldyB0KGkpKTtcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwLCB1LCBjO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZS5zd2lwZXIgPSBuKSxcbiAgICAgICAgICAgIGUgJiYgZS5zaGFkb3dSb290ICYmIGUuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yXG4gICAgICAgICAgICAgID8gKChwID0gbShcbiAgICAgICAgICAgICAgICAgIGUuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgbi5wYXJhbXMud3JhcHBlckNsYXNzKVxuICAgICAgICAgICAgICAgICkpLmNoaWxkcmVuID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvLmNoaWxkcmVuKGUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIDogKHAgPSBvLmNoaWxkcmVuKFwiLlwiICsgbi5wYXJhbXMud3JhcHBlckNsYXNzKSksXG4gICAgICAgICAgICBTKG4sIHtcbiAgICAgICAgICAgICAgJGVsOiBvLFxuICAgICAgICAgICAgICBlbDogZSxcbiAgICAgICAgICAgICAgJHdyYXBwZXJFbDogcCxcbiAgICAgICAgICAgICAgd3JhcHBlckVsOiBwWzBdLFxuICAgICAgICAgICAgICBjbGFzc05hbWVzOiBbXSxcbiAgICAgICAgICAgICAgc2xpZGVzOiBtKCksXG4gICAgICAgICAgICAgIHNsaWRlc0dyaWQ6IFtdLFxuICAgICAgICAgICAgICBzbmFwR3JpZDogW10sXG4gICAgICAgICAgICAgIHNsaWRlc1NpemVzR3JpZDogW10sXG4gICAgICAgICAgICAgIGlzSG9yaXpvbnRhbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImhvcml6b250YWxcIiA9PT0gbi5wYXJhbXMuZGlyZWN0aW9uO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBpc1ZlcnRpY2FsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidmVydGljYWxcIiA9PT0gbi5wYXJhbXMuZGlyZWN0aW9uO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBydGw6XG4gICAgICAgICAgICAgICAgXCJydGxcIiA9PT0gZS5kaXIudG9Mb3dlckNhc2UoKSB8fCBcInJ0bFwiID09PSBvLmNzcyhcImRpcmVjdGlvblwiKSxcbiAgICAgICAgICAgICAgcnRsVHJhbnNsYXRlOlxuICAgICAgICAgICAgICAgIFwiaG9yaXpvbnRhbFwiID09PSBuLnBhcmFtcy5kaXJlY3Rpb24gJiZcbiAgICAgICAgICAgICAgICAoXCJydGxcIiA9PT0gZS5kaXIudG9Mb3dlckNhc2UoKSB8fCBcInJ0bFwiID09PSBvLmNzcyhcImRpcmVjdGlvblwiKSksXG4gICAgICAgICAgICAgIHdyb25nUlRMOiBcIi13ZWJraXQtYm94XCIgPT09IHAuY3NzKFwiZGlzcGxheVwiKSxcbiAgICAgICAgICAgICAgYWN0aXZlSW5kZXg6IDAsXG4gICAgICAgICAgICAgIHJlYWxJbmRleDogMCxcbiAgICAgICAgICAgICAgaXNCZWdpbm5pbmc6ICEwLFxuICAgICAgICAgICAgICBpc0VuZDogITEsXG4gICAgICAgICAgICAgIHRyYW5zbGF0ZTogMCxcbiAgICAgICAgICAgICAgcHJldmlvdXNUcmFuc2xhdGU6IDAsXG4gICAgICAgICAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgICAgICAgICB2ZWxvY2l0eTogMCxcbiAgICAgICAgICAgICAgYW5pbWF0aW5nOiAhMSxcbiAgICAgICAgICAgICAgYWxsb3dTbGlkZU5leHQ6IG4ucGFyYW1zLmFsbG93U2xpZGVOZXh0LFxuICAgICAgICAgICAgICBhbGxvd1NsaWRlUHJldjogbi5wYXJhbXMuYWxsb3dTbGlkZVByZXYsXG4gICAgICAgICAgICAgIHRvdWNoRXZlbnRzOlxuICAgICAgICAgICAgICAgICgodSA9IFtcInRvdWNoc3RhcnRcIiwgXCJ0b3VjaG1vdmVcIiwgXCJ0b3VjaGVuZFwiLCBcInRvdWNoY2FuY2VsXCJdKSxcbiAgICAgICAgICAgICAgICAoYyA9IFtcIm1vdXNlZG93blwiLCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNldXBcIl0pLFxuICAgICAgICAgICAgICAgIG4uc3VwcG9ydC5wb2ludGVyRXZlbnRzICYmXG4gICAgICAgICAgICAgICAgICAoYyA9IFtcInBvaW50ZXJkb3duXCIsIFwicG9pbnRlcm1vdmVcIiwgXCJwb2ludGVydXBcIl0pLFxuICAgICAgICAgICAgICAgIChuLnRvdWNoRXZlbnRzVG91Y2ggPSB7XG4gICAgICAgICAgICAgICAgICBzdGFydDogdVswXSxcbiAgICAgICAgICAgICAgICAgIG1vdmU6IHVbMV0sXG4gICAgICAgICAgICAgICAgICBlbmQ6IHVbMl0sXG4gICAgICAgICAgICAgICAgICBjYW5jZWw6IHVbM10sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgKG4udG91Y2hFdmVudHNEZXNrdG9wID0geyBzdGFydDogY1swXSwgbW92ZTogY1sxXSwgZW5kOiBjWzJdIH0pLFxuICAgICAgICAgICAgICAgIG4uc3VwcG9ydC50b3VjaCB8fCAhbi5wYXJhbXMuc2ltdWxhdGVUb3VjaFxuICAgICAgICAgICAgICAgICAgPyBuLnRvdWNoRXZlbnRzVG91Y2hcbiAgICAgICAgICAgICAgICAgIDogbi50b3VjaEV2ZW50c0Rlc2t0b3ApLFxuICAgICAgICAgICAgICB0b3VjaEV2ZW50c0RhdGE6IHtcbiAgICAgICAgICAgICAgICBpc1RvdWNoZWQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBpc01vdmVkOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgYWxsb3dUb3VjaENhbGxiYWNrczogdm9pZCAwLFxuICAgICAgICAgICAgICAgIHRvdWNoU3RhcnRUaW1lOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgaXNTY3JvbGxpbmc6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBjdXJyZW50VHJhbnNsYXRlOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgc3RhcnRUcmFuc2xhdGU6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBhbGxvd1RocmVzaG9sZE1vdmU6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBmb3JtRWxlbWVudHM6XG4gICAgICAgICAgICAgICAgICBcImlucHV0LCBzZWxlY3QsIG9wdGlvbiwgdGV4dGFyZWEsIGJ1dHRvbiwgdmlkZW8sIGxhYmVsXCIsXG4gICAgICAgICAgICAgICAgbGFzdENsaWNrVGltZTogeCgpLFxuICAgICAgICAgICAgICAgIGNsaWNrVGltZW91dDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIHZlbG9jaXRpZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFsbG93TW9tZW50dW1Cb3VuY2U6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBpc1RvdWNoRXZlbnQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBzdGFydE1vdmluZzogdm9pZCAwLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBhbGxvd0NsaWNrOiAhMCxcbiAgICAgICAgICAgICAgYWxsb3dUb3VjaE1vdmU6IG4ucGFyYW1zLmFsbG93VG91Y2hNb3ZlLFxuICAgICAgICAgICAgICB0b3VjaGVzOiB7XG4gICAgICAgICAgICAgICAgc3RhcnRYOiAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0WTogMCxcbiAgICAgICAgICAgICAgICBjdXJyZW50WDogMCxcbiAgICAgICAgICAgICAgICBjdXJyZW50WTogMCxcbiAgICAgICAgICAgICAgICBkaWZmOiAwLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBpbWFnZXNUb0xvYWQ6IFtdLFxuICAgICAgICAgICAgICBpbWFnZXNMb2FkZWQ6IDAsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG4udXNlTW9kdWxlcygpLFxuICAgICAgICAgICAgbi5lbWl0KFwiX3N3aXBlclwiKSxcbiAgICAgICAgICAgIG4ucGFyYW1zLmluaXQgJiYgbi5pbml0KCksXG4gICAgICAgICAgICBuXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGEsXG4gICAgICAgIGksXG4gICAgICAgIHMsXG4gICAgICAgIHIgPSB0LnByb3RvdHlwZTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChyLmVtaXRDb250YWluZXJDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgICBpZiAoZS5wYXJhbXMuX2VtaXRDbGFzc2VzICYmIGUuZWwpIHtcbiAgICAgICAgICAgIHZhciB0ID0gZS5lbC5jbGFzc05hbWUuc3BsaXQoXCIgXCIpLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDAgPT09IHQuaW5kZXhPZihcInN3aXBlci1jb250YWluZXJcIikgfHxcbiAgICAgICAgICAgICAgICAwID09PSB0LmluZGV4T2YoZS5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcylcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZS5lbWl0KFwiX2NvbnRhaW5lckNsYXNzZXNcIiwgdC5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgKHIuZ2V0U2xpZGVDbGFzc2VzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGUuY2xhc3NOYW1lXG4gICAgICAgICAgICAuc3BsaXQoXCIgXCIpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgMCA9PT0gZS5pbmRleE9mKFwic3dpcGVyLXNsaWRlXCIpIHx8XG4gICAgICAgICAgICAgICAgMCA9PT0gZS5pbmRleE9mKHQucGFyYW1zLnNsaWRlQ2xhc3MpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oXCIgXCIpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHIuZW1pdFNsaWRlc0NsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICAgIGUucGFyYW1zLl9lbWl0Q2xhc3NlcyAmJlxuICAgICAgICAgICAgZS5lbCAmJlxuICAgICAgICAgICAgZS5zbGlkZXMuZWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICB2YXIgYSA9IGUuZ2V0U2xpZGVDbGFzc2VzKHQpO1xuICAgICAgICAgICAgICBlLmVtaXQoXCJfc2xpZGVDbGFzc1wiLCB0LCBhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSxcbiAgICAgICAgKHIuc2xpZGVzUGVyVmlld0R5bmFtaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgICAgdCA9IGUucGFyYW1zLFxuICAgICAgICAgICAgYSA9IGUuc2xpZGVzLFxuICAgICAgICAgICAgaSA9IGUuc2xpZGVzR3JpZCxcbiAgICAgICAgICAgIHMgPSBlLnNpemUsXG4gICAgICAgICAgICByID0gZS5hY3RpdmVJbmRleCxcbiAgICAgICAgICAgIG4gPSAxO1xuICAgICAgICAgIGlmICh0LmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgbCwgbyA9IGFbcl0uc3dpcGVyU2xpZGVTaXplLCBkID0gciArIDE7XG4gICAgICAgICAgICAgIGQgPCBhLmxlbmd0aDtcbiAgICAgICAgICAgICAgZCArPSAxXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIGFbZF0gJiZcbiAgICAgICAgICAgICAgICAhbCAmJlxuICAgICAgICAgICAgICAgICgobiArPSAxKSwgKG8gKz0gYVtkXS5zd2lwZXJTbGlkZVNpemUpID4gcyAmJiAobCA9ICEwKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBwID0gciAtIDE7IHAgPj0gMDsgcCAtPSAxKVxuICAgICAgICAgICAgICBhW3BdICYmXG4gICAgICAgICAgICAgICAgIWwgJiZcbiAgICAgICAgICAgICAgICAoKG4gKz0gMSksIChvICs9IGFbcF0uc3dpcGVyU2xpZGVTaXplKSA+IHMgJiYgKGwgPSAhMCkpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgZm9yICh2YXIgdSA9IHIgKyAxOyB1IDwgYS5sZW5ndGg7IHUgKz0gMSlcbiAgICAgICAgICAgICAgaVt1XSAtIGlbcl0gPCBzICYmIChuICs9IDEpO1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9KSxcbiAgICAgICAgKHIudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgICBpZiAoZSAmJiAhZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHZhciB0ID0gZS5zbmFwR3JpZCxcbiAgICAgICAgICAgICAgYSA9IGUucGFyYW1zO1xuICAgICAgICAgICAgYS5icmVha3BvaW50cyAmJiBlLnNldEJyZWFrcG9pbnQoKSxcbiAgICAgICAgICAgICAgZS51cGRhdGVTaXplKCksXG4gICAgICAgICAgICAgIGUudXBkYXRlU2xpZGVzKCksXG4gICAgICAgICAgICAgIGUudXBkYXRlUHJvZ3Jlc3MoKSxcbiAgICAgICAgICAgICAgZS51cGRhdGVTbGlkZXNDbGFzc2VzKCksXG4gICAgICAgICAgICAgIGUucGFyYW1zLmZyZWVNb2RlXG4gICAgICAgICAgICAgICAgPyAoaSgpLCBlLnBhcmFtcy5hdXRvSGVpZ2h0ICYmIGUudXBkYXRlQXV0b0hlaWdodCgpKVxuICAgICAgICAgICAgICAgIDogKChcImF1dG9cIiA9PT0gZS5wYXJhbXMuc2xpZGVzUGVyVmlldyB8fFxuICAgICAgICAgICAgICAgICAgICBlLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSkgJiZcbiAgICAgICAgICAgICAgICAgIGUuaXNFbmQgJiZcbiAgICAgICAgICAgICAgICAgICFlLnBhcmFtcy5jZW50ZXJlZFNsaWRlc1xuICAgICAgICAgICAgICAgICAgICA/IGUuc2xpZGVUbyhlLnNsaWRlcy5sZW5ndGggLSAxLCAwLCAhMSwgITApXG4gICAgICAgICAgICAgICAgICAgIDogZS5zbGlkZVRvKGUuYWN0aXZlSW5kZXgsIDAsICExLCAhMCkpIHx8IGkoKSxcbiAgICAgICAgICAgICAgYS53YXRjaE92ZXJmbG93ICYmIHQgIT09IGUuc25hcEdyaWQgJiYgZS5jaGVja092ZXJmbG93KCksXG4gICAgICAgICAgICAgIGUuZW1pdChcInVwZGF0ZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgICAgICAgIHZhciB0ID0gZS5ydGxUcmFuc2xhdGUgPyAtMSAqIGUudHJhbnNsYXRlIDogZS50cmFuc2xhdGUsXG4gICAgICAgICAgICAgIGEgPSBNYXRoLm1pbihNYXRoLm1heCh0LCBlLm1heFRyYW5zbGF0ZSgpKSwgZS5taW5UcmFuc2xhdGUoKSk7XG4gICAgICAgICAgICBlLnNldFRyYW5zbGF0ZShhKSwgZS51cGRhdGVBY3RpdmVJbmRleCgpLCBlLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICAoci5jaGFuZ2VEaXJlY3Rpb24gPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgIHZvaWQgMCA9PT0gdCAmJiAodCA9ICEwKTtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBpID0gYS5wYXJhbXMuZGlyZWN0aW9uO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBlIHx8IChlID0gXCJob3Jpem9udGFsXCIgPT09IGkgPyBcInZlcnRpY2FsXCIgOiBcImhvcml6b250YWxcIiksXG4gICAgICAgICAgICBlID09PSBpIHx8XG4gICAgICAgICAgICAgIChcImhvcml6b250YWxcIiAhPT0gZSAmJiBcInZlcnRpY2FsXCIgIT09IGUpIHx8XG4gICAgICAgICAgICAgIChhLiRlbFxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcIlwiICsgYS5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcyArIGkpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiXCIgKyBhLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzICsgZSksXG4gICAgICAgICAgICAgIGEuZW1pdENvbnRhaW5lckNsYXNzZXMoKSxcbiAgICAgICAgICAgICAgKGEucGFyYW1zLmRpcmVjdGlvbiA9IGUpLFxuICAgICAgICAgICAgICBhLnNsaWRlcy5lYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgXCJ2ZXJ0aWNhbFwiID09PSBlID8gKHQuc3R5bGUud2lkdGggPSBcIlwiKSA6ICh0LnN0eWxlLmhlaWdodCA9IFwiXCIpO1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgYS5lbWl0KFwiY2hhbmdlRGlyZWN0aW9uXCIpLFxuICAgICAgICAgICAgICB0ICYmIGEudXBkYXRlKCkpLFxuICAgICAgICAgICAgYVxuICAgICAgICAgICk7XG4gICAgICAgIH0pLFxuICAgICAgICAoci5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgICBlLmluaXRpYWxpemVkIHx8XG4gICAgICAgICAgICAoZS5lbWl0KFwiYmVmb3JlSW5pdFwiKSxcbiAgICAgICAgICAgIGUucGFyYW1zLmJyZWFrcG9pbnRzICYmIGUuc2V0QnJlYWtwb2ludCgpLFxuICAgICAgICAgICAgZS5hZGRDbGFzc2VzKCksXG4gICAgICAgICAgICBlLnBhcmFtcy5sb29wICYmIGUubG9vcENyZWF0ZSgpLFxuICAgICAgICAgICAgZS51cGRhdGVTaXplKCksXG4gICAgICAgICAgICBlLnVwZGF0ZVNsaWRlcygpLFxuICAgICAgICAgICAgZS5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBlLmNoZWNrT3ZlcmZsb3coKSxcbiAgICAgICAgICAgIGUucGFyYW1zLmdyYWJDdXJzb3IgJiYgZS5zZXRHcmFiQ3Vyc29yKCksXG4gICAgICAgICAgICBlLnBhcmFtcy5wcmVsb2FkSW1hZ2VzICYmIGUucHJlbG9hZEltYWdlcygpLFxuICAgICAgICAgICAgZS5wYXJhbXMubG9vcFxuICAgICAgICAgICAgICA/IGUuc2xpZGVUbyhcbiAgICAgICAgICAgICAgICAgIGUucGFyYW1zLmluaXRpYWxTbGlkZSArIGUubG9vcGVkU2xpZGVzLFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgIGUucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBlLnNsaWRlVG8oXG4gICAgICAgICAgICAgICAgICBlLnBhcmFtcy5pbml0aWFsU2xpZGUsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgZS5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGUuYXR0YWNoRXZlbnRzKCksXG4gICAgICAgICAgICAoZS5pbml0aWFsaXplZCA9ICEwKSxcbiAgICAgICAgICAgIGUuZW1pdChcImluaXRcIiksXG4gICAgICAgICAgICBlLmVtaXQoXCJhZnRlckluaXRcIikpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHIuZGVzdHJveSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gITApLCB2b2lkIDAgPT09IHQgJiYgKHQgPSAhMCk7XG4gICAgICAgICAgdmFyIGEsXG4gICAgICAgICAgICBpID0gdGhpcyxcbiAgICAgICAgICAgIHMgPSBpLnBhcmFtcyxcbiAgICAgICAgICAgIHIgPSBpLiRlbCxcbiAgICAgICAgICAgIG4gPSBpLiR3cmFwcGVyRWwsXG4gICAgICAgICAgICBsID0gaS5zbGlkZXM7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gaS5wYXJhbXMgfHxcbiAgICAgICAgICAgICAgaS5kZXN0cm95ZWQgfHxcbiAgICAgICAgICAgICAgKGkuZW1pdChcImJlZm9yZURlc3Ryb3lcIiksXG4gICAgICAgICAgICAgIChpLmluaXRpYWxpemVkID0gITEpLFxuICAgICAgICAgICAgICBpLmRldGFjaEV2ZW50cygpLFxuICAgICAgICAgICAgICBzLmxvb3AgJiYgaS5sb29wRGVzdHJveSgpLFxuICAgICAgICAgICAgICB0ICYmXG4gICAgICAgICAgICAgICAgKGkucmVtb3ZlQ2xhc3NlcygpLFxuICAgICAgICAgICAgICAgIHIucmVtb3ZlQXR0cihcInN0eWxlXCIpLFxuICAgICAgICAgICAgICAgIG4ucmVtb3ZlQXR0cihcInN0eWxlXCIpLFxuICAgICAgICAgICAgICAgIGwgJiZcbiAgICAgICAgICAgICAgICAgIGwubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICBsXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcbiAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzLnNsaWRlVmlzaWJsZUNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcy5zbGlkZUFjdGl2ZUNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcy5zbGlkZU5leHRDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuc2xpZGVQcmV2Q2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgXS5qb2luKFwiIFwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSksXG4gICAgICAgICAgICAgIGkuZW1pdChcImRlc3Ryb3lcIiksXG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGkuZXZlbnRzTGlzdGVuZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaS5vZmYoZSk7XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAhMSAhPT0gZSAmJlxuICAgICAgICAgICAgICAgICgoaS4kZWxbMF0uc3dpcGVyID0gbnVsbCksXG4gICAgICAgICAgICAgICAgKGEgPSBpKSxcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhW2VdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYVtlXTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAoaS5kZXN0cm95ZWQgPSAhMCkpLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIH0pLFxuICAgICAgICAodC5leHRlbmREZWZhdWx0cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgUyhGLCBlKTtcbiAgICAgICAgfSksXG4gICAgICAgICh0Lmluc3RhbGxNb2R1bGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHQucHJvdG90eXBlLm1vZHVsZXMgfHwgKHQucHJvdG90eXBlLm1vZHVsZXMgPSB7fSk7XG4gICAgICAgICAgdmFyIGEgPSBlLm5hbWUgfHwgT2JqZWN0LmtleXModC5wcm90b3R5cGUubW9kdWxlcykubGVuZ3RoICsgXCJfXCIgKyB4KCk7XG4gICAgICAgICAgdC5wcm90b3R5cGUubW9kdWxlc1thXSA9IGU7XG4gICAgICAgIH0pLFxuICAgICAgICAodC51c2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGUpXG4gICAgICAgICAgICA/IChlLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdC5pbnN0YWxsTW9kdWxlKGUpO1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdClcbiAgICAgICAgICAgIDogKHQuaW5zdGFsbE1vZHVsZShlKSwgdCk7XG4gICAgICAgIH0pLFxuICAgICAgICAoYSA9IHQpLFxuICAgICAgICAocyA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZXh0ZW5kZWREZWZhdWx0c1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBGO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJkZWZhdWx0c1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBZO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICBdKSxcbiAgICAgICAgKGkgPSBudWxsKSAmJiBlKGEucHJvdG90eXBlLCBpKSxcbiAgICAgICAgcyAmJiBlKGEsIHMpLFxuICAgICAgICB0XG4gICAgICApO1xuICAgIH0pKCk7XG4gIE9iamVjdC5rZXlzKFYpLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICBPYmplY3Qua2V5cyhWW2VdKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICBSLnByb3RvdHlwZVt0XSA9IFZbZV1bdF07XG4gICAgfSk7XG4gIH0pLFxuICAgIFIudXNlKFtMLCBJXSk7XG4gIHZhciBXID0ge1xuICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgYSA9IHQucGFyYW1zLFxuICAgICAgICAgIGkgPSBhLnNsaWRlc1BlclZpZXcsXG4gICAgICAgICAgcyA9IGEuc2xpZGVzUGVyR3JvdXAsXG4gICAgICAgICAgciA9IGEuY2VudGVyZWRTbGlkZXMsXG4gICAgICAgICAgbiA9IHQucGFyYW1zLnZpcnR1YWwsXG4gICAgICAgICAgbCA9IG4uYWRkU2xpZGVzQmVmb3JlLFxuICAgICAgICAgIG8gPSBuLmFkZFNsaWRlc0FmdGVyLFxuICAgICAgICAgIGQgPSB0LnZpcnR1YWwsXG4gICAgICAgICAgcCA9IGQuZnJvbSxcbiAgICAgICAgICB1ID0gZC50byxcbiAgICAgICAgICBjID0gZC5zbGlkZXMsXG4gICAgICAgICAgaCA9IGQuc2xpZGVzR3JpZCxcbiAgICAgICAgICB2ID0gZC5yZW5kZXJTbGlkZSxcbiAgICAgICAgICBmID0gZC5vZmZzZXQ7XG4gICAgICAgIHQudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICAgICAgdmFyIG0sXG4gICAgICAgICAgZyxcbiAgICAgICAgICB5LFxuICAgICAgICAgIHcgPSB0LmFjdGl2ZUluZGV4IHx8IDA7XG4gICAgICAgIChtID0gdC5ydGxUcmFuc2xhdGUgPyBcInJpZ2h0XCIgOiB0LmlzSG9yaXpvbnRhbCgpID8gXCJsZWZ0XCIgOiBcInRvcFwiKSxcbiAgICAgICAgICByXG4gICAgICAgICAgICA/ICgoZyA9IE1hdGguZmxvb3IoaSAvIDIpICsgcyArIG8pLCAoeSA9IE1hdGguZmxvb3IoaSAvIDIpICsgcyArIGwpKVxuICAgICAgICAgICAgOiAoKGcgPSBpICsgKHMgLSAxKSArIG8pLCAoeSA9IHMgKyBsKSk7XG4gICAgICAgIHZhciBiID0gTWF0aC5tYXgoKHcgfHwgMCkgLSB5LCAwKSxcbiAgICAgICAgICBFID0gTWF0aC5taW4oKHcgfHwgMCkgKyBnLCBjLmxlbmd0aCAtIDEpLFxuICAgICAgICAgIHggPSAodC5zbGlkZXNHcmlkW2JdIHx8IDApIC0gKHQuc2xpZGVzR3JpZFswXSB8fCAwKTtcbiAgICAgICAgZnVuY3Rpb24gVCgpIHtcbiAgICAgICAgICB0LnVwZGF0ZVNsaWRlcygpLFxuICAgICAgICAgICAgdC51cGRhdGVQcm9ncmVzcygpLFxuICAgICAgICAgICAgdC51cGRhdGVTbGlkZXNDbGFzc2VzKCksXG4gICAgICAgICAgICB0LmxhenkgJiYgdC5wYXJhbXMubGF6eS5lbmFibGVkICYmIHQubGF6eS5sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIChTKHQudmlydHVhbCwge1xuICAgICAgICAgICAgZnJvbTogYixcbiAgICAgICAgICAgIHRvOiBFLFxuICAgICAgICAgICAgb2Zmc2V0OiB4LFxuICAgICAgICAgICAgc2xpZGVzR3JpZDogdC5zbGlkZXNHcmlkLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHAgPT09IGIgJiYgdSA9PT0gRSAmJiAhZSlcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0LnNsaWRlc0dyaWQgIT09IGggJiYgeCAhPT0gZiAmJiB0LnNsaWRlcy5jc3MobSwgeCArIFwicHhcIiksXG4gICAgICAgICAgICB2b2lkIHQudXBkYXRlUHJvZ3Jlc3MoKVxuICAgICAgICAgICk7XG4gICAgICAgIGlmICh0LnBhcmFtcy52aXJ0dWFsLnJlbmRlckV4dGVybmFsKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0LnBhcmFtcy52aXJ0dWFsLnJlbmRlckV4dGVybmFsLmNhbGwodCwge1xuICAgICAgICAgICAgICBvZmZzZXQ6IHgsXG4gICAgICAgICAgICAgIGZyb206IGIsXG4gICAgICAgICAgICAgIHRvOiBFLFxuICAgICAgICAgICAgICBzbGlkZXM6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IFtdLCB0ID0gYjsgdCA8PSBFOyB0ICs9IDEpIGUucHVzaChjW3RdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgfSkoKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdm9pZCAodC5wYXJhbXMudmlydHVhbC5yZW5kZXJFeHRlcm5hbFVwZGF0ZSAmJiBUKCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIEMgPSBbXSxcbiAgICAgICAgICBNID0gW107XG4gICAgICAgIGlmIChlKSB0LiR3cmFwcGVyRWwuZmluZChcIi5cIiArIHQucGFyYW1zLnNsaWRlQ2xhc3MpLnJlbW92ZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yICh2YXIgeiA9IHA7IHogPD0gdTsgeiArPSAxKVxuICAgICAgICAgICAgKHogPCBiIHx8IHogPiBFKSAmJlxuICAgICAgICAgICAgICB0LiR3cmFwcGVyRWxcbiAgICAgICAgICAgICAgICAuZmluZChcbiAgICAgICAgICAgICAgICAgIFwiLlwiICtcbiAgICAgICAgICAgICAgICAgICAgdC5wYXJhbXMuc2xpZGVDbGFzcyArXG4gICAgICAgICAgICAgICAgICAgICdbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInICtcbiAgICAgICAgICAgICAgICAgICAgeiArXG4gICAgICAgICAgICAgICAgICAgICdcIl0nXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgZm9yICh2YXIgUCA9IDA7IFAgPCBjLmxlbmd0aDsgUCArPSAxKVxuICAgICAgICAgIFAgPj0gYiAmJlxuICAgICAgICAgICAgUCA8PSBFICYmXG4gICAgICAgICAgICAodm9pZCAwID09PSB1IHx8IGVcbiAgICAgICAgICAgICAgPyBNLnB1c2goUClcbiAgICAgICAgICAgICAgOiAoUCA+IHUgJiYgTS5wdXNoKFApLCBQIDwgcCAmJiBDLnB1c2goUCkpKTtcbiAgICAgICAgTS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdC4kd3JhcHBlckVsLmFwcGVuZCh2KGNbZV0sIGUpKTtcbiAgICAgICAgfSksXG4gICAgICAgICAgQy5zb3J0KGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gdCAtIGU7XG4gICAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdC4kd3JhcHBlckVsLnByZXBlbmQodihjW2VdLCBlKSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgdC4kd3JhcHBlckVsLmNoaWxkcmVuKFwiLnN3aXBlci1zbGlkZVwiKS5jc3MobSwgeCArIFwicHhcIiksXG4gICAgICAgICAgVCgpO1xuICAgICAgfSxcbiAgICAgIHJlbmRlclNsaWRlOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgaSA9IGEucGFyYW1zLnZpcnR1YWw7XG4gICAgICAgIGlmIChpLmNhY2hlICYmIGEudmlydHVhbC5jYWNoZVt0XSkgcmV0dXJuIGEudmlydHVhbC5jYWNoZVt0XTtcbiAgICAgICAgdmFyIHMgPSBpLnJlbmRlclNsaWRlXG4gICAgICAgICAgPyBtKGkucmVuZGVyU2xpZGUuY2FsbChhLCBlLCB0KSlcbiAgICAgICAgICA6IG0oXG4gICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiJyArXG4gICAgICAgICAgICAgICAgYS5wYXJhbXMuc2xpZGVDbGFzcyArXG4gICAgICAgICAgICAgICAgJ1wiIGRhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJyArXG4gICAgICAgICAgICAgICAgdCArXG4gICAgICAgICAgICAgICAgJ1wiPicgK1xuICAgICAgICAgICAgICAgIGUgK1xuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcy5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIikgfHxcbiAgICAgICAgICAgIHMuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIsIHQpLFxuICAgICAgICAgIGkuY2FjaGUgJiYgKGEudmlydHVhbC5jYWNoZVt0XSA9IHMpLFxuICAgICAgICAgIHNcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBhcHBlbmRTbGlkZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiBcImxlbmd0aFwiIGluIGUpXG4gICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBlLmxlbmd0aDsgYSArPSAxKVxuICAgICAgICAgICAgZVthXSAmJiB0LnZpcnR1YWwuc2xpZGVzLnB1c2goZVthXSk7XG4gICAgICAgIGVsc2UgdC52aXJ0dWFsLnNsaWRlcy5wdXNoKGUpO1xuICAgICAgICB0LnZpcnR1YWwudXBkYXRlKCEwKTtcbiAgICAgIH0sXG4gICAgICBwcmVwZW5kU2xpZGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcyxcbiAgICAgICAgICBhID0gdC5hY3RpdmVJbmRleCxcbiAgICAgICAgICBpID0gYSArIDEsXG4gICAgICAgICAgcyA9IDE7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBlLmxlbmd0aDsgciArPSAxKVxuICAgICAgICAgICAgZVtyXSAmJiB0LnZpcnR1YWwuc2xpZGVzLnVuc2hpZnQoZVtyXSk7XG4gICAgICAgICAgKGkgPSBhICsgZS5sZW5ndGgpLCAocyA9IGUubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHQudmlydHVhbC5zbGlkZXMudW5zaGlmdChlKTtcbiAgICAgICAgaWYgKHQucGFyYW1zLnZpcnR1YWwuY2FjaGUpIHtcbiAgICAgICAgICB2YXIgbiA9IHQudmlydHVhbC5jYWNoZSxcbiAgICAgICAgICAgIGwgPSB7fTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IG5bZV0sXG4gICAgICAgICAgICAgIGEgPSB0LmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKTtcbiAgICAgICAgICAgIGEgJiYgdC5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIiwgcGFyc2VJbnQoYSwgMTApICsgMSksXG4gICAgICAgICAgICAgIChsW3BhcnNlSW50KGUsIDEwKSArIHNdID0gdCk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgICAodC52aXJ0dWFsLmNhY2hlID0gbCk7XG4gICAgICAgIH1cbiAgICAgICAgdC52aXJ0dWFsLnVwZGF0ZSghMCksIHQuc2xpZGVUbyhpLCAwKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVTbGlkZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICBpZiAobnVsbCAhPSBlKSB7XG4gICAgICAgICAgdmFyIGEgPSB0LmFjdGl2ZUluZGV4O1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpXG4gICAgICAgICAgICAgIHQudmlydHVhbC5zbGlkZXMuc3BsaWNlKGVbaV0sIDEpLFxuICAgICAgICAgICAgICAgIHQucGFyYW1zLnZpcnR1YWwuY2FjaGUgJiYgZGVsZXRlIHQudmlydHVhbC5jYWNoZVtlW2ldXSxcbiAgICAgICAgICAgICAgICBlW2ldIDwgYSAmJiAoYSAtPSAxKSxcbiAgICAgICAgICAgICAgICAoYSA9IE1hdGgubWF4KGEsIDApKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0LnZpcnR1YWwuc2xpZGVzLnNwbGljZShlLCAxKSxcbiAgICAgICAgICAgICAgdC5wYXJhbXMudmlydHVhbC5jYWNoZSAmJiBkZWxldGUgdC52aXJ0dWFsLmNhY2hlW2VdLFxuICAgICAgICAgICAgICBlIDwgYSAmJiAoYSAtPSAxKSxcbiAgICAgICAgICAgICAgKGEgPSBNYXRoLm1heChhLCAwKSk7XG4gICAgICAgICAgdC52aXJ0dWFsLnVwZGF0ZSghMCksIHQuc2xpZGVUbyhhLCAwKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUFsbFNsaWRlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgIChlLnZpcnR1YWwuc2xpZGVzID0gW10pLFxuICAgICAgICAgIGUucGFyYW1zLnZpcnR1YWwuY2FjaGUgJiYgKGUudmlydHVhbC5jYWNoZSA9IHt9KSxcbiAgICAgICAgICBlLnZpcnR1YWwudXBkYXRlKCEwKSxcbiAgICAgICAgICBlLnNsaWRlVG8oMCwgMCk7XG4gICAgICB9LFxuICAgIH0sXG4gICAgcSA9IHtcbiAgICAgIG5hbWU6IFwidmlydHVhbFwiLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHZpcnR1YWw6IHtcbiAgICAgICAgICBlbmFibGVkOiAhMSxcbiAgICAgICAgICBzbGlkZXM6IFtdLFxuICAgICAgICAgIGNhY2hlOiAhMCxcbiAgICAgICAgICByZW5kZXJTbGlkZTogbnVsbCxcbiAgICAgICAgICByZW5kZXJFeHRlcm5hbDogbnVsbCxcbiAgICAgICAgICByZW5kZXJFeHRlcm5hbFVwZGF0ZTogITAsXG4gICAgICAgICAgYWRkU2xpZGVzQmVmb3JlOiAwLFxuICAgICAgICAgIGFkZFNsaWRlc0FmdGVyOiAwLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBNKHRoaXMsIHtcbiAgICAgICAgICB2aXJ0dWFsOiB0KHt9LCBXLCB7IHNsaWRlczogdGhpcy5wYXJhbXMudmlydHVhbC5zbGlkZXMsIGNhY2hlOiB7fSB9KSxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgYmVmb3JlSW5pdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoZS5wYXJhbXMudmlydHVhbC5lbmFibGVkKSB7XG4gICAgICAgICAgICBlLmNsYXNzTmFtZXMucHVzaChlLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzICsgXCJ2aXJ0dWFsXCIpO1xuICAgICAgICAgICAgdmFyIHQgPSB7IHdhdGNoU2xpZGVzUHJvZ3Jlc3M6ICEwIH07XG4gICAgICAgICAgICBTKGUucGFyYW1zLCB0KSxcbiAgICAgICAgICAgICAgUyhlLm9yaWdpbmFsUGFyYW1zLCB0KSxcbiAgICAgICAgICAgICAgZS5wYXJhbXMuaW5pdGlhbFNsaWRlIHx8IGUudmlydHVhbC51cGRhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldFRyYW5zbGF0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgZS52aXJ0dWFsLnVwZGF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIGogPSB7XG4gICAgICBoYW5kbGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcyxcbiAgICAgICAgICBhID0gbCgpLFxuICAgICAgICAgIGkgPSByKCksXG4gICAgICAgICAgcyA9IHQucnRsVHJhbnNsYXRlLFxuICAgICAgICAgIG4gPSBlO1xuICAgICAgICBuLm9yaWdpbmFsRXZlbnQgJiYgKG4gPSBuLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICB2YXIgbyA9IG4ua2V5Q29kZSB8fCBuLmNoYXJDb2RlLFxuICAgICAgICAgIGQgPSB0LnBhcmFtcy5rZXlib2FyZC5wYWdlVXBEb3duLFxuICAgICAgICAgIHAgPSBkICYmIDMzID09PSBvLFxuICAgICAgICAgIHUgPSBkICYmIDM0ID09PSBvLFxuICAgICAgICAgIGMgPSAzNyA9PT0gbyxcbiAgICAgICAgICBoID0gMzkgPT09IG8sXG4gICAgICAgICAgdiA9IDM4ID09PSBvLFxuICAgICAgICAgIGYgPSA0MCA9PT0gbztcbiAgICAgICAgaWYgKFxuICAgICAgICAgICF0LmFsbG93U2xpZGVOZXh0ICYmXG4gICAgICAgICAgKCh0LmlzSG9yaXpvbnRhbCgpICYmIGgpIHx8ICh0LmlzVmVydGljYWwoKSAmJiBmKSB8fCB1KVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXQuYWxsb3dTbGlkZVByZXYgJiZcbiAgICAgICAgICAoKHQuaXNIb3Jpem9udGFsKCkgJiYgYykgfHwgKHQuaXNWZXJ0aWNhbCgpICYmIHYpIHx8IHApXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhKFxuICAgICAgICAgICAgbi5zaGlmdEtleSB8fFxuICAgICAgICAgICAgbi5hbHRLZXkgfHxcbiAgICAgICAgICAgIG4uY3RybEtleSB8fFxuICAgICAgICAgICAgbi5tZXRhS2V5IHx8XG4gICAgICAgICAgICAoaS5hY3RpdmVFbGVtZW50ICYmXG4gICAgICAgICAgICAgIGkuYWN0aXZlRWxlbWVudC5ub2RlTmFtZSAmJlxuICAgICAgICAgICAgICAoXCJpbnB1dFwiID09PSBpLmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSB8fFxuICAgICAgICAgICAgICAgIFwidGV4dGFyZWFcIiA9PT0gaS5hY3RpdmVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdC5wYXJhbXMua2V5Ym9hcmQub25seUluVmlld3BvcnQgJiZcbiAgICAgICAgICAgIChwIHx8IHUgfHwgYyB8fCBoIHx8IHYgfHwgZilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBtID0gITE7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHQuJGVsLnBhcmVudHMoXCIuXCIgKyB0LnBhcmFtcy5zbGlkZUNsYXNzKS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgIDAgPT09IHQuJGVsLnBhcmVudHMoXCIuXCIgKyB0LnBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzKS5sZW5ndGhcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGcgPSBhLmlubmVyV2lkdGgsXG4gICAgICAgICAgICAgIHkgPSBhLmlubmVySGVpZ2h0LFxuICAgICAgICAgICAgICB3ID0gdC4kZWwub2Zmc2V0KCk7XG4gICAgICAgICAgICBzICYmICh3LmxlZnQgLT0gdC4kZWxbMF0uc2Nyb2xsTGVmdCk7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgYiA9IFtcbiAgICAgICAgICAgICAgICAgIFt3LmxlZnQsIHcudG9wXSxcbiAgICAgICAgICAgICAgICAgIFt3LmxlZnQgKyB0LndpZHRoLCB3LnRvcF0sXG4gICAgICAgICAgICAgICAgICBbdy5sZWZ0LCB3LnRvcCArIHQuaGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAgIFt3LmxlZnQgKyB0LndpZHRoLCB3LnRvcCArIHQuaGVpZ2h0XSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIEUgPSAwO1xuICAgICAgICAgICAgICBFIDwgYi5sZW5ndGg7XG4gICAgICAgICAgICAgIEUgKz0gMVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciB4ID0gYltFXTtcbiAgICAgICAgICAgICAgaWYgKHhbMF0gPj0gMCAmJiB4WzBdIDw9IGcgJiYgeFsxXSA+PSAwICYmIHhbMV0gPD0geSkge1xuICAgICAgICAgICAgICAgIGlmICgwID09PSB4WzBdICYmIDAgPT09IHhbMV0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIG0gPSAhMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtKSByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHQuaXNIb3Jpem9udGFsKClcbiAgICAgICAgICAgID8gKChwIHx8IHUgfHwgYyB8fCBoKSAmJlxuICAgICAgICAgICAgICAgIChuLnByZXZlbnREZWZhdWx0ID8gbi5wcmV2ZW50RGVmYXVsdCgpIDogKG4ucmV0dXJuVmFsdWUgPSAhMSkpLFxuICAgICAgICAgICAgICAoKCh1IHx8IGgpICYmICFzKSB8fCAoKHAgfHwgYykgJiYgcykpICYmIHQuc2xpZGVOZXh0KCksXG4gICAgICAgICAgICAgICgoKHAgfHwgYykgJiYgIXMpIHx8ICgodSB8fCBoKSAmJiBzKSkgJiYgdC5zbGlkZVByZXYoKSlcbiAgICAgICAgICAgIDogKChwIHx8IHUgfHwgdiB8fCBmKSAmJlxuICAgICAgICAgICAgICAgIChuLnByZXZlbnREZWZhdWx0ID8gbi5wcmV2ZW50RGVmYXVsdCgpIDogKG4ucmV0dXJuVmFsdWUgPSAhMSkpLFxuICAgICAgICAgICAgICAodSB8fCBmKSAmJiB0LnNsaWRlTmV4dCgpLFxuICAgICAgICAgICAgICAocCB8fCB2KSAmJiB0LnNsaWRlUHJldigpKSxcbiAgICAgICAgICAgIHQuZW1pdChcImtleVByZXNzXCIsIG8pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICB0ID0gcigpO1xuICAgICAgICBlLmtleWJvYXJkLmVuYWJsZWQgfHxcbiAgICAgICAgICAobSh0KS5vbihcImtleWRvd25cIiwgZS5rZXlib2FyZC5oYW5kbGUpLCAoZS5rZXlib2FyZC5lbmFibGVkID0gITApKTtcbiAgICAgIH0sXG4gICAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICB0ID0gcigpO1xuICAgICAgICBlLmtleWJvYXJkLmVuYWJsZWQgJiZcbiAgICAgICAgICAobSh0KS5vZmYoXCJrZXlkb3duXCIsIGUua2V5Ym9hcmQuaGFuZGxlKSwgKGUua2V5Ym9hcmQuZW5hYmxlZCA9ICExKSk7XG4gICAgICB9LFxuICAgIH0sXG4gICAgXyA9IHtcbiAgICAgIG5hbWU6IFwia2V5Ym9hcmRcIixcbiAgICAgIHBhcmFtczogeyBrZXlib2FyZDogeyBlbmFibGVkOiAhMSwgb25seUluVmlld3BvcnQ6ICEwLCBwYWdlVXBEb3duOiAhMCB9IH0sXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgTSh0aGlzLCB7IGtleWJvYXJkOiB0KHsgZW5hYmxlZDogITEgfSwgaikgfSk7XG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLnBhcmFtcy5rZXlib2FyZC5lbmFibGVkICYmIGUua2V5Ym9hcmQuZW5hYmxlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5rZXlib2FyZC5lbmFibGVkICYmIGUua2V5Ym9hcmQuZGlzYWJsZSgpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICB2YXIgVSA9IHtcbiAgICAgIGxhc3RTY3JvbGxUaW1lOiB4KCksXG4gICAgICBsYXN0RXZlbnRCZWZvcmVTbmFwOiB2b2lkIDAsXG4gICAgICByZWNlbnRXaGVlbEV2ZW50czogW10sXG4gICAgICBldmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbCgpLm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcImZpcmVmb3hcIikgPiAtMVxuICAgICAgICAgID8gXCJET01Nb3VzZVNjcm9sbFwiXG4gICAgICAgICAgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgZSA9IHIoKSxcbiAgICAgICAgICAgICAgICB0ID0gXCJvbndoZWVsXCIsXG4gICAgICAgICAgICAgICAgYSA9IHQgaW4gZTtcbiAgICAgICAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgaS5zZXRBdHRyaWJ1dGUodCwgXCJyZXR1cm47XCIpLFxuICAgICAgICAgICAgICAgICAgKGEgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGkub253aGVlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAhYSAmJlxuICAgICAgICAgICAgICAgICAgZS5pbXBsZW1lbnRhdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgZS5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gICAgICAgICAgICAgICAgICAhMCAhPT0gZS5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFwiXCIsIFwiXCIpICYmXG4gICAgICAgICAgICAgICAgICAoYSA9IGUuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcIkV2ZW50cy53aGVlbFwiLCBcIjMuMFwiKSksXG4gICAgICAgICAgICAgICAgYVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSkoKVxuICAgICAgICAgID8gXCJ3aGVlbFwiXG4gICAgICAgICAgOiBcIm1vdXNld2hlZWxcIjtcbiAgICAgIH0sXG4gICAgICBub3JtYWxpemU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0ID0gMCxcbiAgICAgICAgICBhID0gMCxcbiAgICAgICAgICBpID0gMCxcbiAgICAgICAgICBzID0gMDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBcImRldGFpbFwiIGluIGUgJiYgKGEgPSBlLmRldGFpbCksXG4gICAgICAgICAgXCJ3aGVlbERlbHRhXCIgaW4gZSAmJiAoYSA9IC1lLndoZWVsRGVsdGEgLyAxMjApLFxuICAgICAgICAgIFwid2hlZWxEZWx0YVlcIiBpbiBlICYmIChhID0gLWUud2hlZWxEZWx0YVkgLyAxMjApLFxuICAgICAgICAgIFwid2hlZWxEZWx0YVhcIiBpbiBlICYmICh0ID0gLWUud2hlZWxEZWx0YVggLyAxMjApLFxuICAgICAgICAgIFwiYXhpc1wiIGluIGUgJiYgZS5heGlzID09PSBlLkhPUklaT05UQUxfQVhJUyAmJiAoKHQgPSBhKSwgKGEgPSAwKSksXG4gICAgICAgICAgKGkgPSAxMCAqIHQpLFxuICAgICAgICAgIChzID0gMTAgKiBhKSxcbiAgICAgICAgICBcImRlbHRhWVwiIGluIGUgJiYgKHMgPSBlLmRlbHRhWSksXG4gICAgICAgICAgXCJkZWx0YVhcIiBpbiBlICYmIChpID0gZS5kZWx0YVgpLFxuICAgICAgICAgIGUuc2hpZnRLZXkgJiYgIWkgJiYgKChpID0gcyksIChzID0gMCkpLFxuICAgICAgICAgIChpIHx8IHMpICYmXG4gICAgICAgICAgICBlLmRlbHRhTW9kZSAmJlxuICAgICAgICAgICAgKDEgPT09IGUuZGVsdGFNb2RlXG4gICAgICAgICAgICAgID8gKChpICo9IDQwKSwgKHMgKj0gNDApKVxuICAgICAgICAgICAgICA6ICgoaSAqPSA4MDApLCAocyAqPSA4MDApKSksXG4gICAgICAgICAgaSAmJiAhdCAmJiAodCA9IGkgPCAxID8gLTEgOiAxKSxcbiAgICAgICAgICBzICYmICFhICYmIChhID0gcyA8IDEgPyAtMSA6IDEpLFxuICAgICAgICAgIHsgc3Bpblg6IHQsIHNwaW5ZOiBhLCBwaXhlbFg6IGksIHBpeGVsWTogcyB9XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlTW91c2VFbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1vdXNlRW50ZXJlZCA9ICEwO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZU1vdXNlTGVhdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tb3VzZUVudGVyZWQgPSAhMTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0ID0gZSxcbiAgICAgICAgICBhID0gdGhpcyxcbiAgICAgICAgICBpID0gYS5wYXJhbXMubW91c2V3aGVlbDtcbiAgICAgICAgYS5wYXJhbXMuY3NzTW9kZSAmJiB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBzID0gYS4kZWw7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJjb250YWluZXJcIiAhPT0gYS5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQgJiZcbiAgICAgICAgICAgIChzID0gbShhLnBhcmFtcy5tb3VzZXdoZWVsLmV2ZW50c1RhcmdldCkpLFxuICAgICAgICAgICFhLm1vdXNlRW50ZXJlZCAmJiAhc1swXS5jb250YWlucyh0LnRhcmdldCkgJiYgIWkucmVsZWFzZU9uRWRnZXMpXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIHQub3JpZ2luYWxFdmVudCAmJiAodCA9IHQub3JpZ2luYWxFdmVudCk7XG4gICAgICAgIHZhciByID0gMCxcbiAgICAgICAgICBuID0gYS5ydGxUcmFuc2xhdGUgPyAtMSA6IDEsXG4gICAgICAgICAgbCA9IFUubm9ybWFsaXplKHQpO1xuICAgICAgICBpZiAoaS5mb3JjZVRvQXhpcylcbiAgICAgICAgICBpZiAoYS5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgaWYgKCEoTWF0aC5hYnMobC5waXhlbFgpID4gTWF0aC5hYnMobC5waXhlbFkpKSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgciA9IC1sLnBpeGVsWCAqIG47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKE1hdGguYWJzKGwucGl4ZWxZKSA+IE1hdGguYWJzKGwucGl4ZWxYKSkpIHJldHVybiAhMDtcbiAgICAgICAgICAgIHIgPSAtbC5waXhlbFk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgciA9XG4gICAgICAgICAgICBNYXRoLmFicyhsLnBpeGVsWCkgPiBNYXRoLmFicyhsLnBpeGVsWSkgPyAtbC5waXhlbFggKiBuIDogLWwucGl4ZWxZO1xuICAgICAgICBpZiAoMCA9PT0gcikgcmV0dXJuICEwO1xuICAgICAgICBpLmludmVydCAmJiAociA9IC1yKTtcbiAgICAgICAgdmFyIG8gPSBhLmdldFRyYW5zbGF0ZSgpICsgciAqIGkuc2Vuc2l0aXZpdHk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAobyA+PSBhLm1pblRyYW5zbGF0ZSgpICYmIChvID0gYS5taW5UcmFuc2xhdGUoKSksXG4gICAgICAgICAgbyA8PSBhLm1heFRyYW5zbGF0ZSgpICYmIChvID0gYS5tYXhUcmFuc2xhdGUoKSksXG4gICAgICAgICAgKCEhYS5wYXJhbXMubG9vcCB8fFxuICAgICAgICAgICAgIShvID09PSBhLm1pblRyYW5zbGF0ZSgpIHx8IG8gPT09IGEubWF4VHJhbnNsYXRlKCkpKSAmJlxuICAgICAgICAgICAgYS5wYXJhbXMubmVzdGVkICYmXG4gICAgICAgICAgICB0LnN0b3BQcm9wYWdhdGlvbigpLFxuICAgICAgICAgIGEucGFyYW1zLmZyZWVNb2RlKVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgZCA9IHsgdGltZTogeCgpLCBkZWx0YTogTWF0aC5hYnMociksIGRpcmVjdGlvbjogTWF0aC5zaWduKHIpIH0sXG4gICAgICAgICAgICBwID0gYS5tb3VzZXdoZWVsLmxhc3RFdmVudEJlZm9yZVNuYXAsXG4gICAgICAgICAgICB1ID1cbiAgICAgICAgICAgICAgcCAmJlxuICAgICAgICAgICAgICBkLnRpbWUgPCBwLnRpbWUgKyA1MDAgJiZcbiAgICAgICAgICAgICAgZC5kZWx0YSA8PSBwLmRlbHRhICYmXG4gICAgICAgICAgICAgIGQuZGlyZWN0aW9uID09PSBwLmRpcmVjdGlvbjtcbiAgICAgICAgICBpZiAoIXUpIHtcbiAgICAgICAgICAgIChhLm1vdXNld2hlZWwubGFzdEV2ZW50QmVmb3JlU25hcCA9IHZvaWQgMCksXG4gICAgICAgICAgICAgIGEucGFyYW1zLmxvb3AgJiYgYS5sb29wRml4KCk7XG4gICAgICAgICAgICB2YXIgYyA9IGEuZ2V0VHJhbnNsYXRlKCkgKyByICogaS5zZW5zaXRpdml0eSxcbiAgICAgICAgICAgICAgaCA9IGEuaXNCZWdpbm5pbmcsXG4gICAgICAgICAgICAgIHYgPSBhLmlzRW5kO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoYyA+PSBhLm1pblRyYW5zbGF0ZSgpICYmIChjID0gYS5taW5UcmFuc2xhdGUoKSksXG4gICAgICAgICAgICAgIGMgPD0gYS5tYXhUcmFuc2xhdGUoKSAmJiAoYyA9IGEubWF4VHJhbnNsYXRlKCkpLFxuICAgICAgICAgICAgICBhLnNldFRyYW5zaXRpb24oMCksXG4gICAgICAgICAgICAgIGEuc2V0VHJhbnNsYXRlKGMpLFxuICAgICAgICAgICAgICBhLnVwZGF0ZVByb2dyZXNzKCksXG4gICAgICAgICAgICAgIGEudXBkYXRlQWN0aXZlSW5kZXgoKSxcbiAgICAgICAgICAgICAgYS51cGRhdGVTbGlkZXNDbGFzc2VzKCksXG4gICAgICAgICAgICAgICgoIWggJiYgYS5pc0JlZ2lubmluZykgfHwgKCF2ICYmIGEuaXNFbmQpKSAmJlxuICAgICAgICAgICAgICAgIGEudXBkYXRlU2xpZGVzQ2xhc3NlcygpLFxuICAgICAgICAgICAgICBhLnBhcmFtcy5mcmVlTW9kZVN0aWNreSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoYS5tb3VzZXdoZWVsLnRpbWVvdXQpLFxuICAgICAgICAgICAgICAgIChhLm1vdXNld2hlZWwudGltZW91dCA9IHZvaWQgMCk7XG4gICAgICAgICAgICAgIHZhciBmID0gYS5tb3VzZXdoZWVsLnJlY2VudFdoZWVsRXZlbnRzO1xuICAgICAgICAgICAgICBmLmxlbmd0aCA+PSAxNSAmJiBmLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIHZhciBnID0gZi5sZW5ndGggPyBmW2YubGVuZ3RoIC0gMV0gOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgeSA9IGZbMF07XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZi5wdXNoKGQpLFxuICAgICAgICAgICAgICAgIGcgJiYgKGQuZGVsdGEgPiBnLmRlbHRhIHx8IGQuZGlyZWN0aW9uICE9PSBnLmRpcmVjdGlvbikpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBmLnNwbGljZSgwKTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgZi5sZW5ndGggPj0gMTUgJiZcbiAgICAgICAgICAgICAgICBkLnRpbWUgLSB5LnRpbWUgPCA1MDAgJiZcbiAgICAgICAgICAgICAgICB5LmRlbHRhIC0gZC5kZWx0YSA+PSAxICYmXG4gICAgICAgICAgICAgICAgZC5kZWx0YSA8PSA2XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciB3ID0gciA+IDAgPyAwLjggOiAwLjI7XG4gICAgICAgICAgICAgICAgKGEubW91c2V3aGVlbC5sYXN0RXZlbnRCZWZvcmVTbmFwID0gZCksXG4gICAgICAgICAgICAgICAgICBmLnNwbGljZSgwKSxcbiAgICAgICAgICAgICAgICAgIChhLm1vdXNld2hlZWwudGltZW91dCA9IEUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBhLnNsaWRlVG9DbG9zZXN0KGEucGFyYW1zLnNwZWVkLCAhMCwgdm9pZCAwLCB3KTtcbiAgICAgICAgICAgICAgICAgIH0sIDApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhLm1vdXNld2hlZWwudGltZW91dCB8fFxuICAgICAgICAgICAgICAgIChhLm1vdXNld2hlZWwudGltZW91dCA9IEUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgKGEubW91c2V3aGVlbC5sYXN0RXZlbnRCZWZvcmVTbmFwID0gZCksXG4gICAgICAgICAgICAgICAgICAgIGYuc3BsaWNlKDApLFxuICAgICAgICAgICAgICAgICAgICBhLnNsaWRlVG9DbG9zZXN0KGEucGFyYW1zLnNwZWVkLCAhMCwgdm9pZCAwLCAwLjUpO1xuICAgICAgICAgICAgICAgIH0sIDUwMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAodSB8fCBhLmVtaXQoXCJzY3JvbGxcIiwgdCksXG4gICAgICAgICAgICAgIGEucGFyYW1zLmF1dG9wbGF5ICYmXG4gICAgICAgICAgICAgICAgYS5wYXJhbXMuYXV0b3BsYXlEaXNhYmxlT25JbnRlcmFjdGlvbiAmJlxuICAgICAgICAgICAgICAgIGEuYXV0b3BsYXkuc3RvcCgpLFxuICAgICAgICAgICAgICBjID09PSBhLm1pblRyYW5zbGF0ZSgpIHx8IGMgPT09IGEubWF4VHJhbnNsYXRlKCkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGIgPSB7XG4gICAgICAgICAgICAgIHRpbWU6IHgoKSxcbiAgICAgICAgICAgICAgZGVsdGE6IE1hdGguYWJzKHIpLFxuICAgICAgICAgICAgICBkaXJlY3Rpb246IE1hdGguc2lnbihyKSxcbiAgICAgICAgICAgICAgcmF3OiBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFQgPSBhLm1vdXNld2hlZWwucmVjZW50V2hlZWxFdmVudHM7XG4gICAgICAgICAgVC5sZW5ndGggPj0gMiAmJiBULnNoaWZ0KCk7XG4gICAgICAgICAgdmFyIEMgPSBULmxlbmd0aCA/IFRbVC5sZW5ndGggLSAxXSA6IHZvaWQgMDtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoVC5wdXNoKGIpLFxuICAgICAgICAgICAgQ1xuICAgICAgICAgICAgICA/IChiLmRpcmVjdGlvbiAhPT0gQy5kaXJlY3Rpb24gfHxcbiAgICAgICAgICAgICAgICAgIGIuZGVsdGEgPiBDLmRlbHRhIHx8XG4gICAgICAgICAgICAgICAgICBiLnRpbWUgPiBDLnRpbWUgKyAxNTApICYmXG4gICAgICAgICAgICAgICAgYS5tb3VzZXdoZWVsLmFuaW1hdGVTbGlkZXIoYilcbiAgICAgICAgICAgICAgOiBhLm1vdXNld2hlZWwuYW5pbWF0ZVNsaWRlcihiKSxcbiAgICAgICAgICAgIGEubW91c2V3aGVlbC5yZWxlYXNlU2Nyb2xsKGIpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdC5wcmV2ZW50RGVmYXVsdCA/IHQucHJldmVudERlZmF1bHQoKSA6ICh0LnJldHVyblZhbHVlID0gITEpLCAhMTtcbiAgICAgIH0sXG4gICAgICBhbmltYXRlU2xpZGVyOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgYSA9IGwoKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAhKFxuICAgICAgICAgICAgdGhpcy5wYXJhbXMubW91c2V3aGVlbC50aHJlc2hvbGREZWx0YSAmJlxuICAgICAgICAgICAgZS5kZWx0YSA8IHRoaXMucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkRGVsdGFcbiAgICAgICAgICApICYmXG4gICAgICAgICAgIShcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkVGltZSAmJlxuICAgICAgICAgICAgeCgpIC0gdC5tb3VzZXdoZWVsLmxhc3RTY3JvbGxUaW1lIDxcbiAgICAgICAgICAgICAgdGhpcy5wYXJhbXMubW91c2V3aGVlbC50aHJlc2hvbGRUaW1lXG4gICAgICAgICAgKSAmJlxuICAgICAgICAgICgoZS5kZWx0YSA+PSA2ICYmIHgoKSAtIHQubW91c2V3aGVlbC5sYXN0U2Nyb2xsVGltZSA8IDYwKSB8fFxuICAgICAgICAgICAgKGUuZGlyZWN0aW9uIDwgMFxuICAgICAgICAgICAgICA/ICh0LmlzRW5kICYmICF0LnBhcmFtcy5sb29wKSB8fFxuICAgICAgICAgICAgICAgIHQuYW5pbWF0aW5nIHx8XG4gICAgICAgICAgICAgICAgKHQuc2xpZGVOZXh0KCksIHQuZW1pdChcInNjcm9sbFwiLCBlLnJhdykpXG4gICAgICAgICAgICAgIDogKHQuaXNCZWdpbm5pbmcgJiYgIXQucGFyYW1zLmxvb3ApIHx8XG4gICAgICAgICAgICAgICAgdC5hbmltYXRpbmcgfHxcbiAgICAgICAgICAgICAgICAodC5zbGlkZVByZXYoKSwgdC5lbWl0KFwic2Nyb2xsXCIsIGUucmF3KSksXG4gICAgICAgICAgICAodC5tb3VzZXdoZWVsLmxhc3RTY3JvbGxUaW1lID0gbmV3IGEuRGF0ZSgpLmdldFRpbWUoKSksXG4gICAgICAgICAgICAhMSkpXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgcmVsZWFzZVNjcm9sbDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLFxuICAgICAgICAgIGEgPSB0LnBhcmFtcy5tb3VzZXdoZWVsO1xuICAgICAgICBpZiAoZS5kaXJlY3Rpb24gPCAwKSB7XG4gICAgICAgICAgaWYgKHQuaXNFbmQgJiYgIXQucGFyYW1zLmxvb3AgJiYgYS5yZWxlYXNlT25FZGdlcykgcmV0dXJuICEwO1xuICAgICAgICB9IGVsc2UgaWYgKHQuaXNCZWdpbm5pbmcgJiYgIXQucGFyYW1zLmxvb3AgJiYgYS5yZWxlYXNlT25FZGdlcylcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sXG4gICAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgIHQgPSBVLmV2ZW50KCk7XG4gICAgICAgIGlmIChlLnBhcmFtcy5jc3NNb2RlKVxuICAgICAgICAgIHJldHVybiBlLndyYXBwZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKHQsIGUubW91c2V3aGVlbC5oYW5kbGUpLCAhMDtcbiAgICAgICAgaWYgKCF0KSByZXR1cm4gITE7XG4gICAgICAgIGlmIChlLm1vdXNld2hlZWwuZW5hYmxlZCkgcmV0dXJuICExO1xuICAgICAgICB2YXIgYSA9IGUuJGVsO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIFwiY29udGFpbmVyXCIgIT09IGUucGFyYW1zLm1vdXNld2hlZWwuZXZlbnRzVGFyZ2V0ICYmXG4gICAgICAgICAgICAoYSA9IG0oZS5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQpKSxcbiAgICAgICAgICBhLm9uKFwibW91c2VlbnRlclwiLCBlLm1vdXNld2hlZWwuaGFuZGxlTW91c2VFbnRlciksXG4gICAgICAgICAgYS5vbihcIm1vdXNlbGVhdmVcIiwgZS5tb3VzZXdoZWVsLmhhbmRsZU1vdXNlTGVhdmUpLFxuICAgICAgICAgIGEub24odCwgZS5tb3VzZXdoZWVsLmhhbmRsZSksXG4gICAgICAgICAgKGUubW91c2V3aGVlbC5lbmFibGVkID0gITApLFxuICAgICAgICAgICEwXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgdCA9IFUuZXZlbnQoKTtcbiAgICAgICAgaWYgKGUucGFyYW1zLmNzc01vZGUpXG4gICAgICAgICAgcmV0dXJuIGUud3JhcHBlckVsLmFkZEV2ZW50TGlzdGVuZXIodCwgZS5tb3VzZXdoZWVsLmhhbmRsZSksICEwO1xuICAgICAgICBpZiAoIXQpIHJldHVybiAhMTtcbiAgICAgICAgaWYgKCFlLm1vdXNld2hlZWwuZW5hYmxlZCkgcmV0dXJuICExO1xuICAgICAgICB2YXIgYSA9IGUuJGVsO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIFwiY29udGFpbmVyXCIgIT09IGUucGFyYW1zLm1vdXNld2hlZWwuZXZlbnRzVGFyZ2V0ICYmXG4gICAgICAgICAgICAoYSA9IG0oZS5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQpKSxcbiAgICAgICAgICBhLm9mZih0LCBlLm1vdXNld2hlZWwuaGFuZGxlKSxcbiAgICAgICAgICAoZS5tb3VzZXdoZWVsLmVuYWJsZWQgPSAhMSksXG4gICAgICAgICAgITBcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICBLID0ge1xuICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICB0ID0gZS5wYXJhbXMubmF2aWdhdGlvbjtcbiAgICAgICAgaWYgKCFlLnBhcmFtcy5sb29wKSB7XG4gICAgICAgICAgdmFyIGEgPSBlLm5hdmlnYXRpb24sXG4gICAgICAgICAgICBpID0gYS4kbmV4dEVsLFxuICAgICAgICAgICAgcyA9IGEuJHByZXZFbDtcbiAgICAgICAgICBzICYmXG4gICAgICAgICAgICBzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIChlLmlzQmVnaW5uaW5nXG4gICAgICAgICAgICAgID8gcy5hZGRDbGFzcyh0LmRpc2FibGVkQ2xhc3MpXG4gICAgICAgICAgICAgIDogcy5yZW1vdmVDbGFzcyh0LmRpc2FibGVkQ2xhc3MpLFxuICAgICAgICAgICAgc1tcbiAgICAgICAgICAgICAgZS5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBlLmlzTG9ja2VkID8gXCJhZGRDbGFzc1wiIDogXCJyZW1vdmVDbGFzc1wiXG4gICAgICAgICAgICBdKHQubG9ja0NsYXNzKSksXG4gICAgICAgICAgICBpICYmXG4gICAgICAgICAgICAgIGkubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAoZS5pc0VuZFxuICAgICAgICAgICAgICAgID8gaS5hZGRDbGFzcyh0LmRpc2FibGVkQ2xhc3MpXG4gICAgICAgICAgICAgICAgOiBpLnJlbW92ZUNsYXNzKHQuZGlzYWJsZWRDbGFzcyksXG4gICAgICAgICAgICAgIGlbXG4gICAgICAgICAgICAgICAgZS5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBlLmlzTG9ja2VkXG4gICAgICAgICAgICAgICAgICA/IFwiYWRkQ2xhc3NcIlxuICAgICAgICAgICAgICAgICAgOiBcInJlbW92ZUNsYXNzXCJcbiAgICAgICAgICAgICAgXSh0LmxvY2tDbGFzcykpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25QcmV2Q2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCAodC5pc0JlZ2lubmluZyAmJiAhdC5wYXJhbXMubG9vcCkgfHwgdC5zbGlkZVByZXYoKTtcbiAgICAgIH0sXG4gICAgICBvbk5leHRDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCksICh0LmlzRW5kICYmICF0LnBhcmFtcy5sb29wKSB8fCB0LnNsaWRlTmV4dCgpO1xuICAgICAgfSxcbiAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUsXG4gICAgICAgICAgdCxcbiAgICAgICAgICBhID0gdGhpcyxcbiAgICAgICAgICBpID0gYS5wYXJhbXMubmF2aWdhdGlvbjtcbiAgICAgICAgKGkubmV4dEVsIHx8IGkucHJldkVsKSAmJlxuICAgICAgICAgIChpLm5leHRFbCAmJlxuICAgICAgICAgICAgKChlID0gbShpLm5leHRFbCkpLFxuICAgICAgICAgICAgYS5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHMgJiZcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgaS5uZXh0RWwgJiZcbiAgICAgICAgICAgICAgZS5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAgIDEgPT09IGEuJGVsLmZpbmQoaS5uZXh0RWwpLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAoZSA9IGEuJGVsLmZpbmQoaS5uZXh0RWwpKSksXG4gICAgICAgICAgaS5wcmV2RWwgJiZcbiAgICAgICAgICAgICgodCA9IG0oaS5wcmV2RWwpKSxcbiAgICAgICAgICAgIGEucGFyYW1zLnVuaXF1ZU5hdkVsZW1lbnRzICYmXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIGkucHJldkVsICYmXG4gICAgICAgICAgICAgIHQubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgICAxID09PSBhLiRlbC5maW5kKGkucHJldkVsKS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgKHQgPSBhLiRlbC5maW5kKGkucHJldkVsKSkpLFxuICAgICAgICAgIGUgJiYgZS5sZW5ndGggPiAwICYmIGUub24oXCJjbGlja1wiLCBhLm5hdmlnYXRpb24ub25OZXh0Q2xpY2spLFxuICAgICAgICAgIHQgJiYgdC5sZW5ndGggPiAwICYmIHQub24oXCJjbGlja1wiLCBhLm5hdmlnYXRpb24ub25QcmV2Q2xpY2spLFxuICAgICAgICAgIFMoYS5uYXZpZ2F0aW9uLCB7XG4gICAgICAgICAgICAkbmV4dEVsOiBlLFxuICAgICAgICAgICAgbmV4dEVsOiBlICYmIGVbMF0sXG4gICAgICAgICAgICAkcHJldkVsOiB0LFxuICAgICAgICAgICAgcHJldkVsOiB0ICYmIHRbMF0sXG4gICAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgIHQgPSBlLm5hdmlnYXRpb24sXG4gICAgICAgICAgYSA9IHQuJG5leHRFbCxcbiAgICAgICAgICBpID0gdC4kcHJldkVsO1xuICAgICAgICBhICYmXG4gICAgICAgICAgYS5sZW5ndGggJiZcbiAgICAgICAgICAoYS5vZmYoXCJjbGlja1wiLCBlLm5hdmlnYXRpb24ub25OZXh0Q2xpY2spLFxuICAgICAgICAgIGEucmVtb3ZlQ2xhc3MoZS5wYXJhbXMubmF2aWdhdGlvbi5kaXNhYmxlZENsYXNzKSksXG4gICAgICAgICAgaSAmJlxuICAgICAgICAgICAgaS5sZW5ndGggJiZcbiAgICAgICAgICAgIChpLm9mZihcImNsaWNrXCIsIGUubmF2aWdhdGlvbi5vblByZXZDbGljayksXG4gICAgICAgICAgICBpLnJlbW92ZUNsYXNzKGUucGFyYW1zLm5hdmlnYXRpb24uZGlzYWJsZWRDbGFzcykpO1xuICAgICAgfSxcbiAgICB9LFxuICAgIFogPSB7XG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgIHQgPSBlLnJ0bCxcbiAgICAgICAgICBhID0gZS5wYXJhbXMucGFnaW5hdGlvbjtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGEuZWwgJiZcbiAgICAgICAgICBlLnBhZ2luYXRpb24uZWwgJiZcbiAgICAgICAgICBlLnBhZ2luYXRpb24uJGVsICYmXG4gICAgICAgICAgMCAhPT0gZS5wYWdpbmF0aW9uLiRlbC5sZW5ndGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBzID1cbiAgICAgICAgICAgICAgZS52aXJ0dWFsICYmIGUucGFyYW1zLnZpcnR1YWwuZW5hYmxlZFxuICAgICAgICAgICAgICAgID8gZS52aXJ0dWFsLnNsaWRlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICA6IGUuc2xpZGVzLmxlbmd0aCxcbiAgICAgICAgICAgIHIgPSBlLnBhZ2luYXRpb24uJGVsLFxuICAgICAgICAgICAgbiA9IGUucGFyYW1zLmxvb3BcbiAgICAgICAgICAgICAgPyBNYXRoLmNlaWwoKHMgLSAyICogZS5sb29wZWRTbGlkZXMpIC8gZS5wYXJhbXMuc2xpZGVzUGVyR3JvdXApXG4gICAgICAgICAgICAgIDogZS5zbmFwR3JpZC5sZW5ndGg7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGUucGFyYW1zLmxvb3BcbiAgICAgICAgICAgICAgPyAoKGkgPSBNYXRoLmNlaWwoXG4gICAgICAgICAgICAgICAgICAoZS5hY3RpdmVJbmRleCAtIGUubG9vcGVkU2xpZGVzKSAvIGUucGFyYW1zLnNsaWRlc1Blckdyb3VwXG4gICAgICAgICAgICAgICAgKSkgPlxuICAgICAgICAgICAgICAgICAgcyAtIDEgLSAyICogZS5sb29wZWRTbGlkZXMgJiYgKGkgLT0gcyAtIDIgKiBlLmxvb3BlZFNsaWRlcyksXG4gICAgICAgICAgICAgICAgaSA+IG4gLSAxICYmIChpIC09IG4pLFxuICAgICAgICAgICAgICAgIGkgPCAwICYmIFwiYnVsbGV0c1wiICE9PSBlLnBhcmFtcy5wYWdpbmF0aW9uVHlwZSAmJiAoaSA9IG4gKyBpKSlcbiAgICAgICAgICAgICAgOiAoaSA9IHZvaWQgMCAhPT0gZS5zbmFwSW5kZXggPyBlLnNuYXBJbmRleCA6IGUuYWN0aXZlSW5kZXggfHwgMCksXG4gICAgICAgICAgICBcImJ1bGxldHNcIiA9PT0gYS50eXBlICYmXG4gICAgICAgICAgICAgIGUucGFnaW5hdGlvbi5idWxsZXRzICYmXG4gICAgICAgICAgICAgIGUucGFnaW5hdGlvbi5idWxsZXRzLmxlbmd0aCA+IDApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgbCxcbiAgICAgICAgICAgICAgbyxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICAgcCA9IGUucGFnaW5hdGlvbi5idWxsZXRzO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoYS5keW5hbWljQnVsbGV0cyAmJlxuICAgICAgICAgICAgICAgICgoZS5wYWdpbmF0aW9uLmJ1bGxldFNpemUgPSBwXG4gICAgICAgICAgICAgICAgICAuZXEoMClcbiAgICAgICAgICAgICAgICAgIFtlLmlzSG9yaXpvbnRhbCgpID8gXCJvdXRlcldpZHRoXCIgOiBcIm91dGVySGVpZ2h0XCJdKCEwKSksXG4gICAgICAgICAgICAgICAgci5jc3MoXG4gICAgICAgICAgICAgICAgICBlLmlzSG9yaXpvbnRhbCgpID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIixcbiAgICAgICAgICAgICAgICAgIGUucGFnaW5hdGlvbi5idWxsZXRTaXplICogKGEuZHluYW1pY01haW5CdWxsZXRzICsgNCkgKyBcInB4XCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGEuZHluYW1pY01haW5CdWxsZXRzID4gMSAmJlxuICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBlLnByZXZpb3VzSW5kZXggJiZcbiAgICAgICAgICAgICAgICAgICgoZS5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleCArPSBpIC0gZS5wcmV2aW91c0luZGV4KSxcbiAgICAgICAgICAgICAgICAgIGUucGFnaW5hdGlvbi5keW5hbWljQnVsbGV0SW5kZXggPiBhLmR5bmFtaWNNYWluQnVsbGV0cyAtIDFcbiAgICAgICAgICAgICAgICAgICAgPyAoZS5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBhLmR5bmFtaWNNYWluQnVsbGV0cyAtIDEpXG4gICAgICAgICAgICAgICAgICAgIDogZS5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleCA8IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoZS5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleCA9IDApKSxcbiAgICAgICAgICAgICAgICAobCA9IGkgLSBlLnBhZ2luYXRpb24uZHluYW1pY0J1bGxldEluZGV4KSxcbiAgICAgICAgICAgICAgICAoZCA9XG4gICAgICAgICAgICAgICAgICAoKG8gPSBsICsgKE1hdGgubWluKHAubGVuZ3RoLCBhLmR5bmFtaWNNYWluQnVsbGV0cykgLSAxKSkgK1xuICAgICAgICAgICAgICAgICAgICBsKSAvXG4gICAgICAgICAgICAgICAgICAyKSksXG4gICAgICAgICAgICAgIHAucmVtb3ZlQ2xhc3MoXG4gICAgICAgICAgICAgICAgYS5idWxsZXRBY3RpdmVDbGFzcyArXG4gICAgICAgICAgICAgICAgICBcIiBcIiArXG4gICAgICAgICAgICAgICAgICBhLmJ1bGxldEFjdGl2ZUNsYXNzICtcbiAgICAgICAgICAgICAgICAgIFwiLW5leHQgXCIgK1xuICAgICAgICAgICAgICAgICAgYS5idWxsZXRBY3RpdmVDbGFzcyArXG4gICAgICAgICAgICAgICAgICBcIi1uZXh0LW5leHQgXCIgK1xuICAgICAgICAgICAgICAgICAgYS5idWxsZXRBY3RpdmVDbGFzcyArXG4gICAgICAgICAgICAgICAgICBcIi1wcmV2IFwiICtcbiAgICAgICAgICAgICAgICAgIGEuYnVsbGV0QWN0aXZlQ2xhc3MgK1xuICAgICAgICAgICAgICAgICAgXCItcHJldi1wcmV2IFwiICtcbiAgICAgICAgICAgICAgICAgIGEuYnVsbGV0QWN0aXZlQ2xhc3MgK1xuICAgICAgICAgICAgICAgICAgXCItbWFpblwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIHIubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcC5lYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBtKGUpLFxuICAgICAgICAgICAgICAgICAgcyA9IHQuaW5kZXgoKTtcbiAgICAgICAgICAgICAgICBzID09PSBpICYmIHQuYWRkQ2xhc3MoYS5idWxsZXRBY3RpdmVDbGFzcyksXG4gICAgICAgICAgICAgICAgICBhLmR5bmFtaWNCdWxsZXRzICYmXG4gICAgICAgICAgICAgICAgICAgIChzID49IGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICBzIDw9IG8gJiZcbiAgICAgICAgICAgICAgICAgICAgICB0LmFkZENsYXNzKGEuYnVsbGV0QWN0aXZlQ2xhc3MgKyBcIi1tYWluXCIpLFxuICAgICAgICAgICAgICAgICAgICBzID09PSBsICYmXG4gICAgICAgICAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgICAgICAgICAgICAgLnByZXYoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGEuYnVsbGV0QWN0aXZlQ2xhc3MgKyBcIi1wcmV2XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucHJldigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoYS5idWxsZXRBY3RpdmVDbGFzcyArIFwiLXByZXYtcHJldlwiKSxcbiAgICAgICAgICAgICAgICAgICAgcyA9PT0gbyAmJlxuICAgICAgICAgICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5uZXh0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhhLmJ1bGxldEFjdGl2ZUNsYXNzICsgXCItbmV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm5leHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGEuYnVsbGV0QWN0aXZlQ2xhc3MgKyBcIi1uZXh0LW5leHRcIikpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdSA9IHAuZXEoaSksXG4gICAgICAgICAgICAgICAgYyA9IHUuaW5kZXgoKTtcbiAgICAgICAgICAgICAgaWYgKCh1LmFkZENsYXNzKGEuYnVsbGV0QWN0aXZlQ2xhc3MpLCBhLmR5bmFtaWNCdWxsZXRzKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGggPSBwLmVxKGwpLCB2ID0gcC5lcShvKSwgZiA9IGw7IGYgPD0gbzsgZiArPSAxKVxuICAgICAgICAgICAgICAgICAgcC5lcShmKS5hZGRDbGFzcyhhLmJ1bGxldEFjdGl2ZUNsYXNzICsgXCItbWFpblwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5wYXJhbXMubG9vcClcbiAgICAgICAgICAgICAgICAgIGlmIChjID49IHAubGVuZ3RoIC0gYS5keW5hbWljTWFpbkJ1bGxldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZyA9IGEuZHluYW1pY01haW5CdWxsZXRzOyBnID49IDA7IGcgLT0gMSlcbiAgICAgICAgICAgICAgICAgICAgICBwLmVxKHAubGVuZ3RoIC0gZykuYWRkQ2xhc3MoXG4gICAgICAgICAgICAgICAgICAgICAgICBhLmJ1bGxldEFjdGl2ZUNsYXNzICsgXCItbWFpblwiXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcC5lcShwLmxlbmd0aCAtIGEuZHluYW1pY01haW5CdWxsZXRzIC0gMSkuYWRkQ2xhc3MoXG4gICAgICAgICAgICAgICAgICAgICAgYS5idWxsZXRBY3RpdmVDbGFzcyArIFwiLXByZXZcIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGhcbiAgICAgICAgICAgICAgICAgICAgICAucHJldigpXG4gICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGEuYnVsbGV0QWN0aXZlQ2xhc3MgKyBcIi1wcmV2XCIpXG4gICAgICAgICAgICAgICAgICAgICAgLnByZXYoKVxuICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhhLmJ1bGxldEFjdGl2ZUNsYXNzICsgXCItcHJldi1wcmV2XCIpLFxuICAgICAgICAgICAgICAgICAgICAgIHZcbiAgICAgICAgICAgICAgICAgICAgICAgIC5uZXh0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhhLmJ1bGxldEFjdGl2ZUNsYXNzICsgXCItbmV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm5leHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGEuYnVsbGV0QWN0aXZlQ2xhc3MgKyBcIi1uZXh0LW5leHRcIik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgaFxuICAgICAgICAgICAgICAgICAgICAucHJldigpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhhLmJ1bGxldEFjdGl2ZUNsYXNzICsgXCItcHJldlwiKVxuICAgICAgICAgICAgICAgICAgICAucHJldigpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhhLmJ1bGxldEFjdGl2ZUNsYXNzICsgXCItcHJldi1wcmV2XCIpLFxuICAgICAgICAgICAgICAgICAgICB2XG4gICAgICAgICAgICAgICAgICAgICAgLm5leHQoKVxuICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhhLmJ1bGxldEFjdGl2ZUNsYXNzICsgXCItbmV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAgIC5uZXh0KClcbiAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoYS5idWxsZXRBY3RpdmVDbGFzcyArIFwiLW5leHQtbmV4dFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEuZHluYW1pY0J1bGxldHMpIHtcbiAgICAgICAgICAgICAgdmFyIHkgPSBNYXRoLm1pbihwLmxlbmd0aCwgYS5keW5hbWljTWFpbkJ1bGxldHMgKyA0KSxcbiAgICAgICAgICAgICAgICB3ID1cbiAgICAgICAgICAgICAgICAgIChlLnBhZ2luYXRpb24uYnVsbGV0U2l6ZSAqIHkgLSBlLnBhZ2luYXRpb24uYnVsbGV0U2l6ZSkgLyAyIC1cbiAgICAgICAgICAgICAgICAgIGQgKiBlLnBhZ2luYXRpb24uYnVsbGV0U2l6ZSxcbiAgICAgICAgICAgICAgICBiID0gdCA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuICAgICAgICAgICAgICBwLmNzcyhlLmlzSG9yaXpvbnRhbCgpID8gYiA6IFwidG9wXCIsIHcgKyBcInB4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoXCJmcmFjdGlvblwiID09PSBhLnR5cGUgJiZcbiAgICAgICAgICAgICAgKHJcbiAgICAgICAgICAgICAgICAuZmluZChcIi5cIiArIGEuY3VycmVudENsYXNzKVxuICAgICAgICAgICAgICAgIC50ZXh0KGEuZm9ybWF0RnJhY3Rpb25DdXJyZW50KGkgKyAxKSksXG4gICAgICAgICAgICAgIHIuZmluZChcIi5cIiArIGEudG90YWxDbGFzcykudGV4dChhLmZvcm1hdEZyYWN0aW9uVG90YWwobikpKSxcbiAgICAgICAgICAgIFwicHJvZ3Jlc3NiYXJcIiA9PT0gYS50eXBlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIEU7XG4gICAgICAgICAgICBFID0gYS5wcm9ncmVzc2Jhck9wcG9zaXRlXG4gICAgICAgICAgICAgID8gZS5pc0hvcml6b250YWwoKVxuICAgICAgICAgICAgICAgID8gXCJ2ZXJ0aWNhbFwiXG4gICAgICAgICAgICAgICAgOiBcImhvcml6b250YWxcIlxuICAgICAgICAgICAgICA6IGUuaXNIb3Jpem9udGFsKClcbiAgICAgICAgICAgICAgPyBcImhvcml6b250YWxcIlxuICAgICAgICAgICAgICA6IFwidmVydGljYWxcIjtcbiAgICAgICAgICAgIHZhciB4ID0gKGkgKyAxKSAvIG4sXG4gICAgICAgICAgICAgIFQgPSAxLFxuICAgICAgICAgICAgICBDID0gMTtcbiAgICAgICAgICAgIFwiaG9yaXpvbnRhbFwiID09PSBFID8gKFQgPSB4KSA6IChDID0geCksXG4gICAgICAgICAgICAgIHJcbiAgICAgICAgICAgICAgICAuZmluZChcIi5cIiArIGEucHJvZ3Jlc3NiYXJGaWxsQ2xhc3MpXG4gICAgICAgICAgICAgICAgLnRyYW5zZm9ybShcbiAgICAgICAgICAgICAgICAgIFwidHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlWChcIiArIFQgKyBcIikgc2NhbGVZKFwiICsgQyArIFwiKVwiXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKGUucGFyYW1zLnNwZWVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXCJjdXN0b21cIiA9PT0gYS50eXBlICYmIGEucmVuZGVyQ3VzdG9tXG4gICAgICAgICAgICA/IChyLmh0bWwoYS5yZW5kZXJDdXN0b20oZSwgaSArIDEsIG4pKSxcbiAgICAgICAgICAgICAgZS5lbWl0KFwicGFnaW5hdGlvblJlbmRlclwiLCByWzBdKSlcbiAgICAgICAgICAgIDogZS5lbWl0KFwicGFnaW5hdGlvblVwZGF0ZVwiLCByWzBdKSxcbiAgICAgICAgICAgIHJbXG4gICAgICAgICAgICAgIGUucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgZS5pc0xvY2tlZCA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIlxuICAgICAgICAgICAgXShhLmxvY2tDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgIHQgPSBlLnBhcmFtcy5wYWdpbmF0aW9uO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdC5lbCAmJlxuICAgICAgICAgIGUucGFnaW5hdGlvbi5lbCAmJlxuICAgICAgICAgIGUucGFnaW5hdGlvbi4kZWwgJiZcbiAgICAgICAgICAwICE9PSBlLnBhZ2luYXRpb24uJGVsLmxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgYSA9XG4gICAgICAgICAgICAgIGUudmlydHVhbCAmJiBlLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWRcbiAgICAgICAgICAgICAgICA/IGUudmlydHVhbC5zbGlkZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgOiBlLnNsaWRlcy5sZW5ndGgsXG4gICAgICAgICAgICBpID0gZS5wYWdpbmF0aW9uLiRlbCxcbiAgICAgICAgICAgIHMgPSBcIlwiO1xuICAgICAgICAgIGlmIChcImJ1bGxldHNcIiA9PT0gdC50eXBlKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgciA9IGUucGFyYW1zLmxvb3BcbiAgICAgICAgICAgICAgICAgID8gTWF0aC5jZWlsKFxuICAgICAgICAgICAgICAgICAgICAgIChhIC0gMiAqIGUubG9vcGVkU2xpZGVzKSAvIGUucGFyYW1zLnNsaWRlc1Blckdyb3VwXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogZS5zbmFwR3JpZC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgICAgIG4gPCByO1xuICAgICAgICAgICAgICBuICs9IDFcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdC5yZW5kZXJCdWxsZXRcbiAgICAgICAgICAgICAgICA/IChzICs9IHQucmVuZGVyQnVsbGV0LmNhbGwoZSwgbiwgdC5idWxsZXRDbGFzcykpXG4gICAgICAgICAgICAgICAgOiAocyArPVxuICAgICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAgIHQuYnVsbGV0RWxlbWVudCArXG4gICAgICAgICAgICAgICAgICAgICcgY2xhc3M9XCInICtcbiAgICAgICAgICAgICAgICAgICAgdC5idWxsZXRDbGFzcyArXG4gICAgICAgICAgICAgICAgICAgICdcIj48LycgK1xuICAgICAgICAgICAgICAgICAgICB0LmJ1bGxldEVsZW1lbnQgK1xuICAgICAgICAgICAgICAgICAgICBcIj5cIik7XG4gICAgICAgICAgICBpLmh0bWwocyksXG4gICAgICAgICAgICAgIChlLnBhZ2luYXRpb24uYnVsbGV0cyA9IGkuZmluZChcbiAgICAgICAgICAgICAgICBcIi5cIiArIHQuYnVsbGV0Q2xhc3MucmVwbGFjZSgvIC9nLCBcIi5cIilcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFwiZnJhY3Rpb25cIiA9PT0gdC50eXBlICYmXG4gICAgICAgICAgICAoKHMgPSB0LnJlbmRlckZyYWN0aW9uXG4gICAgICAgICAgICAgID8gdC5yZW5kZXJGcmFjdGlvbi5jYWxsKGUsIHQuY3VycmVudENsYXNzLCB0LnRvdGFsQ2xhc3MpXG4gICAgICAgICAgICAgIDogJzxzcGFuIGNsYXNzPVwiJyArXG4gICAgICAgICAgICAgICAgdC5jdXJyZW50Q2xhc3MgK1xuICAgICAgICAgICAgICAgICdcIj48L3NwYW4+IC8gPHNwYW4gY2xhc3M9XCInICtcbiAgICAgICAgICAgICAgICB0LnRvdGFsQ2xhc3MgK1xuICAgICAgICAgICAgICAgICdcIj48L3NwYW4+JyksXG4gICAgICAgICAgICBpLmh0bWwocykpLFxuICAgICAgICAgICAgXCJwcm9ncmVzc2JhclwiID09PSB0LnR5cGUgJiZcbiAgICAgICAgICAgICAgKChzID0gdC5yZW5kZXJQcm9ncmVzc2JhclxuICAgICAgICAgICAgICAgID8gdC5yZW5kZXJQcm9ncmVzc2Jhci5jYWxsKGUsIHQucHJvZ3Jlc3NiYXJGaWxsQ2xhc3MpXG4gICAgICAgICAgICAgICAgOiAnPHNwYW4gY2xhc3M9XCInICsgdC5wcm9ncmVzc2JhckZpbGxDbGFzcyArICdcIj48L3NwYW4+JyksXG4gICAgICAgICAgICAgIGkuaHRtbChzKSksXG4gICAgICAgICAgICBcImN1c3RvbVwiICE9PSB0LnR5cGUgJiZcbiAgICAgICAgICAgICAgZS5lbWl0KFwicGFnaW5hdGlvblJlbmRlclwiLCBlLnBhZ2luYXRpb24uJGVsWzBdKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgIHQgPSBlLnBhcmFtcy5wYWdpbmF0aW9uO1xuICAgICAgICBpZiAodC5lbCkge1xuICAgICAgICAgIHZhciBhID0gbSh0LmVsKTtcbiAgICAgICAgICAwICE9PSBhLmxlbmd0aCAmJlxuICAgICAgICAgICAgKGUucGFyYW1zLnVuaXF1ZU5hdkVsZW1lbnRzICYmXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQuZWwgJiZcbiAgICAgICAgICAgICAgYS5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAgIChhID0gZS4kZWwuZmluZCh0LmVsKSksXG4gICAgICAgICAgICBcImJ1bGxldHNcIiA9PT0gdC50eXBlICYmIHQuY2xpY2thYmxlICYmIGEuYWRkQ2xhc3ModC5jbGlja2FibGVDbGFzcyksXG4gICAgICAgICAgICBhLmFkZENsYXNzKHQubW9kaWZpZXJDbGFzcyArIHQudHlwZSksXG4gICAgICAgICAgICBcImJ1bGxldHNcIiA9PT0gdC50eXBlICYmXG4gICAgICAgICAgICAgIHQuZHluYW1pY0J1bGxldHMgJiZcbiAgICAgICAgICAgICAgKGEuYWRkQ2xhc3MoXCJcIiArIHQubW9kaWZpZXJDbGFzcyArIHQudHlwZSArIFwiLWR5bmFtaWNcIiksXG4gICAgICAgICAgICAgIChlLnBhZ2luYXRpb24uZHluYW1pY0J1bGxldEluZGV4ID0gMCksXG4gICAgICAgICAgICAgIHQuZHluYW1pY01haW5CdWxsZXRzIDwgMSAmJiAodC5keW5hbWljTWFpbkJ1bGxldHMgPSAxKSksXG4gICAgICAgICAgICBcInByb2dyZXNzYmFyXCIgPT09IHQudHlwZSAmJlxuICAgICAgICAgICAgICB0LnByb2dyZXNzYmFyT3Bwb3NpdGUgJiZcbiAgICAgICAgICAgICAgYS5hZGRDbGFzcyh0LnByb2dyZXNzYmFyT3Bwb3NpdGVDbGFzcyksXG4gICAgICAgICAgICB0LmNsaWNrYWJsZSAmJlxuICAgICAgICAgICAgICBhLm9uKFxuICAgICAgICAgICAgICAgIFwiY2xpY2tcIixcbiAgICAgICAgICAgICAgICBcIi5cIiArIHQuYnVsbGV0Q2xhc3MucmVwbGFjZSgvIC9nLCBcIi5cIiksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgIHZhciBhID0gbSh0aGlzKS5pbmRleCgpICogZS5wYXJhbXMuc2xpZGVzUGVyR3JvdXA7XG4gICAgICAgICAgICAgICAgICBlLnBhcmFtcy5sb29wICYmIChhICs9IGUubG9vcGVkU2xpZGVzKSwgZS5zbGlkZVRvKGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFMoZS5wYWdpbmF0aW9uLCB7ICRlbDogYSwgZWw6IGFbMF0gfSkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgdCA9IGUucGFyYW1zLnBhZ2luYXRpb247XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0LmVsICYmXG4gICAgICAgICAgZS5wYWdpbmF0aW9uLmVsICYmXG4gICAgICAgICAgZS5wYWdpbmF0aW9uLiRlbCAmJlxuICAgICAgICAgIDAgIT09IGUucGFnaW5hdGlvbi4kZWwubGVuZ3RoXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBhID0gZS5wYWdpbmF0aW9uLiRlbDtcbiAgICAgICAgICBhLnJlbW92ZUNsYXNzKHQuaGlkZGVuQ2xhc3MpLFxuICAgICAgICAgICAgYS5yZW1vdmVDbGFzcyh0Lm1vZGlmaWVyQ2xhc3MgKyB0LnR5cGUpLFxuICAgICAgICAgICAgZS5wYWdpbmF0aW9uLmJ1bGxldHMgJiZcbiAgICAgICAgICAgICAgZS5wYWdpbmF0aW9uLmJ1bGxldHMucmVtb3ZlQ2xhc3ModC5idWxsZXRBY3RpdmVDbGFzcyksXG4gICAgICAgICAgICB0LmNsaWNrYWJsZSAmJlxuICAgICAgICAgICAgICBhLm9mZihcImNsaWNrXCIsIFwiLlwiICsgdC5idWxsZXRDbGFzcy5yZXBsYWNlKC8gL2csIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSxcbiAgICBKID0ge1xuICAgICAgc2V0VHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgaWYgKGUucGFyYW1zLnNjcm9sbGJhci5lbCAmJiBlLnNjcm9sbGJhci5lbCkge1xuICAgICAgICAgIHZhciB0ID0gZS5zY3JvbGxiYXIsXG4gICAgICAgICAgICBhID0gZS5ydGxUcmFuc2xhdGUsXG4gICAgICAgICAgICBpID0gZS5wcm9ncmVzcyxcbiAgICAgICAgICAgIHMgPSB0LmRyYWdTaXplLFxuICAgICAgICAgICAgciA9IHQudHJhY2tTaXplLFxuICAgICAgICAgICAgbiA9IHQuJGRyYWdFbCxcbiAgICAgICAgICAgIGwgPSB0LiRlbCxcbiAgICAgICAgICAgIG8gPSBlLnBhcmFtcy5zY3JvbGxiYXIsXG4gICAgICAgICAgICBkID0gcyxcbiAgICAgICAgICAgIHAgPSAociAtIHMpICogaTtcbiAgICAgICAgICBhXG4gICAgICAgICAgICA/IChwID0gLXApID4gMFxuICAgICAgICAgICAgICA/ICgoZCA9IHMgLSBwKSwgKHAgPSAwKSlcbiAgICAgICAgICAgICAgOiAtcCArIHMgPiByICYmIChkID0gciArIHApXG4gICAgICAgICAgICA6IHAgPCAwXG4gICAgICAgICAgICA/ICgoZCA9IHMgKyBwKSwgKHAgPSAwKSlcbiAgICAgICAgICAgIDogcCArIHMgPiByICYmIChkID0gciAtIHApLFxuICAgICAgICAgICAgZS5pc0hvcml6b250YWwoKVxuICAgICAgICAgICAgICA/IChuLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKFwiICsgcCArIFwicHgsIDAsIDApXCIpLFxuICAgICAgICAgICAgICAgIChuWzBdLnN0eWxlLndpZHRoID0gZCArIFwicHhcIikpXG4gICAgICAgICAgICAgIDogKG4udHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMHB4LCBcIiArIHAgKyBcInB4LCAwKVwiKSxcbiAgICAgICAgICAgICAgICAoblswXS5zdHlsZS5oZWlnaHQgPSBkICsgXCJweFwiKSksXG4gICAgICAgICAgICBvLmhpZGUgJiZcbiAgICAgICAgICAgICAgKGNsZWFyVGltZW91dChlLnNjcm9sbGJhci50aW1lb3V0KSxcbiAgICAgICAgICAgICAgKGxbMF0uc3R5bGUub3BhY2l0eSA9IDEpLFxuICAgICAgICAgICAgICAoZS5zY3JvbGxiYXIudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIChsWzBdLnN0eWxlLm9wYWNpdHkgPSAwKSwgbC50cmFuc2l0aW9uKDQwMCk7XG4gICAgICAgICAgICAgIH0sIDFlMykpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgICAgdC5wYXJhbXMuc2Nyb2xsYmFyLmVsICYmXG4gICAgICAgICAgdC5zY3JvbGxiYXIuZWwgJiZcbiAgICAgICAgICB0LnNjcm9sbGJhci4kZHJhZ0VsLnRyYW5zaXRpb24oZSk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlU2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgIGlmIChlLnBhcmFtcy5zY3JvbGxiYXIuZWwgJiYgZS5zY3JvbGxiYXIuZWwpIHtcbiAgICAgICAgICB2YXIgdCA9IGUuc2Nyb2xsYmFyLFxuICAgICAgICAgICAgYSA9IHQuJGRyYWdFbCxcbiAgICAgICAgICAgIGkgPSB0LiRlbDtcbiAgICAgICAgICAoYVswXS5zdHlsZS53aWR0aCA9IFwiXCIpLCAoYVswXS5zdHlsZS5oZWlnaHQgPSBcIlwiKTtcbiAgICAgICAgICB2YXIgcyxcbiAgICAgICAgICAgIHIgPSBlLmlzSG9yaXpvbnRhbCgpID8gaVswXS5vZmZzZXRXaWR0aCA6IGlbMF0ub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgbiA9IGUuc2l6ZSAvIGUudmlydHVhbFNpemUsXG4gICAgICAgICAgICBsID0gbiAqIChyIC8gZS5zaXplKTtcbiAgICAgICAgICAocyA9XG4gICAgICAgICAgICBcImF1dG9cIiA9PT0gZS5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdTaXplXG4gICAgICAgICAgICAgID8gciAqIG5cbiAgICAgICAgICAgICAgOiBwYXJzZUludChlLnBhcmFtcy5zY3JvbGxiYXIuZHJhZ1NpemUsIDEwKSksXG4gICAgICAgICAgICBlLmlzSG9yaXpvbnRhbCgpXG4gICAgICAgICAgICAgID8gKGFbMF0uc3R5bGUud2lkdGggPSBzICsgXCJweFwiKVxuICAgICAgICAgICAgICA6IChhWzBdLnN0eWxlLmhlaWdodCA9IHMgKyBcInB4XCIpLFxuICAgICAgICAgICAgKGlbMF0uc3R5bGUuZGlzcGxheSA9IG4gPj0gMSA/IFwibm9uZVwiIDogXCJcIiksXG4gICAgICAgICAgICBlLnBhcmFtcy5zY3JvbGxiYXIuaGlkZSAmJiAoaVswXS5zdHlsZS5vcGFjaXR5ID0gMCksXG4gICAgICAgICAgICBTKHQsIHsgdHJhY2tTaXplOiByLCBkaXZpZGVyOiBuLCBtb3ZlRGl2aWRlcjogbCwgZHJhZ1NpemU6IHMgfSksXG4gICAgICAgICAgICB0LiRlbFtcbiAgICAgICAgICAgICAgZS5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBlLmlzTG9ja2VkID8gXCJhZGRDbGFzc1wiIDogXCJyZW1vdmVDbGFzc1wiXG4gICAgICAgICAgICBdKGUucGFyYW1zLnNjcm9sbGJhci5sb2NrQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0UG9pbnRlclBvc2l0aW9uOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgICAgID8gXCJ0b3VjaHN0YXJ0XCIgPT09IGUudHlwZSB8fCBcInRvdWNobW92ZVwiID09PSBlLnR5cGVcbiAgICAgICAgICAgID8gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFhcbiAgICAgICAgICAgIDogZS5jbGllbnRYXG4gICAgICAgICAgOiBcInRvdWNoc3RhcnRcIiA9PT0gZS50eXBlIHx8IFwidG91Y2htb3ZlXCIgPT09IGUudHlwZVxuICAgICAgICAgID8gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFlcbiAgICAgICAgICA6IGUuY2xpZW50WTtcbiAgICAgIH0sXG4gICAgICBzZXREcmFnUG9zaXRpb246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0LFxuICAgICAgICAgIGEgPSB0aGlzLFxuICAgICAgICAgIGkgPSBhLnNjcm9sbGJhcixcbiAgICAgICAgICBzID0gYS5ydGxUcmFuc2xhdGUsXG4gICAgICAgICAgciA9IGkuJGVsLFxuICAgICAgICAgIG4gPSBpLmRyYWdTaXplLFxuICAgICAgICAgIGwgPSBpLnRyYWNrU2l6ZSxcbiAgICAgICAgICBvID0gaS5kcmFnU3RhcnRQb3M7XG4gICAgICAgICh0ID1cbiAgICAgICAgICAoaS5nZXRQb2ludGVyUG9zaXRpb24oZSkgLVxuICAgICAgICAgICAgci5vZmZzZXQoKVthLmlzSG9yaXpvbnRhbCgpID8gXCJsZWZ0XCIgOiBcInRvcFwiXSAtXG4gICAgICAgICAgICAobnVsbCAhPT0gbyA/IG8gOiBuIC8gMikpIC9cbiAgICAgICAgICAobCAtIG4pKSxcbiAgICAgICAgICAodCA9IE1hdGgubWF4KE1hdGgubWluKHQsIDEpLCAwKSksXG4gICAgICAgICAgcyAmJiAodCA9IDEgLSB0KTtcbiAgICAgICAgdmFyIGQgPSBhLm1pblRyYW5zbGF0ZSgpICsgKGEubWF4VHJhbnNsYXRlKCkgLSBhLm1pblRyYW5zbGF0ZSgpKSAqIHQ7XG4gICAgICAgIGEudXBkYXRlUHJvZ3Jlc3MoZCksXG4gICAgICAgICAgYS5zZXRUcmFuc2xhdGUoZCksXG4gICAgICAgICAgYS51cGRhdGVBY3RpdmVJbmRleCgpLFxuICAgICAgICAgIGEudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgICAgfSxcbiAgICAgIG9uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgYSA9IHQucGFyYW1zLnNjcm9sbGJhcixcbiAgICAgICAgICBpID0gdC5zY3JvbGxiYXIsXG4gICAgICAgICAgcyA9IHQuJHdyYXBwZXJFbCxcbiAgICAgICAgICByID0gaS4kZWwsXG4gICAgICAgICAgbiA9IGkuJGRyYWdFbDtcbiAgICAgICAgKHQuc2Nyb2xsYmFyLmlzVG91Y2hlZCA9ICEwKSxcbiAgICAgICAgICAodC5zY3JvbGxiYXIuZHJhZ1N0YXJ0UG9zID1cbiAgICAgICAgICAgIGUudGFyZ2V0ID09PSBuWzBdIHx8IGUudGFyZ2V0ID09PSBuXG4gICAgICAgICAgICAgID8gaS5nZXRQb2ludGVyUG9zaXRpb24oZSkgLVxuICAgICAgICAgICAgICAgIGUudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW1xuICAgICAgICAgICAgICAgICAgdC5pc0hvcml6b250YWwoKSA/IFwibGVmdFwiIDogXCJ0b3BcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgOiBudWxsKSxcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCksXG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKSxcbiAgICAgICAgICBzLnRyYW5zaXRpb24oMTAwKSxcbiAgICAgICAgICBuLnRyYW5zaXRpb24oMTAwKSxcbiAgICAgICAgICBpLnNldERyYWdQb3NpdGlvbihlKSxcbiAgICAgICAgICBjbGVhclRpbWVvdXQodC5zY3JvbGxiYXIuZHJhZ1RpbWVvdXQpLFxuICAgICAgICAgIHIudHJhbnNpdGlvbigwKSxcbiAgICAgICAgICBhLmhpZGUgJiYgci5jc3MoXCJvcGFjaXR5XCIsIDEpLFxuICAgICAgICAgIHQucGFyYW1zLmNzc01vZGUgJiYgdC4kd3JhcHBlckVsLmNzcyhcInNjcm9sbC1zbmFwLXR5cGVcIiwgXCJub25lXCIpLFxuICAgICAgICAgIHQuZW1pdChcInNjcm9sbGJhckRyYWdTdGFydFwiLCBlKTtcbiAgICAgIH0sXG4gICAgICBvbkRyYWdNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgYSA9IHQuc2Nyb2xsYmFyLFxuICAgICAgICAgIGkgPSB0LiR3cmFwcGVyRWwsXG4gICAgICAgICAgcyA9IGEuJGVsLFxuICAgICAgICAgIHIgPSBhLiRkcmFnRWw7XG4gICAgICAgIHQuc2Nyb2xsYmFyLmlzVG91Y2hlZCAmJlxuICAgICAgICAgIChlLnByZXZlbnREZWZhdWx0ID8gZS5wcmV2ZW50RGVmYXVsdCgpIDogKGUucmV0dXJuVmFsdWUgPSAhMSksXG4gICAgICAgICAgYS5zZXREcmFnUG9zaXRpb24oZSksXG4gICAgICAgICAgaS50cmFuc2l0aW9uKDApLFxuICAgICAgICAgIHMudHJhbnNpdGlvbigwKSxcbiAgICAgICAgICByLnRyYW5zaXRpb24oMCksXG4gICAgICAgICAgdC5lbWl0KFwic2Nyb2xsYmFyRHJhZ01vdmVcIiwgZSkpO1xuICAgICAgfSxcbiAgICAgIG9uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLFxuICAgICAgICAgIGEgPSB0LnBhcmFtcy5zY3JvbGxiYXIsXG4gICAgICAgICAgaSA9IHQuc2Nyb2xsYmFyLFxuICAgICAgICAgIHMgPSB0LiR3cmFwcGVyRWwsXG4gICAgICAgICAgciA9IGkuJGVsO1xuICAgICAgICB0LnNjcm9sbGJhci5pc1RvdWNoZWQgJiZcbiAgICAgICAgICAoKHQuc2Nyb2xsYmFyLmlzVG91Y2hlZCA9ICExKSxcbiAgICAgICAgICB0LnBhcmFtcy5jc3NNb2RlICYmXG4gICAgICAgICAgICAodC4kd3JhcHBlckVsLmNzcyhcInNjcm9sbC1zbmFwLXR5cGVcIiwgXCJcIiksIHMudHJhbnNpdGlvbihcIlwiKSksXG4gICAgICAgICAgYS5oaWRlICYmXG4gICAgICAgICAgICAoY2xlYXJUaW1lb3V0KHQuc2Nyb2xsYmFyLmRyYWdUaW1lb3V0KSxcbiAgICAgICAgICAgICh0LnNjcm9sbGJhci5kcmFnVGltZW91dCA9IEUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByLmNzcyhcIm9wYWNpdHlcIiwgMCksIHIudHJhbnNpdGlvbig0MDApO1xuICAgICAgICAgICAgfSwgMWUzKSkpLFxuICAgICAgICAgIHQuZW1pdChcInNjcm9sbGJhckRyYWdFbmRcIiwgZSksXG4gICAgICAgICAgYS5zbmFwT25SZWxlYXNlICYmIHQuc2xpZGVUb0Nsb3Nlc3QoKSk7XG4gICAgICB9LFxuICAgICAgZW5hYmxlRHJhZ2dhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgaWYgKGUucGFyYW1zLnNjcm9sbGJhci5lbCkge1xuICAgICAgICAgIHZhciB0ID0gcigpLFxuICAgICAgICAgICAgYSA9IGUuc2Nyb2xsYmFyLFxuICAgICAgICAgICAgaSA9IGUudG91Y2hFdmVudHNUb3VjaCxcbiAgICAgICAgICAgIHMgPSBlLnRvdWNoRXZlbnRzRGVza3RvcCxcbiAgICAgICAgICAgIG4gPSBlLnBhcmFtcyxcbiAgICAgICAgICAgIGwgPSBlLnN1cHBvcnQsXG4gICAgICAgICAgICBvID0gYS4kZWxbMF0sXG4gICAgICAgICAgICBkID0gISghbC5wYXNzaXZlTGlzdGVuZXIgfHwgIW4ucGFzc2l2ZUxpc3RlbmVycykgJiYge1xuICAgICAgICAgICAgICBwYXNzaXZlOiAhMSxcbiAgICAgICAgICAgICAgY2FwdHVyZTogITEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcCA9ICEoIWwucGFzc2l2ZUxpc3RlbmVyIHx8ICFuLnBhc3NpdmVMaXN0ZW5lcnMpICYmIHtcbiAgICAgICAgICAgICAgcGFzc2l2ZTogITAsXG4gICAgICAgICAgICAgIGNhcHR1cmU6ICExLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICBsLnRvdWNoXG4gICAgICAgICAgICA/IChvLmFkZEV2ZW50TGlzdGVuZXIoaS5zdGFydCwgZS5zY3JvbGxiYXIub25EcmFnU3RhcnQsIGQpLFxuICAgICAgICAgICAgICBvLmFkZEV2ZW50TGlzdGVuZXIoaS5tb3ZlLCBlLnNjcm9sbGJhci5vbkRyYWdNb3ZlLCBkKSxcbiAgICAgICAgICAgICAgby5hZGRFdmVudExpc3RlbmVyKGkuZW5kLCBlLnNjcm9sbGJhci5vbkRyYWdFbmQsIHApKVxuICAgICAgICAgICAgOiAoby5hZGRFdmVudExpc3RlbmVyKHMuc3RhcnQsIGUuc2Nyb2xsYmFyLm9uRHJhZ1N0YXJ0LCBkKSxcbiAgICAgICAgICAgICAgdC5hZGRFdmVudExpc3RlbmVyKHMubW92ZSwgZS5zY3JvbGxiYXIub25EcmFnTW92ZSwgZCksXG4gICAgICAgICAgICAgIHQuYWRkRXZlbnRMaXN0ZW5lcihzLmVuZCwgZS5zY3JvbGxiYXIub25EcmFnRW5kLCBwKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNhYmxlRHJhZ2dhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgaWYgKGUucGFyYW1zLnNjcm9sbGJhci5lbCkge1xuICAgICAgICAgIHZhciB0ID0gcigpLFxuICAgICAgICAgICAgYSA9IGUuc2Nyb2xsYmFyLFxuICAgICAgICAgICAgaSA9IGUudG91Y2hFdmVudHNUb3VjaCxcbiAgICAgICAgICAgIHMgPSBlLnRvdWNoRXZlbnRzRGVza3RvcCxcbiAgICAgICAgICAgIG4gPSBlLnBhcmFtcyxcbiAgICAgICAgICAgIGwgPSBlLnN1cHBvcnQsXG4gICAgICAgICAgICBvID0gYS4kZWxbMF0sXG4gICAgICAgICAgICBkID0gISghbC5wYXNzaXZlTGlzdGVuZXIgfHwgIW4ucGFzc2l2ZUxpc3RlbmVycykgJiYge1xuICAgICAgICAgICAgICBwYXNzaXZlOiAhMSxcbiAgICAgICAgICAgICAgY2FwdHVyZTogITEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcCA9ICEoIWwucGFzc2l2ZUxpc3RlbmVyIHx8ICFuLnBhc3NpdmVMaXN0ZW5lcnMpICYmIHtcbiAgICAgICAgICAgICAgcGFzc2l2ZTogITAsXG4gICAgICAgICAgICAgIGNhcHR1cmU6ICExLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICBsLnRvdWNoXG4gICAgICAgICAgICA/IChvLnJlbW92ZUV2ZW50TGlzdGVuZXIoaS5zdGFydCwgZS5zY3JvbGxiYXIub25EcmFnU3RhcnQsIGQpLFxuICAgICAgICAgICAgICBvLnJlbW92ZUV2ZW50TGlzdGVuZXIoaS5tb3ZlLCBlLnNjcm9sbGJhci5vbkRyYWdNb3ZlLCBkKSxcbiAgICAgICAgICAgICAgby5yZW1vdmVFdmVudExpc3RlbmVyKGkuZW5kLCBlLnNjcm9sbGJhci5vbkRyYWdFbmQsIHApKVxuICAgICAgICAgICAgOiAoby5yZW1vdmVFdmVudExpc3RlbmVyKHMuc3RhcnQsIGUuc2Nyb2xsYmFyLm9uRHJhZ1N0YXJ0LCBkKSxcbiAgICAgICAgICAgICAgdC5yZW1vdmVFdmVudExpc3RlbmVyKHMubW92ZSwgZS5zY3JvbGxiYXIub25EcmFnTW92ZSwgZCksXG4gICAgICAgICAgICAgIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihzLmVuZCwgZS5zY3JvbGxiYXIub25EcmFnRW5kLCBwKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgaWYgKGUucGFyYW1zLnNjcm9sbGJhci5lbCkge1xuICAgICAgICAgIHZhciB0ID0gZS5zY3JvbGxiYXIsXG4gICAgICAgICAgICBhID0gZS4kZWwsXG4gICAgICAgICAgICBpID0gZS5wYXJhbXMuc2Nyb2xsYmFyLFxuICAgICAgICAgICAgcyA9IG0oaS5lbCk7XG4gICAgICAgICAgZS5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHMgJiZcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIGkuZWwgJiZcbiAgICAgICAgICAgIHMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgMSA9PT0gYS5maW5kKGkuZWwpLmxlbmd0aCAmJlxuICAgICAgICAgICAgKHMgPSBhLmZpbmQoaS5lbCkpO1xuICAgICAgICAgIHZhciByID0gcy5maW5kKFwiLlwiICsgZS5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdDbGFzcyk7XG4gICAgICAgICAgMCA9PT0gci5sZW5ndGggJiZcbiAgICAgICAgICAgICgociA9IG0oXG4gICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiJyArIGUucGFyYW1zLnNjcm9sbGJhci5kcmFnQ2xhc3MgKyAnXCI+PC9kaXY+J1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBzLmFwcGVuZChyKSksXG4gICAgICAgICAgICBTKHQsIHsgJGVsOiBzLCBlbDogc1swXSwgJGRyYWdFbDogciwgZHJhZ0VsOiByWzBdIH0pLFxuICAgICAgICAgICAgaS5kcmFnZ2FibGUgJiYgdC5lbmFibGVEcmFnZ2FibGUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxiYXIuZGlzYWJsZURyYWdnYWJsZSgpO1xuICAgICAgfSxcbiAgICB9LFxuICAgIFEgPSB7XG4gICAgICBzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5ydGwsXG4gICAgICAgICAgaSA9IG0oZSksXG4gICAgICAgICAgcyA9IGEgPyAtMSA6IDEsXG4gICAgICAgICAgciA9IGkuYXR0cihcImRhdGEtc3dpcGVyLXBhcmFsbGF4XCIpIHx8IFwiMFwiLFxuICAgICAgICAgIG4gPSBpLmF0dHIoXCJkYXRhLXN3aXBlci1wYXJhbGxheC14XCIpLFxuICAgICAgICAgIGwgPSBpLmF0dHIoXCJkYXRhLXN3aXBlci1wYXJhbGxheC15XCIpLFxuICAgICAgICAgIG8gPSBpLmF0dHIoXCJkYXRhLXN3aXBlci1wYXJhbGxheC1zY2FsZVwiKSxcbiAgICAgICAgICBkID0gaS5hdHRyKFwiZGF0YS1zd2lwZXItcGFyYWxsYXgtb3BhY2l0eVwiKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChuIHx8IGxcbiAgICAgICAgICAgID8gKChuID0gbiB8fCBcIjBcIiksIChsID0gbCB8fCBcIjBcIikpXG4gICAgICAgICAgICA6IHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgICAgICAgID8gKChuID0gciksIChsID0gXCIwXCIpKVxuICAgICAgICAgICAgOiAoKGwgPSByKSwgKG4gPSBcIjBcIikpLFxuICAgICAgICAgIChuID1cbiAgICAgICAgICAgIG4uaW5kZXhPZihcIiVcIikgPj0gMFxuICAgICAgICAgICAgICA/IHBhcnNlSW50KG4sIDEwKSAqIHQgKiBzICsgXCIlXCJcbiAgICAgICAgICAgICAgOiBuICogdCAqIHMgKyBcInB4XCIpLFxuICAgICAgICAgIChsID0gbC5pbmRleE9mKFwiJVwiKSA+PSAwID8gcGFyc2VJbnQobCwgMTApICogdCArIFwiJVwiIDogbCAqIHQgKyBcInB4XCIpLFxuICAgICAgICAgIG51bGwgIT0gZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIHAgPSBkIC0gKGQgLSAxKSAqICgxIC0gTWF0aC5hYnModCkpO1xuICAgICAgICAgIGlbMF0uc3R5bGUub3BhY2l0eSA9IHA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bGwgPT0gbykgaS50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZChcIiArIG4gKyBcIiwgXCIgKyBsICsgXCIsIDBweClcIik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciB1ID0gbyAtIChvIC0gMSkgKiAoMSAtIE1hdGguYWJzKHQpKTtcbiAgICAgICAgICBpLnRyYW5zZm9ybShcbiAgICAgICAgICAgIFwidHJhbnNsYXRlM2QoXCIgKyBuICsgXCIsIFwiICsgbCArIFwiLCAwcHgpIHNjYWxlKFwiICsgdSArIFwiKVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldFRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgdCA9IGUuJGVsLFxuICAgICAgICAgIGEgPSBlLnNsaWRlcyxcbiAgICAgICAgICBpID0gZS5wcm9ncmVzcyxcbiAgICAgICAgICBzID0gZS5zbmFwR3JpZDtcbiAgICAgICAgdFxuICAgICAgICAgIC5jaGlsZHJlbihcbiAgICAgICAgICAgIFwiW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXVwiXG4gICAgICAgICAgKVxuICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBlLnBhcmFsbGF4LnNldFRyYW5zZm9ybSh0LCBpKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBhLmVhY2goZnVuY3Rpb24gKHQsIGEpIHtcbiAgICAgICAgICAgIHZhciByID0gdC5wcm9ncmVzcztcbiAgICAgICAgICAgIGUucGFyYW1zLnNsaWRlc1Blckdyb3VwID4gMSAmJlxuICAgICAgICAgICAgICBcImF1dG9cIiAhPT0gZS5wYXJhbXMuc2xpZGVzUGVyVmlldyAmJlxuICAgICAgICAgICAgICAociArPSBNYXRoLmNlaWwoYSAvIDIpIC0gaSAqIChzLmxlbmd0aCAtIDEpKSxcbiAgICAgICAgICAgICAgKHIgPSBNYXRoLm1pbihNYXRoLm1heChyLCAtMSksIDEpKSxcbiAgICAgICAgICAgICAgbSh0KVxuICAgICAgICAgICAgICAgIC5maW5kKFxuICAgICAgICAgICAgICAgICAgXCJbZGF0YS1zd2lwZXItcGFyYWxsYXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC15XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LW9wYWNpdHldLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgtc2NhbGVdXCJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgIGUucGFyYWxsYXguc2V0VHJhbnNmb3JtKHQsIHIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IHRoaXMucGFyYW1zLnNwZWVkKTtcbiAgICAgICAgdGhpcy4kZWxcbiAgICAgICAgICAuZmluZChcbiAgICAgICAgICAgIFwiW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXVwiXG4gICAgICAgICAgKVxuICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgYSA9IG0odCksXG4gICAgICAgICAgICAgIGkgPSBwYXJzZUludChhLmF0dHIoXCJkYXRhLXN3aXBlci1wYXJhbGxheC1kdXJhdGlvblwiKSwgMTApIHx8IGU7XG4gICAgICAgICAgICAwID09PSBlICYmIChpID0gMCksIGEudHJhbnNpdGlvbihpKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICBlZSA9IHtcbiAgICAgIGdldERpc3RhbmNlQmV0d2VlblRvdWNoZXM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldFRvdWNoZXMubGVuZ3RoIDwgMikgcmV0dXJuIDE7XG4gICAgICAgIHZhciB0ID0gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYLFxuICAgICAgICAgIGEgPSBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVksXG4gICAgICAgICAgaSA9IGUudGFyZ2V0VG91Y2hlc1sxXS5wYWdlWCxcbiAgICAgICAgICBzID0gZS50YXJnZXRUb3VjaGVzWzFdLnBhZ2VZO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGkgLSB0LCAyKSArIE1hdGgucG93KHMgLSBhLCAyKSk7XG4gICAgICB9LFxuICAgICAgb25HZXN0dXJlU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcyxcbiAgICAgICAgICBhID0gdC5zdXBwb3J0LFxuICAgICAgICAgIGkgPSB0LnBhcmFtcy56b29tLFxuICAgICAgICAgIHMgPSB0Lnpvb20sXG4gICAgICAgICAgciA9IHMuZ2VzdHVyZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgocy5mYWtlR2VzdHVyZVRvdWNoZWQgPSAhMSksIChzLmZha2VHZXN0dXJlTW92ZWQgPSAhMSksICFhLmdlc3R1cmVzKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcInRvdWNoc3RhcnRcIiAhPT0gZS50eXBlIHx8XG4gICAgICAgICAgICAoXCJ0b3VjaHN0YXJ0XCIgPT09IGUudHlwZSAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoIDwgMilcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgKHMuZmFrZUdlc3R1cmVUb3VjaGVkID0gITApLFxuICAgICAgICAgICAgKHIuc2NhbGVTdGFydCA9IGVlLmdldERpc3RhbmNlQmV0d2VlblRvdWNoZXMoZSkpO1xuICAgICAgICB9XG4gICAgICAgIChyLiRzbGlkZUVsICYmIHIuJHNsaWRlRWwubGVuZ3RoKSB8fFxuICAgICAgICAoKHIuJHNsaWRlRWwgPSBtKGUudGFyZ2V0KS5jbG9zZXN0KFwiLlwiICsgdC5wYXJhbXMuc2xpZGVDbGFzcykpLFxuICAgICAgICAwID09PSByLiRzbGlkZUVsLmxlbmd0aCAmJiAoci4kc2xpZGVFbCA9IHQuc2xpZGVzLmVxKHQuYWN0aXZlSW5kZXgpKSxcbiAgICAgICAgKHIuJGltYWdlRWwgPSByLiRzbGlkZUVsLmZpbmQoXG4gICAgICAgICAgXCJpbWcsIHN2ZywgY2FudmFzLCBwaWN0dXJlLCAuc3dpcGVyLXpvb20tdGFyZ2V0XCJcbiAgICAgICAgKSksXG4gICAgICAgIChyLiRpbWFnZVdyYXBFbCA9IHIuJGltYWdlRWwucGFyZW50KFwiLlwiICsgaS5jb250YWluZXJDbGFzcykpLFxuICAgICAgICAoci5tYXhSYXRpbyA9IHIuJGltYWdlV3JhcEVsLmF0dHIoXCJkYXRhLXN3aXBlci16b29tXCIpIHx8IGkubWF4UmF0aW8pLFxuICAgICAgICAwICE9PSByLiRpbWFnZVdyYXBFbC5sZW5ndGgpXG4gICAgICAgICAgPyAoci4kaW1hZ2VFbCAmJiByLiRpbWFnZUVsLnRyYW5zaXRpb24oMCksICh0Lnpvb20uaXNTY2FsaW5nID0gITApKVxuICAgICAgICAgIDogKHIuJGltYWdlRWwgPSB2b2lkIDApO1xuICAgICAgfSxcbiAgICAgIG9uR2VzdHVyZUNoYW5nZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLFxuICAgICAgICAgIGEgPSB0LnN1cHBvcnQsXG4gICAgICAgICAgaSA9IHQucGFyYW1zLnpvb20sXG4gICAgICAgICAgcyA9IHQuem9vbSxcbiAgICAgICAgICByID0gcy5nZXN0dXJlO1xuICAgICAgICBpZiAoIWEuZ2VzdHVyZXMpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcInRvdWNobW92ZVwiICE9PSBlLnR5cGUgfHxcbiAgICAgICAgICAgIChcInRvdWNobW92ZVwiID09PSBlLnR5cGUgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA8IDIpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIChzLmZha2VHZXN0dXJlTW92ZWQgPSAhMCksXG4gICAgICAgICAgICAoci5zY2FsZU1vdmUgPSBlZS5nZXREaXN0YW5jZUJldHdlZW5Ub3VjaGVzKGUpKTtcbiAgICAgICAgfVxuICAgICAgICByLiRpbWFnZUVsICYmIDAgIT09IHIuJGltYWdlRWwubGVuZ3RoXG4gICAgICAgICAgPyAoYS5nZXN0dXJlc1xuICAgICAgICAgICAgICA/IChzLnNjYWxlID0gZS5zY2FsZSAqIHMuY3VycmVudFNjYWxlKVxuICAgICAgICAgICAgICA6IChzLnNjYWxlID0gKHIuc2NhbGVNb3ZlIC8gci5zY2FsZVN0YXJ0KSAqIHMuY3VycmVudFNjYWxlKSxcbiAgICAgICAgICAgIHMuc2NhbGUgPiByLm1heFJhdGlvICYmXG4gICAgICAgICAgICAgIChzLnNjYWxlID1cbiAgICAgICAgICAgICAgICByLm1heFJhdGlvIC0gMSArIE1hdGgucG93KHMuc2NhbGUgLSByLm1heFJhdGlvICsgMSwgMC41KSksXG4gICAgICAgICAgICBzLnNjYWxlIDwgaS5taW5SYXRpbyAmJlxuICAgICAgICAgICAgICAocy5zY2FsZSA9XG4gICAgICAgICAgICAgICAgaS5taW5SYXRpbyArIDEgLSBNYXRoLnBvdyhpLm1pblJhdGlvIC0gcy5zY2FsZSArIDEsIDAuNSkpLFxuICAgICAgICAgICAgci4kaW1hZ2VFbC50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoXCIgKyBzLnNjYWxlICsgXCIpXCIpKVxuICAgICAgICAgIDogXCJnZXN0dXJlY2hhbmdlXCIgPT09IGUudHlwZSAmJiBzLm9uR2VzdHVyZVN0YXJ0KGUpO1xuICAgICAgfSxcbiAgICAgIG9uR2VzdHVyZUVuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLFxuICAgICAgICAgIGEgPSB0LmRldmljZSxcbiAgICAgICAgICBpID0gdC5zdXBwb3J0LFxuICAgICAgICAgIHMgPSB0LnBhcmFtcy56b29tLFxuICAgICAgICAgIHIgPSB0Lnpvb20sXG4gICAgICAgICAgbiA9IHIuZ2VzdHVyZTtcbiAgICAgICAgaWYgKCFpLmdlc3R1cmVzKSB7XG4gICAgICAgICAgaWYgKCFyLmZha2VHZXN0dXJlVG91Y2hlZCB8fCAhci5mYWtlR2VzdHVyZU1vdmVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJ0b3VjaGVuZFwiICE9PSBlLnR5cGUgfHxcbiAgICAgICAgICAgIChcInRvdWNoZW5kXCIgPT09IGUudHlwZSAmJiBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA8IDIgJiYgIWEuYW5kcm9pZClcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgKHIuZmFrZUdlc3R1cmVUb3VjaGVkID0gITEpLCAoci5mYWtlR2VzdHVyZU1vdmVkID0gITEpO1xuICAgICAgICB9XG4gICAgICAgIG4uJGltYWdlRWwgJiZcbiAgICAgICAgICAwICE9PSBuLiRpbWFnZUVsLmxlbmd0aCAmJlxuICAgICAgICAgICgoci5zY2FsZSA9IE1hdGgubWF4KE1hdGgubWluKHIuc2NhbGUsIG4ubWF4UmF0aW8pLCBzLm1pblJhdGlvKSksXG4gICAgICAgICAgbi4kaW1hZ2VFbFxuICAgICAgICAgICAgLnRyYW5zaXRpb24odC5wYXJhbXMuc3BlZWQpXG4gICAgICAgICAgICAudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKFwiICsgci5zY2FsZSArIFwiKVwiKSxcbiAgICAgICAgICAoci5jdXJyZW50U2NhbGUgPSByLnNjYWxlKSxcbiAgICAgICAgICAoci5pc1NjYWxpbmcgPSAhMSksXG4gICAgICAgICAgMSA9PT0gci5zY2FsZSAmJiAobi4kc2xpZGVFbCA9IHZvaWQgMCkpO1xuICAgICAgfSxcbiAgICAgIG9uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmRldmljZSxcbiAgICAgICAgICBhID0gdGhpcy56b29tLFxuICAgICAgICAgIGkgPSBhLmdlc3R1cmUsXG4gICAgICAgICAgcyA9IGEuaW1hZ2U7XG4gICAgICAgIGkuJGltYWdlRWwgJiZcbiAgICAgICAgICAwICE9PSBpLiRpbWFnZUVsLmxlbmd0aCAmJlxuICAgICAgICAgIChzLmlzVG91Y2hlZCB8fFxuICAgICAgICAgICAgKHQuYW5kcm9pZCAmJiBlLmNhbmNlbGFibGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpLFxuICAgICAgICAgICAgKHMuaXNUb3VjaGVkID0gITApLFxuICAgICAgICAgICAgKHMudG91Y2hlc1N0YXJ0LnggPVxuICAgICAgICAgICAgICBcInRvdWNoc3RhcnRcIiA9PT0gZS50eXBlID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYIDogZS5wYWdlWCksXG4gICAgICAgICAgICAocy50b3VjaGVzU3RhcnQueSA9XG4gICAgICAgICAgICAgIFwidG91Y2hzdGFydFwiID09PSBlLnR5cGUgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZKSkpO1xuICAgICAgfSxcbiAgICAgIG9uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgYSA9IHQuem9vbSxcbiAgICAgICAgICBpID0gYS5nZXN0dXJlLFxuICAgICAgICAgIHMgPSBhLmltYWdlLFxuICAgICAgICAgIHIgPSBhLnZlbG9jaXR5O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaS4kaW1hZ2VFbCAmJlxuICAgICAgICAgIDAgIT09IGkuJGltYWdlRWwubGVuZ3RoICYmXG4gICAgICAgICAgKCh0LmFsbG93Q2xpY2sgPSAhMSksIHMuaXNUb3VjaGVkICYmIGkuJHNsaWRlRWwpXG4gICAgICAgICkge1xuICAgICAgICAgIHMuaXNNb3ZlZCB8fFxuICAgICAgICAgICAgKChzLndpZHRoID0gaS4kaW1hZ2VFbFswXS5vZmZzZXRXaWR0aCksXG4gICAgICAgICAgICAocy5oZWlnaHQgPSBpLiRpbWFnZUVsWzBdLm9mZnNldEhlaWdodCksXG4gICAgICAgICAgICAocy5zdGFydFggPSBUKGkuJGltYWdlV3JhcEVsWzBdLCBcInhcIikgfHwgMCksXG4gICAgICAgICAgICAocy5zdGFydFkgPSBUKGkuJGltYWdlV3JhcEVsWzBdLCBcInlcIikgfHwgMCksXG4gICAgICAgICAgICAoaS5zbGlkZVdpZHRoID0gaS4kc2xpZGVFbFswXS5vZmZzZXRXaWR0aCksXG4gICAgICAgICAgICAoaS5zbGlkZUhlaWdodCA9IGkuJHNsaWRlRWxbMF0ub2Zmc2V0SGVpZ2h0KSxcbiAgICAgICAgICAgIGkuJGltYWdlV3JhcEVsLnRyYW5zaXRpb24oMCksXG4gICAgICAgICAgICB0LnJ0bCAmJiAoKHMuc3RhcnRYID0gLXMuc3RhcnRYKSwgKHMuc3RhcnRZID0gLXMuc3RhcnRZKSkpO1xuICAgICAgICAgIHZhciBuID0gcy53aWR0aCAqIGEuc2NhbGUsXG4gICAgICAgICAgICBsID0gcy5oZWlnaHQgKiBhLnNjYWxlO1xuICAgICAgICAgIGlmICghKG4gPCBpLnNsaWRlV2lkdGggJiYgbCA8IGkuc2xpZGVIZWlnaHQpKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgocy5taW5YID0gTWF0aC5taW4oaS5zbGlkZVdpZHRoIC8gMiAtIG4gLyAyLCAwKSksXG4gICAgICAgICAgICAgIChzLm1heFggPSAtcy5taW5YKSxcbiAgICAgICAgICAgICAgKHMubWluWSA9IE1hdGgubWluKGkuc2xpZGVIZWlnaHQgLyAyIC0gbCAvIDIsIDApKSxcbiAgICAgICAgICAgICAgKHMubWF4WSA9IC1zLm1pblkpLFxuICAgICAgICAgICAgICAocy50b3VjaGVzQ3VycmVudC54ID1cbiAgICAgICAgICAgICAgICBcInRvdWNobW92ZVwiID09PSBlLnR5cGUgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYKSxcbiAgICAgICAgICAgICAgKHMudG91Y2hlc0N1cnJlbnQueSA9XG4gICAgICAgICAgICAgICAgXCJ0b3VjaG1vdmVcIiA9PT0gZS50eXBlID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWSksXG4gICAgICAgICAgICAgICFzLmlzTW92ZWQgJiYgIWEuaXNTY2FsaW5nKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0LmlzSG9yaXpvbnRhbCgpICYmXG4gICAgICAgICAgICAgICAgKChNYXRoLmZsb29yKHMubWluWCkgPT09IE1hdGguZmxvb3Iocy5zdGFydFgpICYmXG4gICAgICAgICAgICAgICAgICBzLnRvdWNoZXNDdXJyZW50LnggPCBzLnRvdWNoZXNTdGFydC54KSB8fFxuICAgICAgICAgICAgICAgICAgKE1hdGguZmxvb3Iocy5tYXhYKSA9PT0gTWF0aC5mbG9vcihzLnN0YXJ0WCkgJiZcbiAgICAgICAgICAgICAgICAgICAgcy50b3VjaGVzQ3VycmVudC54ID4gcy50b3VjaGVzU3RhcnQueCkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAocy5pc1RvdWNoZWQgPSAhMSk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhdC5pc0hvcml6b250YWwoKSAmJlxuICAgICAgICAgICAgICAgICgoTWF0aC5mbG9vcihzLm1pblkpID09PSBNYXRoLmZsb29yKHMuc3RhcnRZKSAmJlxuICAgICAgICAgICAgICAgICAgcy50b3VjaGVzQ3VycmVudC55IDwgcy50b3VjaGVzU3RhcnQueSkgfHxcbiAgICAgICAgICAgICAgICAgIChNYXRoLmZsb29yKHMubWF4WSkgPT09IE1hdGguZmxvb3Iocy5zdGFydFkpICYmXG4gICAgICAgICAgICAgICAgICAgIHMudG91Y2hlc0N1cnJlbnQueSA+IHMudG91Y2hlc1N0YXJ0LnkpKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgKHMuaXNUb3VjaGVkID0gITEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5jYW5jZWxhYmxlICYmIGUucHJldmVudERlZmF1bHQoKSxcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKSxcbiAgICAgICAgICAgICAgKHMuaXNNb3ZlZCA9ICEwKSxcbiAgICAgICAgICAgICAgKHMuY3VycmVudFggPSBzLnRvdWNoZXNDdXJyZW50LnggLSBzLnRvdWNoZXNTdGFydC54ICsgcy5zdGFydFgpLFxuICAgICAgICAgICAgICAocy5jdXJyZW50WSA9IHMudG91Y2hlc0N1cnJlbnQueSAtIHMudG91Y2hlc1N0YXJ0LnkgKyBzLnN0YXJ0WSksXG4gICAgICAgICAgICAgIHMuY3VycmVudFggPCBzLm1pblggJiZcbiAgICAgICAgICAgICAgICAocy5jdXJyZW50WCA9XG4gICAgICAgICAgICAgICAgICBzLm1pblggKyAxIC0gTWF0aC5wb3cocy5taW5YIC0gcy5jdXJyZW50WCArIDEsIDAuOCkpLFxuICAgICAgICAgICAgICBzLmN1cnJlbnRYID4gcy5tYXhYICYmXG4gICAgICAgICAgICAgICAgKHMuY3VycmVudFggPVxuICAgICAgICAgICAgICAgICAgcy5tYXhYIC0gMSArIE1hdGgucG93KHMuY3VycmVudFggLSBzLm1heFggKyAxLCAwLjgpKSxcbiAgICAgICAgICAgICAgcy5jdXJyZW50WSA8IHMubWluWSAmJlxuICAgICAgICAgICAgICAgIChzLmN1cnJlbnRZID1cbiAgICAgICAgICAgICAgICAgIHMubWluWSArIDEgLSBNYXRoLnBvdyhzLm1pblkgLSBzLmN1cnJlbnRZICsgMSwgMC44KSksXG4gICAgICAgICAgICAgIHMuY3VycmVudFkgPiBzLm1heFkgJiZcbiAgICAgICAgICAgICAgICAocy5jdXJyZW50WSA9XG4gICAgICAgICAgICAgICAgICBzLm1heFkgLSAxICsgTWF0aC5wb3cocy5jdXJyZW50WSAtIHMubWF4WSArIDEsIDAuOCkpLFxuICAgICAgICAgICAgICByLnByZXZQb3NpdGlvblggfHwgKHIucHJldlBvc2l0aW9uWCA9IHMudG91Y2hlc0N1cnJlbnQueCksXG4gICAgICAgICAgICAgIHIucHJldlBvc2l0aW9uWSB8fCAoci5wcmV2UG9zaXRpb25ZID0gcy50b3VjaGVzQ3VycmVudC55KSxcbiAgICAgICAgICAgICAgci5wcmV2VGltZSB8fCAoci5wcmV2VGltZSA9IERhdGUubm93KCkpLFxuICAgICAgICAgICAgICAoci54ID1cbiAgICAgICAgICAgICAgICAocy50b3VjaGVzQ3VycmVudC54IC0gci5wcmV2UG9zaXRpb25YKSAvXG4gICAgICAgICAgICAgICAgKERhdGUubm93KCkgLSByLnByZXZUaW1lKSAvXG4gICAgICAgICAgICAgICAgMiksXG4gICAgICAgICAgICAgIChyLnkgPVxuICAgICAgICAgICAgICAgIChzLnRvdWNoZXNDdXJyZW50LnkgLSByLnByZXZQb3NpdGlvblkpIC9cbiAgICAgICAgICAgICAgICAoRGF0ZS5ub3coKSAtIHIucHJldlRpbWUpIC9cbiAgICAgICAgICAgICAgICAyKSxcbiAgICAgICAgICAgICAgTWF0aC5hYnMocy50b3VjaGVzQ3VycmVudC54IC0gci5wcmV2UG9zaXRpb25YKSA8IDIgJiYgKHIueCA9IDApLFxuICAgICAgICAgICAgICBNYXRoLmFicyhzLnRvdWNoZXNDdXJyZW50LnkgLSByLnByZXZQb3NpdGlvblkpIDwgMiAmJiAoci55ID0gMCksXG4gICAgICAgICAgICAgIChyLnByZXZQb3NpdGlvblggPSBzLnRvdWNoZXNDdXJyZW50LngpLFxuICAgICAgICAgICAgICAoci5wcmV2UG9zaXRpb25ZID0gcy50b3VjaGVzQ3VycmVudC55KSxcbiAgICAgICAgICAgICAgKHIucHJldlRpbWUgPSBEYXRlLm5vdygpKSxcbiAgICAgICAgICAgICAgaS4kaW1hZ2VXcmFwRWwudHJhbnNmb3JtKFxuICAgICAgICAgICAgICAgIFwidHJhbnNsYXRlM2QoXCIgKyBzLmN1cnJlbnRYICsgXCJweCwgXCIgKyBzLmN1cnJlbnRZICsgXCJweCwwKVwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Ub3VjaEVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuem9vbSxcbiAgICAgICAgICB0ID0gZS5nZXN0dXJlLFxuICAgICAgICAgIGEgPSBlLmltYWdlLFxuICAgICAgICAgIGkgPSBlLnZlbG9jaXR5O1xuICAgICAgICBpZiAodC4kaW1hZ2VFbCAmJiAwICE9PSB0LiRpbWFnZUVsLmxlbmd0aCkge1xuICAgICAgICAgIGlmICghYS5pc1RvdWNoZWQgfHwgIWEuaXNNb3ZlZClcbiAgICAgICAgICAgIHJldHVybiAoYS5pc1RvdWNoZWQgPSAhMSksIHZvaWQgKGEuaXNNb3ZlZCA9ICExKTtcbiAgICAgICAgICAoYS5pc1RvdWNoZWQgPSAhMSksIChhLmlzTW92ZWQgPSAhMSk7XG4gICAgICAgICAgdmFyIHMgPSAzMDAsXG4gICAgICAgICAgICByID0gMzAwLFxuICAgICAgICAgICAgbiA9IGkueCAqIHMsXG4gICAgICAgICAgICBsID0gYS5jdXJyZW50WCArIG4sXG4gICAgICAgICAgICBvID0gaS55ICogcixcbiAgICAgICAgICAgIGQgPSBhLmN1cnJlbnRZICsgbztcbiAgICAgICAgICAwICE9PSBpLnggJiYgKHMgPSBNYXRoLmFicygobCAtIGEuY3VycmVudFgpIC8gaS54KSksXG4gICAgICAgICAgICAwICE9PSBpLnkgJiYgKHIgPSBNYXRoLmFicygoZCAtIGEuY3VycmVudFkpIC8gaS55KSk7XG4gICAgICAgICAgdmFyIHAgPSBNYXRoLm1heChzLCByKTtcbiAgICAgICAgICAoYS5jdXJyZW50WCA9IGwpLCAoYS5jdXJyZW50WSA9IGQpO1xuICAgICAgICAgIHZhciB1ID0gYS53aWR0aCAqIGUuc2NhbGUsXG4gICAgICAgICAgICBjID0gYS5oZWlnaHQgKiBlLnNjYWxlO1xuICAgICAgICAgIChhLm1pblggPSBNYXRoLm1pbih0LnNsaWRlV2lkdGggLyAyIC0gdSAvIDIsIDApKSxcbiAgICAgICAgICAgIChhLm1heFggPSAtYS5taW5YKSxcbiAgICAgICAgICAgIChhLm1pblkgPSBNYXRoLm1pbih0LnNsaWRlSGVpZ2h0IC8gMiAtIGMgLyAyLCAwKSksXG4gICAgICAgICAgICAoYS5tYXhZID0gLWEubWluWSksXG4gICAgICAgICAgICAoYS5jdXJyZW50WCA9IE1hdGgubWF4KE1hdGgubWluKGEuY3VycmVudFgsIGEubWF4WCksIGEubWluWCkpLFxuICAgICAgICAgICAgKGEuY3VycmVudFkgPSBNYXRoLm1heChNYXRoLm1pbihhLmN1cnJlbnRZLCBhLm1heFkpLCBhLm1pblkpKSxcbiAgICAgICAgICAgIHQuJGltYWdlV3JhcEVsXG4gICAgICAgICAgICAgIC50cmFuc2l0aW9uKHApXG4gICAgICAgICAgICAgIC50cmFuc2Zvcm0oXG4gICAgICAgICAgICAgICAgXCJ0cmFuc2xhdGUzZChcIiArIGEuY3VycmVudFggKyBcInB4LCBcIiArIGEuY3VycmVudFkgKyBcInB4LDApXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgdCA9IGUuem9vbSxcbiAgICAgICAgICBhID0gdC5nZXN0dXJlO1xuICAgICAgICBhLiRzbGlkZUVsICYmXG4gICAgICAgICAgZS5wcmV2aW91c0luZGV4ICE9PSBlLmFjdGl2ZUluZGV4ICYmXG4gICAgICAgICAgKGEuJGltYWdlRWwgJiYgYS4kaW1hZ2VFbC50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoMSlcIiksXG4gICAgICAgICAgYS4kaW1hZ2VXcmFwRWwgJiYgYS4kaW1hZ2VXcmFwRWwudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMCwwLDApXCIpLFxuICAgICAgICAgICh0LnNjYWxlID0gMSksXG4gICAgICAgICAgKHQuY3VycmVudFNjYWxlID0gMSksXG4gICAgICAgICAgKGEuJHNsaWRlRWwgPSB2b2lkIDApLFxuICAgICAgICAgIChhLiRpbWFnZUVsID0gdm9pZCAwKSxcbiAgICAgICAgICAoYS4kaW1hZ2VXcmFwRWwgPSB2b2lkIDApKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy56b29tO1xuICAgICAgICB0LnNjYWxlICYmIDEgIT09IHQuc2NhbGUgPyB0Lm91dCgpIDogdC5pbihlKTtcbiAgICAgIH0sXG4gICAgICBpbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHMsXG4gICAgICAgICAgcixcbiAgICAgICAgICBuLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgbyxcbiAgICAgICAgICBkLFxuICAgICAgICAgIHAsXG4gICAgICAgICAgdSxcbiAgICAgICAgICBjLFxuICAgICAgICAgIGgsXG4gICAgICAgICAgdixcbiAgICAgICAgICBmLFxuICAgICAgICAgIG0sXG4gICAgICAgICAgZyA9IHRoaXMsXG4gICAgICAgICAgeSA9IGcuem9vbSxcbiAgICAgICAgICB3ID0gZy5wYXJhbXMuem9vbSxcbiAgICAgICAgICBiID0geS5nZXN0dXJlLFxuICAgICAgICAgIEUgPSB5LmltYWdlO1xuICAgICAgICAoYi4kc2xpZGVFbCB8fFxuICAgICAgICAgIChnLnBhcmFtcy52aXJ0dWFsICYmIGcucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCAmJiBnLnZpcnR1YWxcbiAgICAgICAgICAgID8gKGIuJHNsaWRlRWwgPSBnLiR3cmFwcGVyRWwuY2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgXCIuXCIgKyBnLnBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzXG4gICAgICAgICAgICAgICkpXG4gICAgICAgICAgICA6IChiLiRzbGlkZUVsID0gZy5zbGlkZXMuZXEoZy5hY3RpdmVJbmRleCkpLFxuICAgICAgICAgIChiLiRpbWFnZUVsID0gYi4kc2xpZGVFbC5maW5kKFxuICAgICAgICAgICAgXCJpbWcsIHN2ZywgY2FudmFzLCBwaWN0dXJlLCAuc3dpcGVyLXpvb20tdGFyZ2V0XCJcbiAgICAgICAgICApKSxcbiAgICAgICAgICAoYi4kaW1hZ2VXcmFwRWwgPSBiLiRpbWFnZUVsLnBhcmVudChcIi5cIiArIHcuY29udGFpbmVyQ2xhc3MpKSksXG4gICAgICAgIGIuJGltYWdlRWwgJiYgMCAhPT0gYi4kaW1hZ2VFbC5sZW5ndGgpICYmXG4gICAgICAgICAgKGIuJHNsaWRlRWwuYWRkQ2xhc3MoXCJcIiArIHcuem9vbWVkU2xpZGVDbGFzcyksXG4gICAgICAgICAgdm9pZCAwID09PSBFLnRvdWNoZXNTdGFydC54ICYmIGVcbiAgICAgICAgICAgID8gKCh0ID1cbiAgICAgICAgICAgICAgICBcInRvdWNoZW5kXCIgPT09IGUudHlwZSA/IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYKSxcbiAgICAgICAgICAgICAgKGEgPSBcInRvdWNoZW5kXCIgPT09IGUudHlwZSA/IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZKSlcbiAgICAgICAgICAgIDogKCh0ID0gRS50b3VjaGVzU3RhcnQueCksIChhID0gRS50b3VjaGVzU3RhcnQueSkpLFxuICAgICAgICAgICh5LnNjYWxlID0gYi4kaW1hZ2VXcmFwRWwuYXR0cihcImRhdGEtc3dpcGVyLXpvb21cIikgfHwgdy5tYXhSYXRpbyksXG4gICAgICAgICAgKHkuY3VycmVudFNjYWxlID1cbiAgICAgICAgICAgIGIuJGltYWdlV3JhcEVsLmF0dHIoXCJkYXRhLXN3aXBlci16b29tXCIpIHx8IHcubWF4UmF0aW8pLFxuICAgICAgICAgIGVcbiAgICAgICAgICAgID8gKChmID0gYi4kc2xpZGVFbFswXS5vZmZzZXRXaWR0aCksXG4gICAgICAgICAgICAgIChtID0gYi4kc2xpZGVFbFswXS5vZmZzZXRIZWlnaHQpLFxuICAgICAgICAgICAgICAoaSA9IGIuJHNsaWRlRWwub2Zmc2V0KCkubGVmdCArIGYgLyAyIC0gdCksXG4gICAgICAgICAgICAgIChzID0gYi4kc2xpZGVFbC5vZmZzZXQoKS50b3AgKyBtIC8gMiAtIGEpLFxuICAgICAgICAgICAgICAobCA9IGIuJGltYWdlRWxbMF0ub2Zmc2V0V2lkdGgpLFxuICAgICAgICAgICAgICAobyA9IGIuJGltYWdlRWxbMF0ub2Zmc2V0SGVpZ2h0KSxcbiAgICAgICAgICAgICAgKGQgPSBsICogeS5zY2FsZSksXG4gICAgICAgICAgICAgIChwID0gbyAqIHkuc2NhbGUpLFxuICAgICAgICAgICAgICAoaCA9IC0odSA9IE1hdGgubWluKGYgLyAyIC0gZCAvIDIsIDApKSksXG4gICAgICAgICAgICAgICh2ID0gLShjID0gTWF0aC5taW4obSAvIDIgLSBwIC8gMiwgMCkpKSxcbiAgICAgICAgICAgICAgKHIgPSBpICogeS5zY2FsZSkgPCB1ICYmIChyID0gdSksXG4gICAgICAgICAgICAgIHIgPiBoICYmIChyID0gaCksXG4gICAgICAgICAgICAgIChuID0gcyAqIHkuc2NhbGUpIDwgYyAmJiAobiA9IGMpLFxuICAgICAgICAgICAgICBuID4gdiAmJiAobiA9IHYpKVxuICAgICAgICAgICAgOiAoKHIgPSAwKSwgKG4gPSAwKSksXG4gICAgICAgICAgYi4kaW1hZ2VXcmFwRWxcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKDMwMClcbiAgICAgICAgICAgIC50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZChcIiArIHIgKyBcInB4LCBcIiArIG4gKyBcInB4LDApXCIpLFxuICAgICAgICAgIGIuJGltYWdlRWxcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKDMwMClcbiAgICAgICAgICAgIC50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoXCIgKyB5LnNjYWxlICsgXCIpXCIpKTtcbiAgICAgIH0sXG4gICAgICBvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgIHQgPSBlLnpvb20sXG4gICAgICAgICAgYSA9IGUucGFyYW1zLnpvb20sXG4gICAgICAgICAgaSA9IHQuZ2VzdHVyZTtcbiAgICAgICAgaS4kc2xpZGVFbCB8fFxuICAgICAgICAgIChlLnBhcmFtcy52aXJ0dWFsICYmIGUucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCAmJiBlLnZpcnR1YWxcbiAgICAgICAgICAgID8gKGkuJHNsaWRlRWwgPSBlLiR3cmFwcGVyRWwuY2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgXCIuXCIgKyBlLnBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzXG4gICAgICAgICAgICAgICkpXG4gICAgICAgICAgICA6IChpLiRzbGlkZUVsID0gZS5zbGlkZXMuZXEoZS5hY3RpdmVJbmRleCkpLFxuICAgICAgICAgIChpLiRpbWFnZUVsID0gaS4kc2xpZGVFbC5maW5kKFxuICAgICAgICAgICAgXCJpbWcsIHN2ZywgY2FudmFzLCBwaWN0dXJlLCAuc3dpcGVyLXpvb20tdGFyZ2V0XCJcbiAgICAgICAgICApKSxcbiAgICAgICAgICAoaS4kaW1hZ2VXcmFwRWwgPSBpLiRpbWFnZUVsLnBhcmVudChcIi5cIiArIGEuY29udGFpbmVyQ2xhc3MpKSksXG4gICAgICAgICAgaS4kaW1hZ2VFbCAmJlxuICAgICAgICAgICAgMCAhPT0gaS4kaW1hZ2VFbC5sZW5ndGggJiZcbiAgICAgICAgICAgICgodC5zY2FsZSA9IDEpLFxuICAgICAgICAgICAgKHQuY3VycmVudFNjYWxlID0gMSksXG4gICAgICAgICAgICBpLiRpbWFnZVdyYXBFbC50cmFuc2l0aW9uKDMwMCkudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMCwwLDApXCIpLFxuICAgICAgICAgICAgaS4kaW1hZ2VFbC50cmFuc2l0aW9uKDMwMCkudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKDEpXCIpLFxuICAgICAgICAgICAgaS4kc2xpZGVFbC5yZW1vdmVDbGFzcyhcIlwiICsgYS56b29tZWRTbGlkZUNsYXNzKSxcbiAgICAgICAgICAgIChpLiRzbGlkZUVsID0gdm9pZCAwKSk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlR2VzdHVyZXM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcyxcbiAgICAgICAgICBhID0gdC56b29tLFxuICAgICAgICAgIGkgPSBhLnNsaWRlU2VsZWN0b3IsXG4gICAgICAgICAgcyA9IGEucGFzc2l2ZUxpc3RlbmVyO1xuICAgICAgICB0LiR3cmFwcGVyRWxbZV0oXCJnZXN0dXJlc3RhcnRcIiwgaSwgYS5vbkdlc3R1cmVTdGFydCwgcyksXG4gICAgICAgICAgdC4kd3JhcHBlckVsW2VdKFwiZ2VzdHVyZWNoYW5nZVwiLCBpLCBhLm9uR2VzdHVyZUNoYW5nZSwgcyksXG4gICAgICAgICAgdC4kd3JhcHBlckVsW2VdKFwiZ2VzdHVyZWVuZFwiLCBpLCBhLm9uR2VzdHVyZUVuZCwgcyk7XG4gICAgICB9LFxuICAgICAgZW5hYmxlR2VzdHVyZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy56b29tLmdlc3R1cmVzRW5hYmxlZCB8fFxuICAgICAgICAgICgodGhpcy56b29tLmdlc3R1cmVzRW5hYmxlZCA9ICEwKSwgdGhpcy56b29tLnRvZ2dsZUdlc3R1cmVzKFwib25cIikpO1xuICAgICAgfSxcbiAgICAgIGRpc2FibGVHZXN0dXJlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnpvb20uZ2VzdHVyZXNFbmFibGVkICYmXG4gICAgICAgICAgKCh0aGlzLnpvb20uZ2VzdHVyZXNFbmFibGVkID0gITEpLCB0aGlzLnpvb20udG9nZ2xlR2VzdHVyZXMoXCJvZmZcIikpO1xuICAgICAgfSxcbiAgICAgIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgdCA9IGUuc3VwcG9ydCxcbiAgICAgICAgICBhID0gZS56b29tO1xuICAgICAgICBpZiAoIWEuZW5hYmxlZCkge1xuICAgICAgICAgIGEuZW5hYmxlZCA9ICEwO1xuICAgICAgICAgIHZhciBpID0gIShcbiAgICAgICAgICAgICAgXCJ0b3VjaHN0YXJ0XCIgIT09IGUudG91Y2hFdmVudHMuc3RhcnQgfHxcbiAgICAgICAgICAgICAgIXQucGFzc2l2ZUxpc3RlbmVyIHx8XG4gICAgICAgICAgICAgICFlLnBhcmFtcy5wYXNzaXZlTGlzdGVuZXJzXG4gICAgICAgICAgICApICYmIHsgcGFzc2l2ZTogITAsIGNhcHR1cmU6ICExIH0sXG4gICAgICAgICAgICBzID0gIXQucGFzc2l2ZUxpc3RlbmVyIHx8IHsgcGFzc2l2ZTogITEsIGNhcHR1cmU6ICEwIH0sXG4gICAgICAgICAgICByID0gXCIuXCIgKyBlLnBhcmFtcy5zbGlkZUNsYXNzO1xuICAgICAgICAgIChlLnpvb20ucGFzc2l2ZUxpc3RlbmVyID0gaSksXG4gICAgICAgICAgICAoZS56b29tLnNsaWRlU2VsZWN0b3IgPSByKSxcbiAgICAgICAgICAgIHQuZ2VzdHVyZXNcbiAgICAgICAgICAgICAgPyAoZS4kd3JhcHBlckVsLm9uKGUudG91Y2hFdmVudHMuc3RhcnQsIGUuem9vbS5lbmFibGVHZXN0dXJlcywgaSksXG4gICAgICAgICAgICAgICAgZS4kd3JhcHBlckVsLm9uKGUudG91Y2hFdmVudHMuZW5kLCBlLnpvb20uZGlzYWJsZUdlc3R1cmVzLCBpKSlcbiAgICAgICAgICAgICAgOiBcInRvdWNoc3RhcnRcIiA9PT0gZS50b3VjaEV2ZW50cy5zdGFydCAmJlxuICAgICAgICAgICAgICAgIChlLiR3cmFwcGVyRWwub24oZS50b3VjaEV2ZW50cy5zdGFydCwgciwgYS5vbkdlc3R1cmVTdGFydCwgaSksXG4gICAgICAgICAgICAgICAgZS4kd3JhcHBlckVsLm9uKGUudG91Y2hFdmVudHMubW92ZSwgciwgYS5vbkdlc3R1cmVDaGFuZ2UsIHMpLFxuICAgICAgICAgICAgICAgIGUuJHdyYXBwZXJFbC5vbihlLnRvdWNoRXZlbnRzLmVuZCwgciwgYS5vbkdlc3R1cmVFbmQsIGkpLFxuICAgICAgICAgICAgICAgIGUudG91Y2hFdmVudHMuY2FuY2VsICYmXG4gICAgICAgICAgICAgICAgICBlLiR3cmFwcGVyRWwub24oZS50b3VjaEV2ZW50cy5jYW5jZWwsIHIsIGEub25HZXN0dXJlRW5kLCBpKSksXG4gICAgICAgICAgICBlLiR3cmFwcGVyRWwub24oXG4gICAgICAgICAgICAgIGUudG91Y2hFdmVudHMubW92ZSxcbiAgICAgICAgICAgICAgXCIuXCIgKyBlLnBhcmFtcy56b29tLmNvbnRhaW5lckNsYXNzLFxuICAgICAgICAgICAgICBhLm9uVG91Y2hNb3ZlLFxuICAgICAgICAgICAgICBzXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgdCA9IGUuem9vbTtcbiAgICAgICAgaWYgKHQuZW5hYmxlZCkge1xuICAgICAgICAgIHZhciBhID0gZS5zdXBwb3J0O1xuICAgICAgICAgIGUuem9vbS5lbmFibGVkID0gITE7XG4gICAgICAgICAgdmFyIGkgPSAhKFxuICAgICAgICAgICAgICBcInRvdWNoc3RhcnRcIiAhPT0gZS50b3VjaEV2ZW50cy5zdGFydCB8fFxuICAgICAgICAgICAgICAhYS5wYXNzaXZlTGlzdGVuZXIgfHxcbiAgICAgICAgICAgICAgIWUucGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnNcbiAgICAgICAgICAgICkgJiYgeyBwYXNzaXZlOiAhMCwgY2FwdHVyZTogITEgfSxcbiAgICAgICAgICAgIHMgPSAhYS5wYXNzaXZlTGlzdGVuZXIgfHwgeyBwYXNzaXZlOiAhMSwgY2FwdHVyZTogITAgfSxcbiAgICAgICAgICAgIHIgPSBcIi5cIiArIGUucGFyYW1zLnNsaWRlQ2xhc3M7XG4gICAgICAgICAgYS5nZXN0dXJlc1xuICAgICAgICAgICAgPyAoZS4kd3JhcHBlckVsLm9mZihlLnRvdWNoRXZlbnRzLnN0YXJ0LCBlLnpvb20uZW5hYmxlR2VzdHVyZXMsIGkpLFxuICAgICAgICAgICAgICBlLiR3cmFwcGVyRWwub2ZmKGUudG91Y2hFdmVudHMuZW5kLCBlLnpvb20uZGlzYWJsZUdlc3R1cmVzLCBpKSlcbiAgICAgICAgICAgIDogXCJ0b3VjaHN0YXJ0XCIgPT09IGUudG91Y2hFdmVudHMuc3RhcnQgJiZcbiAgICAgICAgICAgICAgKGUuJHdyYXBwZXJFbC5vZmYoZS50b3VjaEV2ZW50cy5zdGFydCwgciwgdC5vbkdlc3R1cmVTdGFydCwgaSksXG4gICAgICAgICAgICAgIGUuJHdyYXBwZXJFbC5vZmYoZS50b3VjaEV2ZW50cy5tb3ZlLCByLCB0Lm9uR2VzdHVyZUNoYW5nZSwgcyksXG4gICAgICAgICAgICAgIGUuJHdyYXBwZXJFbC5vZmYoZS50b3VjaEV2ZW50cy5lbmQsIHIsIHQub25HZXN0dXJlRW5kLCBpKSxcbiAgICAgICAgICAgICAgZS50b3VjaEV2ZW50cy5jYW5jZWwgJiZcbiAgICAgICAgICAgICAgICBlLiR3cmFwcGVyRWwub2ZmKGUudG91Y2hFdmVudHMuY2FuY2VsLCByLCB0Lm9uR2VzdHVyZUVuZCwgaSkpLFxuICAgICAgICAgICAgZS4kd3JhcHBlckVsLm9mZihcbiAgICAgICAgICAgICAgZS50b3VjaEV2ZW50cy5tb3ZlLFxuICAgICAgICAgICAgICBcIi5cIiArIGUucGFyYW1zLnpvb20uY29udGFpbmVyQ2xhc3MsXG4gICAgICAgICAgICAgIHQub25Ub3VjaE1vdmUsXG4gICAgICAgICAgICAgIHNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSxcbiAgICB0ZSA9IHtcbiAgICAgIGxvYWRJblNsaWRlOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB2b2lkIDAgPT09IHQgJiYgKHQgPSAhMCk7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICBpID0gYS5wYXJhbXMubGF6eTtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gZSAmJiAwICE9PSBhLnNsaWRlcy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcyA9XG4gICAgICAgICAgICAgIGEudmlydHVhbCAmJiBhLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWRcbiAgICAgICAgICAgICAgICA/IGEuJHdyYXBwZXJFbC5jaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgXCIuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIGEucGFyYW1zLnNsaWRlQ2xhc3MgK1xuICAgICAgICAgICAgICAgICAgICAgICdbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInICtcbiAgICAgICAgICAgICAgICAgICAgICBlICtcbiAgICAgICAgICAgICAgICAgICAgICAnXCJdJ1xuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogYS5zbGlkZXMuZXEoZSksXG4gICAgICAgICAgICByID0gcy5maW5kKFxuICAgICAgICAgICAgICBcIi5cIiArXG4gICAgICAgICAgICAgICAgaS5lbGVtZW50Q2xhc3MgK1xuICAgICAgICAgICAgICAgIFwiOm5vdCguXCIgK1xuICAgICAgICAgICAgICAgIGkubG9hZGVkQ2xhc3MgK1xuICAgICAgICAgICAgICAgIFwiKTpub3QoLlwiICtcbiAgICAgICAgICAgICAgICBpLmxvYWRpbmdDbGFzcyArXG4gICAgICAgICAgICAgICAgXCIpXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgIXMuaGFzQ2xhc3MoaS5lbGVtZW50Q2xhc3MpIHx8XG4gICAgICAgICAgICBzLmhhc0NsYXNzKGkubG9hZGVkQ2xhc3MpIHx8XG4gICAgICAgICAgICBzLmhhc0NsYXNzKGkubG9hZGluZ0NsYXNzKSB8fFxuICAgICAgICAgICAgci5wdXNoKHNbMF0pLFxuICAgICAgICAgICAgMCAhPT0gci5sZW5ndGggJiZcbiAgICAgICAgICAgICAgci5lYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBtKGUpO1xuICAgICAgICAgICAgICAgIHIuYWRkQ2xhc3MoaS5sb2FkaW5nQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHZhciBuID0gci5hdHRyKFwiZGF0YS1iYWNrZ3JvdW5kXCIpLFxuICAgICAgICAgICAgICAgICAgbCA9IHIuYXR0cihcImRhdGEtc3JjXCIpLFxuICAgICAgICAgICAgICAgICAgbyA9IHIuYXR0cihcImRhdGEtc3Jjc2V0XCIpLFxuICAgICAgICAgICAgICAgICAgZCA9IHIuYXR0cihcImRhdGEtc2l6ZXNcIiksXG4gICAgICAgICAgICAgICAgICBwID0gci5wYXJlbnQoXCJwaWN0dXJlXCIpO1xuICAgICAgICAgICAgICAgIGEubG9hZEltYWdlKHJbMF0sIGwgfHwgbiwgbywgZCwgITEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IGEgJiYgYSAmJiAoIWEgfHwgYS5wYXJhbXMpICYmICFhLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgKG5cbiAgICAgICAgICAgICAgICAgICAgICAgID8gKHIuY3NzKFwiYmFja2dyb3VuZC1pbWFnZVwiLCAndXJsKFwiJyArIG4gKyAnXCIpJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHIucmVtb3ZlQXR0cihcImRhdGEtYmFja2dyb3VuZFwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKG8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoci5hdHRyKFwic3Jjc2V0XCIsIG8pLCByLnJlbW92ZUF0dHIoXCJkYXRhLXNyY3NldFwiKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGQgJiYgKHIuYXR0cihcInNpemVzXCIsIGQpLCByLnJlbW92ZUF0dHIoXCJkYXRhLXNpemVzXCIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmNoaWxkcmVuKFwic291cmNlXCIpLmVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuYXR0cihcImRhdGEtc3Jjc2V0XCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0LmF0dHIoXCJzcmNzZXRcIiwgdC5hdHRyKFwiZGF0YS1zcmNzZXRcIikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnJlbW92ZUF0dHIoXCJkYXRhLXNyY3NldFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGwgJiYgKHIuYXR0cihcInNyY1wiLCBsKSwgci5yZW1vdmVBdHRyKFwiZGF0YS1zcmNcIikpKSxcbiAgICAgICAgICAgICAgICAgICAgICByLmFkZENsYXNzKGkubG9hZGVkQ2xhc3MpLnJlbW92ZUNsYXNzKGkubG9hZGluZ0NsYXNzKSxcbiAgICAgICAgICAgICAgICAgICAgICBzLmZpbmQoXCIuXCIgKyBpLnByZWxvYWRlckNsYXNzKS5yZW1vdmUoKSxcbiAgICAgICAgICAgICAgICAgICAgICBhLnBhcmFtcy5sb29wICYmIHQpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gcy5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIik7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHMuaGFzQ2xhc3MoYS5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gYS4kd3JhcHBlckVsLmNoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiXTpub3QoLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5sYXp5LmxvYWRJblNsaWRlKHUuaW5kZXgoKSwgITEpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGEuJHdyYXBwZXJFbC5jaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJdJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEubGF6eS5sb2FkSW5TbGlkZShjLmluZGV4KCksICExKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYS5lbWl0KFwibGF6eUltYWdlUmVhZHlcIiwgc1swXSwgclswXSksXG4gICAgICAgICAgICAgICAgICAgICAgYS5wYXJhbXMuYXV0b0hlaWdodCAmJiBhLnVwZGF0ZUF1dG9IZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIGEuZW1pdChcImxhenlJbWFnZUxvYWRcIiwgc1swXSwgclswXSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgdCA9IGUuJHdyYXBwZXJFbCxcbiAgICAgICAgICBhID0gZS5wYXJhbXMsXG4gICAgICAgICAgaSA9IGUuc2xpZGVzLFxuICAgICAgICAgIHMgPSBlLmFjdGl2ZUluZGV4LFxuICAgICAgICAgIHIgPSBlLnZpcnR1YWwgJiYgYS52aXJ0dWFsLmVuYWJsZWQsXG4gICAgICAgICAgbiA9IGEubGF6eSxcbiAgICAgICAgICBsID0gYS5zbGlkZXNQZXJWaWV3O1xuICAgICAgICBmdW5jdGlvbiBvKGUpIHtcbiAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0LmNoaWxkcmVuKFxuICAgICAgICAgICAgICAgIFwiLlwiICsgYS5zbGlkZUNsYXNzICsgJ1tkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicgKyBlICsgJ1wiXSdcbiAgICAgICAgICAgICAgKS5sZW5ndGhcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaVtlXSkgcmV0dXJuICEwO1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkKGUpIHtcbiAgICAgICAgICByZXR1cm4gciA/IG0oZSkuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpIDogbShlKS5pbmRleCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJhdXRvXCIgPT09IGwgJiYgKGwgPSAwKSxcbiAgICAgICAgICBlLmxhenkuaW5pdGlhbEltYWdlTG9hZGVkIHx8IChlLmxhenkuaW5pdGlhbEltYWdlTG9hZGVkID0gITApLFxuICAgICAgICAgIGUucGFyYW1zLndhdGNoU2xpZGVzVmlzaWJpbGl0eSlcbiAgICAgICAgKVxuICAgICAgICAgIHQuY2hpbGRyZW4oXCIuXCIgKyBhLnNsaWRlVmlzaWJsZUNsYXNzKS5lYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgYSA9IHIgPyBtKHQpLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSA6IG0odCkuaW5kZXgoKTtcbiAgICAgICAgICAgIGUubGF6eS5sb2FkSW5TbGlkZShhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgZWxzZSBpZiAobCA+IDEpXG4gICAgICAgICAgZm9yICh2YXIgcCA9IHM7IHAgPCBzICsgbDsgcCArPSAxKSBvKHApICYmIGUubGF6eS5sb2FkSW5TbGlkZShwKTtcbiAgICAgICAgZWxzZSBlLmxhenkubG9hZEluU2xpZGUocyk7XG4gICAgICAgIGlmIChuLmxvYWRQcmV2TmV4dClcbiAgICAgICAgICBpZiAobCA+IDEgfHwgKG4ubG9hZFByZXZOZXh0QW1vdW50ICYmIG4ubG9hZFByZXZOZXh0QW1vdW50ID4gMSkpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIHZhciB1ID0gbi5sb2FkUHJldk5leHRBbW91bnQsXG4gICAgICAgICAgICAgICAgYyA9IGwsXG4gICAgICAgICAgICAgICAgaCA9IE1hdGgubWluKHMgKyBjICsgTWF0aC5tYXgodSwgYyksIGkubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICB2ID0gTWF0aC5tYXgocyAtIE1hdGgubWF4KGMsIHUpLCAwKSxcbiAgICAgICAgICAgICAgICBmID0gcyArIGw7XG4gICAgICAgICAgICAgIGYgPCBoO1xuICAgICAgICAgICAgICBmICs9IDFcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgbyhmKSAmJiBlLmxhenkubG9hZEluU2xpZGUoZik7XG4gICAgICAgICAgICBmb3IgKHZhciBnID0gdjsgZyA8IHM7IGcgKz0gMSkgbyhnKSAmJiBlLmxhenkubG9hZEluU2xpZGUoZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB5ID0gdC5jaGlsZHJlbihcIi5cIiArIGEuc2xpZGVOZXh0Q2xhc3MpO1xuICAgICAgICAgICAgeS5sZW5ndGggPiAwICYmIGUubGF6eS5sb2FkSW5TbGlkZShkKHkpKTtcbiAgICAgICAgICAgIHZhciB3ID0gdC5jaGlsZHJlbihcIi5cIiArIGEuc2xpZGVQcmV2Q2xhc3MpO1xuICAgICAgICAgICAgdy5sZW5ndGggPiAwICYmIGUubGF6eS5sb2FkSW5TbGlkZShkKHcpKTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2hlY2tJblZpZXdPbkxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSBsKCksXG4gICAgICAgICAgdCA9IHRoaXM7XG4gICAgICAgIGlmICh0ICYmICF0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHZhciBhID0gdC5wYXJhbXMubGF6eS5zY3JvbGxpbmdFbGVtZW50XG4gICAgICAgICAgICAgID8gbSh0LnBhcmFtcy5sYXp5LnNjcm9sbGluZ0VsZW1lbnQpXG4gICAgICAgICAgICAgIDogbShlKSxcbiAgICAgICAgICAgIGkgPSBhWzBdID09PSBlLFxuICAgICAgICAgICAgcyA9IGkgPyBlLmlubmVyV2lkdGggOiBhWzBdLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgciA9IGkgPyBlLmlubmVySGVpZ2h0IDogYVswXS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICBuID0gdC4kZWwub2Zmc2V0KCksXG4gICAgICAgICAgICBvID0gITE7XG4gICAgICAgICAgdC5ydGxUcmFuc2xhdGUgJiYgKG4ubGVmdCAtPSB0LiRlbFswXS5zY3JvbGxMZWZ0KTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgdmFyIGQgPSBbXG4gICAgICAgICAgICAgICAgW24ubGVmdCwgbi50b3BdLFxuICAgICAgICAgICAgICAgIFtuLmxlZnQgKyB0LndpZHRoLCBuLnRvcF0sXG4gICAgICAgICAgICAgICAgW24ubGVmdCwgbi50b3AgKyB0LmhlaWdodF0sXG4gICAgICAgICAgICAgICAgW24ubGVmdCArIHQud2lkdGgsIG4udG9wICsgdC5oZWlnaHRdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBwID0gMDtcbiAgICAgICAgICAgIHAgPCBkLmxlbmd0aDtcbiAgICAgICAgICAgIHAgKz0gMVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHUgPSBkW3BdO1xuICAgICAgICAgICAgaWYgKHVbMF0gPj0gMCAmJiB1WzBdIDw9IHMgJiYgdVsxXSA+PSAwICYmIHVbMV0gPD0gcikge1xuICAgICAgICAgICAgICBpZiAoMCA9PT0gdVswXSAmJiAwID09PSB1WzFdKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgbyA9ICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvXG4gICAgICAgICAgICA/ICh0LmxhenkubG9hZCgpLCBhLm9mZihcInNjcm9sbFwiLCB0LmxhenkuY2hlY2tJblZpZXdPbkxvYWQpKVxuICAgICAgICAgICAgOiB0Lmxhenkuc2Nyb2xsSGFuZGxlckF0dGFjaGVkIHx8XG4gICAgICAgICAgICAgICgodC5sYXp5LnNjcm9sbEhhbmRsZXJBdHRhY2hlZCA9ICEwKSxcbiAgICAgICAgICAgICAgYS5vbihcInNjcm9sbFwiLCB0LmxhenkuY2hlY2tJblZpZXdPbkxvYWQpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9LFxuICAgIGFlID0ge1xuICAgICAgTGluZWFyU3BsaW5lOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB2YXIgYSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHMsXG4gICAgICAgICAgcixcbiAgICAgICAgICBuLFxuICAgICAgICAgIGwgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgZm9yIChpID0gLTEsIGEgPSBlLmxlbmd0aDsgYSAtIGkgPiAxOyApXG4gICAgICAgICAgICAgIGVbKHMgPSAoYSArIGkpID4+IDEpXSA8PSB0ID8gKGkgPSBzKSA6IChhID0gcyk7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICh0aGlzLnggPSBlKSxcbiAgICAgICAgICAodGhpcy55ID0gdCksXG4gICAgICAgICAgKHRoaXMubGFzdEluZGV4ID0gZS5sZW5ndGggLSAxKSxcbiAgICAgICAgICAodGhpcy5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgICA/ICgobiA9IGwodGhpcy54LCBlKSksXG4gICAgICAgICAgICAgICAgKHIgPSBuIC0gMSksXG4gICAgICAgICAgICAgICAgKChlIC0gdGhpcy54W3JdKSAqICh0aGlzLnlbbl0gLSB0aGlzLnlbcl0pKSAvXG4gICAgICAgICAgICAgICAgICAodGhpcy54W25dIC0gdGhpcy54W3JdKSArXG4gICAgICAgICAgICAgICAgICB0aGlzLnlbcl0pXG4gICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgZ2V0SW50ZXJwb2xhdGVGdW5jdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICB0LmNvbnRyb2xsZXIuc3BsaW5lIHx8XG4gICAgICAgICAgKHQuY29udHJvbGxlci5zcGxpbmUgPSB0LnBhcmFtcy5sb29wXG4gICAgICAgICAgICA/IG5ldyBhZS5MaW5lYXJTcGxpbmUodC5zbGlkZXNHcmlkLCBlLnNsaWRlc0dyaWQpXG4gICAgICAgICAgICA6IG5ldyBhZS5MaW5lYXJTcGxpbmUodC5zbmFwR3JpZCwgZS5zbmFwR3JpZCkpO1xuICAgICAgfSxcbiAgICAgIHNldFRyYW5zbGF0ZTogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgdmFyIGEsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBzID0gdGhpcyxcbiAgICAgICAgICByID0gcy5jb250cm9sbGVyLmNvbnRyb2wsXG4gICAgICAgICAgbiA9IHMuY29uc3RydWN0b3I7XG4gICAgICAgIGZ1bmN0aW9uIGwoZSkge1xuICAgICAgICAgIHZhciB0ID0gcy5ydGxUcmFuc2xhdGUgPyAtcy50cmFuc2xhdGUgOiBzLnRyYW5zbGF0ZTtcbiAgICAgICAgICBcInNsaWRlXCIgPT09IHMucGFyYW1zLmNvbnRyb2xsZXIuYnkgJiZcbiAgICAgICAgICAgIChzLmNvbnRyb2xsZXIuZ2V0SW50ZXJwb2xhdGVGdW5jdGlvbihlKSxcbiAgICAgICAgICAgIChpID0gLXMuY29udHJvbGxlci5zcGxpbmUuaW50ZXJwb2xhdGUoLXQpKSksXG4gICAgICAgICAgICAoaSAmJiBcImNvbnRhaW5lclwiICE9PSBzLnBhcmFtcy5jb250cm9sbGVyLmJ5KSB8fFxuICAgICAgICAgICAgICAoKGEgPVxuICAgICAgICAgICAgICAgIChlLm1heFRyYW5zbGF0ZSgpIC0gZS5taW5UcmFuc2xhdGUoKSkgL1xuICAgICAgICAgICAgICAgIChzLm1heFRyYW5zbGF0ZSgpIC0gcy5taW5UcmFuc2xhdGUoKSkpLFxuICAgICAgICAgICAgICAoaSA9ICh0IC0gcy5taW5UcmFuc2xhdGUoKSkgKiBhICsgZS5taW5UcmFuc2xhdGUoKSkpLFxuICAgICAgICAgICAgcy5wYXJhbXMuY29udHJvbGxlci5pbnZlcnNlICYmIChpID0gZS5tYXhUcmFuc2xhdGUoKSAtIGkpLFxuICAgICAgICAgICAgZS51cGRhdGVQcm9ncmVzcyhpKSxcbiAgICAgICAgICAgIGUuc2V0VHJhbnNsYXRlKGksIHMpLFxuICAgICAgICAgICAgZS51cGRhdGVBY3RpdmVJbmRleCgpLFxuICAgICAgICAgICAgZS51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocikpXG4gICAgICAgICAgZm9yICh2YXIgbyA9IDA7IG8gPCByLmxlbmd0aDsgbyArPSAxKVxuICAgICAgICAgICAgcltvXSAhPT0gdCAmJiByW29dIGluc3RhbmNlb2YgbiAmJiBsKHJbb10pO1xuICAgICAgICBlbHNlIHIgaW5zdGFuY2VvZiBuICYmIHQgIT09IHIgJiYgbChyKTtcbiAgICAgIH0sXG4gICAgICBzZXRUcmFuc2l0aW9uOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB2YXIgYSxcbiAgICAgICAgICBpID0gdGhpcyxcbiAgICAgICAgICBzID0gaS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICByID0gaS5jb250cm9sbGVyLmNvbnRyb2w7XG4gICAgICAgIGZ1bmN0aW9uIG4odCkge1xuICAgICAgICAgIHQuc2V0VHJhbnNpdGlvbihlLCBpKSxcbiAgICAgICAgICAgIDAgIT09IGUgJiZcbiAgICAgICAgICAgICAgKHQudHJhbnNpdGlvblN0YXJ0KCksXG4gICAgICAgICAgICAgIHQucGFyYW1zLmF1dG9IZWlnaHQgJiZcbiAgICAgICAgICAgICAgICBFKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHQudXBkYXRlQXV0b0hlaWdodCgpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB0LiR3cmFwcGVyRWwudHJhbnNpdGlvbkVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgciAmJlxuICAgICAgICAgICAgICAgICAgKHQucGFyYW1zLmxvb3AgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzbGlkZVwiID09PSBpLnBhcmFtcy5jb250cm9sbGVyLmJ5ICYmXG4gICAgICAgICAgICAgICAgICAgIHQubG9vcEZpeCgpLFxuICAgICAgICAgICAgICAgICAgdC50cmFuc2l0aW9uRW5kKCkpO1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocikpXG4gICAgICAgICAgZm9yIChhID0gMDsgYSA8IHIubGVuZ3RoOyBhICs9IDEpXG4gICAgICAgICAgICByW2FdICE9PSB0ICYmIHJbYV0gaW5zdGFuY2VvZiBzICYmIG4oclthXSk7XG4gICAgICAgIGVsc2UgciBpbnN0YW5jZW9mIHMgJiYgdCAhPT0gciAmJiBuKHIpO1xuICAgICAgfSxcbiAgICB9LFxuICAgIGllID0ge1xuICAgICAgZ2V0UmFuZG9tTnVtYmVyOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSAxNik7XG4gICAgICAgIHJldHVybiBcInhcIi5yZXBlYXQoZSkucmVwbGFjZSgveC9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoMTYgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygxNik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG1ha2VFbEZvY3VzYWJsZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuYXR0cihcInRhYkluZGV4XCIsIFwiMFwiKSwgZTtcbiAgICAgIH0sXG4gICAgICBtYWtlRWxOb3RGb2N1c2FibGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLmF0dHIoXCJ0YWJJbmRleFwiLCBcIi0xXCIpLCBlO1xuICAgICAgfSxcbiAgICAgIGFkZEVsUm9sZTogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgcmV0dXJuIGUuYXR0cihcInJvbGVcIiwgdCksIGU7XG4gICAgICB9LFxuICAgICAgYWRkRWxSb2xlRGVzY3JpcHRpb246IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHJldHVybiBlLmF0dHIoXCJhcmlhLXJvbGUtZGVzY3JpcHRpb25cIiwgdCksIGU7XG4gICAgICB9LFxuICAgICAgYWRkRWxDb250cm9sczogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgcmV0dXJuIGUuYXR0cihcImFyaWEtY29udHJvbHNcIiwgdCksIGU7XG4gICAgICB9LFxuICAgICAgYWRkRWxMYWJlbDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgcmV0dXJuIGUuYXR0cihcImFyaWEtbGFiZWxcIiwgdCksIGU7XG4gICAgICB9LFxuICAgICAgYWRkRWxJZDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgcmV0dXJuIGUuYXR0cihcImlkXCIsIHQpLCBlO1xuICAgICAgfSxcbiAgICAgIGFkZEVsTGl2ZTogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgcmV0dXJuIGUuYXR0cihcImFyaWEtbGl2ZVwiLCB0KSwgZTtcbiAgICAgIH0sXG4gICAgICBkaXNhYmxlRWw6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsICEwKSwgZTtcbiAgICAgIH0sXG4gICAgICBlbmFibGVFbDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuYXR0cihcImFyaWEtZGlzYWJsZWRcIiwgITEpLCBlO1xuICAgICAgfSxcbiAgICAgIG9uRW50ZXJLZXk6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcyxcbiAgICAgICAgICBhID0gdC5wYXJhbXMuYTExeTtcbiAgICAgICAgaWYgKDEzID09PSBlLmtleUNvZGUpIHtcbiAgICAgICAgICB2YXIgaSA9IG0oZS50YXJnZXQpO1xuICAgICAgICAgIHQubmF2aWdhdGlvbiAmJlxuICAgICAgICAgICAgdC5uYXZpZ2F0aW9uLiRuZXh0RWwgJiZcbiAgICAgICAgICAgIGkuaXModC5uYXZpZ2F0aW9uLiRuZXh0RWwpICYmXG4gICAgICAgICAgICAoKHQuaXNFbmQgJiYgIXQucGFyYW1zLmxvb3ApIHx8IHQuc2xpZGVOZXh0KCksXG4gICAgICAgICAgICB0LmlzRW5kXG4gICAgICAgICAgICAgID8gdC5hMTF5Lm5vdGlmeShhLmxhc3RTbGlkZU1lc3NhZ2UpXG4gICAgICAgICAgICAgIDogdC5hMTF5Lm5vdGlmeShhLm5leHRTbGlkZU1lc3NhZ2UpKSxcbiAgICAgICAgICAgIHQubmF2aWdhdGlvbiAmJlxuICAgICAgICAgICAgICB0Lm5hdmlnYXRpb24uJHByZXZFbCAmJlxuICAgICAgICAgICAgICBpLmlzKHQubmF2aWdhdGlvbi4kcHJldkVsKSAmJlxuICAgICAgICAgICAgICAoKHQuaXNCZWdpbm5pbmcgJiYgIXQucGFyYW1zLmxvb3ApIHx8IHQuc2xpZGVQcmV2KCksXG4gICAgICAgICAgICAgIHQuaXNCZWdpbm5pbmdcbiAgICAgICAgICAgICAgICA/IHQuYTExeS5ub3RpZnkoYS5maXJzdFNsaWRlTWVzc2FnZSlcbiAgICAgICAgICAgICAgICA6IHQuYTExeS5ub3RpZnkoYS5wcmV2U2xpZGVNZXNzYWdlKSksXG4gICAgICAgICAgICB0LnBhZ2luYXRpb24gJiZcbiAgICAgICAgICAgICAgaS5pcyhcIi5cIiArIHQucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3MucmVwbGFjZSgvIC9nLCBcIi5cIikpICYmXG4gICAgICAgICAgICAgIGlbMF0uY2xpY2soKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG5vdGlmeTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmExMXkubGl2ZVJlZ2lvbjtcbiAgICAgICAgMCAhPT0gdC5sZW5ndGggJiYgKHQuaHRtbChcIlwiKSwgdC5odG1sKGUpKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVOYXZpZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgaWYgKCFlLnBhcmFtcy5sb29wICYmIGUubmF2aWdhdGlvbikge1xuICAgICAgICAgIHZhciB0ID0gZS5uYXZpZ2F0aW9uLFxuICAgICAgICAgICAgYSA9IHQuJG5leHRFbCxcbiAgICAgICAgICAgIGkgPSB0LiRwcmV2RWw7XG4gICAgICAgICAgaSAmJlxuICAgICAgICAgICAgaS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAoZS5pc0JlZ2lubmluZ1xuICAgICAgICAgICAgICA/IChlLmExMXkuZGlzYWJsZUVsKGkpLCBlLmExMXkubWFrZUVsTm90Rm9jdXNhYmxlKGkpKVxuICAgICAgICAgICAgICA6IChlLmExMXkuZW5hYmxlRWwoaSksIGUuYTExeS5tYWtlRWxGb2N1c2FibGUoaSkpKSxcbiAgICAgICAgICAgIGEgJiZcbiAgICAgICAgICAgICAgYS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgIChlLmlzRW5kXG4gICAgICAgICAgICAgICAgPyAoZS5hMTF5LmRpc2FibGVFbChhKSwgZS5hMTF5Lm1ha2VFbE5vdEZvY3VzYWJsZShhKSlcbiAgICAgICAgICAgICAgICA6IChlLmExMXkuZW5hYmxlRWwoYSksIGUuYTExeS5tYWtlRWxGb2N1c2FibGUoYSkpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZVBhZ2luYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgIHQgPSBlLnBhcmFtcy5hMTF5O1xuICAgICAgICBlLnBhZ2luYXRpb24gJiZcbiAgICAgICAgICBlLnBhcmFtcy5wYWdpbmF0aW9uLmNsaWNrYWJsZSAmJlxuICAgICAgICAgIGUucGFnaW5hdGlvbi5idWxsZXRzICYmXG4gICAgICAgICAgZS5wYWdpbmF0aW9uLmJ1bGxldHMubGVuZ3RoICYmXG4gICAgICAgICAgZS5wYWdpbmF0aW9uLmJ1bGxldHMuZWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgdmFyIGkgPSBtKGEpO1xuICAgICAgICAgICAgZS5hMTF5Lm1ha2VFbEZvY3VzYWJsZShpKSxcbiAgICAgICAgICAgICAgZS5wYXJhbXMucGFnaW5hdGlvbi5yZW5kZXJCdWxsZXQgfHxcbiAgICAgICAgICAgICAgICAoZS5hMTF5LmFkZEVsUm9sZShpLCBcImJ1dHRvblwiKSxcbiAgICAgICAgICAgICAgICBlLmExMXkuYWRkRWxMYWJlbChcbiAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICB0LnBhZ2luYXRpb25CdWxsZXRNZXNzYWdlLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIC9cXHtcXHtpbmRleFxcfVxcfS8sXG4gICAgICAgICAgICAgICAgICAgIGkuaW5kZXgoKSArIDFcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICB0ID0gZS5wYXJhbXMuYTExeTtcbiAgICAgICAgZS4kZWwuYXBwZW5kKGUuYTExeS5saXZlUmVnaW9uKTtcbiAgICAgICAgdmFyIGEgPSBlLiRlbDtcbiAgICAgICAgdC5jb250YWluZXJSb2xlRGVzY3JpcHRpb25NZXNzYWdlICYmXG4gICAgICAgICAgZS5hMTF5LmFkZEVsUm9sZURlc2NyaXB0aW9uKGEsIHQuY29udGFpbmVyUm9sZURlc2NyaXB0aW9uTWVzc2FnZSksXG4gICAgICAgICAgdC5jb250YWluZXJNZXNzYWdlICYmIGUuYTExeS5hZGRFbExhYmVsKGEsIHQuY29udGFpbmVyTWVzc2FnZSk7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgIHMsXG4gICAgICAgICAgcixcbiAgICAgICAgICBuID0gZS4kd3JhcHBlckVsLFxuICAgICAgICAgIGwgPSBuLmF0dHIoXCJpZFwiKSB8fCBcInN3aXBlci13cmFwcGVyLVwiICsgZS5hMTF5LmdldFJhbmRvbU51bWJlcigxNik7XG4gICAgICAgIGUuYTExeS5hZGRFbElkKG4sIGwpLFxuICAgICAgICAgIChpID1cbiAgICAgICAgICAgIGUucGFyYW1zLmF1dG9wbGF5ICYmIGUucGFyYW1zLmF1dG9wbGF5LmVuYWJsZWQgPyBcIm9mZlwiIDogXCJwb2xpdGVcIiksXG4gICAgICAgICAgZS5hMTF5LmFkZEVsTGl2ZShuLCBpKSxcbiAgICAgICAgICB0Lml0ZW1Sb2xlRGVzY3JpcHRpb25NZXNzYWdlICYmXG4gICAgICAgICAgICBlLmExMXkuYWRkRWxSb2xlRGVzY3JpcHRpb24oXG4gICAgICAgICAgICAgIG0oZS5zbGlkZXMpLFxuICAgICAgICAgICAgICB0Lml0ZW1Sb2xlRGVzY3JpcHRpb25NZXNzYWdlXG4gICAgICAgICAgICApLFxuICAgICAgICAgIGUuYTExeS5hZGRFbFJvbGUobShlLnNsaWRlcyksIFwiZ3JvdXBcIiksXG4gICAgICAgICAgZS5zbGlkZXMuZWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIGEgPSBtKHQpO1xuICAgICAgICAgICAgZS5hMTF5LmFkZEVsTGFiZWwoYSwgYS5pbmRleCgpICsgMSArIFwiIC8gXCIgKyBlLnNsaWRlcy5sZW5ndGgpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGUubmF2aWdhdGlvbiAmJiBlLm5hdmlnYXRpb24uJG5leHRFbCAmJiAocyA9IGUubmF2aWdhdGlvbi4kbmV4dEVsKSxcbiAgICAgICAgICBlLm5hdmlnYXRpb24gJiYgZS5uYXZpZ2F0aW9uLiRwcmV2RWwgJiYgKHIgPSBlLm5hdmlnYXRpb24uJHByZXZFbCksXG4gICAgICAgICAgcyAmJlxuICAgICAgICAgICAgcy5sZW5ndGggJiZcbiAgICAgICAgICAgIChlLmExMXkubWFrZUVsRm9jdXNhYmxlKHMpLFxuICAgICAgICAgICAgXCJCVVRUT05cIiAhPT0gc1swXS50YWdOYW1lICYmXG4gICAgICAgICAgICAgIChlLmExMXkuYWRkRWxSb2xlKHMsIFwiYnV0dG9uXCIpLFxuICAgICAgICAgICAgICBzLm9uKFwia2V5ZG93blwiLCBlLmExMXkub25FbnRlcktleSkpLFxuICAgICAgICAgICAgZS5hMTF5LmFkZEVsTGFiZWwocywgdC5uZXh0U2xpZGVNZXNzYWdlKSxcbiAgICAgICAgICAgIGUuYTExeS5hZGRFbENvbnRyb2xzKHMsIGwpKSxcbiAgICAgICAgICByICYmXG4gICAgICAgICAgICByLmxlbmd0aCAmJlxuICAgICAgICAgICAgKGUuYTExeS5tYWtlRWxGb2N1c2FibGUociksXG4gICAgICAgICAgICBcIkJVVFRPTlwiICE9PSByWzBdLnRhZ05hbWUgJiZcbiAgICAgICAgICAgICAgKGUuYTExeS5hZGRFbFJvbGUociwgXCJidXR0b25cIiksXG4gICAgICAgICAgICAgIHIub24oXCJrZXlkb3duXCIsIGUuYTExeS5vbkVudGVyS2V5KSksXG4gICAgICAgICAgICBlLmExMXkuYWRkRWxMYWJlbChyLCB0LnByZXZTbGlkZU1lc3NhZ2UpLFxuICAgICAgICAgICAgZS5hMTF5LmFkZEVsQ29udHJvbHMociwgbCkpLFxuICAgICAgICAgIGUucGFnaW5hdGlvbiAmJlxuICAgICAgICAgICAgZS5wYXJhbXMucGFnaW5hdGlvbi5jbGlja2FibGUgJiZcbiAgICAgICAgICAgIGUucGFnaW5hdGlvbi5idWxsZXRzICYmXG4gICAgICAgICAgICBlLnBhZ2luYXRpb24uYnVsbGV0cy5sZW5ndGggJiZcbiAgICAgICAgICAgIGUucGFnaW5hdGlvbi4kZWwub24oXG4gICAgICAgICAgICAgIFwia2V5ZG93blwiLFxuICAgICAgICAgICAgICBcIi5cIiArIGUucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3MucmVwbGFjZSgvIC9nLCBcIi5cIiksXG4gICAgICAgICAgICAgIGUuYTExeS5vbkVudGVyS2V5XG4gICAgICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUsXG4gICAgICAgICAgdCxcbiAgICAgICAgICBhID0gdGhpcztcbiAgICAgICAgYS5hMTF5LmxpdmVSZWdpb24gJiZcbiAgICAgICAgICBhLmExMXkubGl2ZVJlZ2lvbi5sZW5ndGggPiAwICYmXG4gICAgICAgICAgYS5hMTF5LmxpdmVSZWdpb24ucmVtb3ZlKCksXG4gICAgICAgICAgYS5uYXZpZ2F0aW9uICYmIGEubmF2aWdhdGlvbi4kbmV4dEVsICYmIChlID0gYS5uYXZpZ2F0aW9uLiRuZXh0RWwpLFxuICAgICAgICAgIGEubmF2aWdhdGlvbiAmJiBhLm5hdmlnYXRpb24uJHByZXZFbCAmJiAodCA9IGEubmF2aWdhdGlvbi4kcHJldkVsKSxcbiAgICAgICAgICBlICYmIGUub2ZmKFwia2V5ZG93blwiLCBhLmExMXkub25FbnRlcktleSksXG4gICAgICAgICAgdCAmJiB0Lm9mZihcImtleWRvd25cIiwgYS5hMTF5Lm9uRW50ZXJLZXkpLFxuICAgICAgICAgIGEucGFnaW5hdGlvbiAmJlxuICAgICAgICAgICAgYS5wYXJhbXMucGFnaW5hdGlvbi5jbGlja2FibGUgJiZcbiAgICAgICAgICAgIGEucGFnaW5hdGlvbi5idWxsZXRzICYmXG4gICAgICAgICAgICBhLnBhZ2luYXRpb24uYnVsbGV0cy5sZW5ndGggJiZcbiAgICAgICAgICAgIGEucGFnaW5hdGlvbi4kZWwub2ZmKFxuICAgICAgICAgICAgICBcImtleWRvd25cIixcbiAgICAgICAgICAgICAgXCIuXCIgKyBhLnBhcmFtcy5wYWdpbmF0aW9uLmJ1bGxldENsYXNzLnJlcGxhY2UoLyAvZywgXCIuXCIpLFxuICAgICAgICAgICAgICBhLmExMXkub25FbnRlcktleVxuICAgICAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICBzZSA9IHtcbiAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgIHQgPSBsKCk7XG4gICAgICAgIGlmIChlLnBhcmFtcy5oaXN0b3J5KSB7XG4gICAgICAgICAgaWYgKCF0Lmhpc3RvcnkgfHwgIXQuaGlzdG9yeS5wdXNoU3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoZS5wYXJhbXMuaGlzdG9yeS5lbmFibGVkID0gITEpLFxuICAgICAgICAgICAgICB2b2lkIChlLnBhcmFtcy5oYXNoTmF2aWdhdGlvbi5lbmFibGVkID0gITApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHZhciBhID0gZS5oaXN0b3J5O1xuICAgICAgICAgIChhLmluaXRpYWxpemVkID0gITApLFxuICAgICAgICAgICAgKGEucGF0aHMgPSBzZS5nZXRQYXRoVmFsdWVzKGUucGFyYW1zLnVybCkpLFxuICAgICAgICAgICAgKGEucGF0aHMua2V5IHx8IGEucGF0aHMudmFsdWUpICYmXG4gICAgICAgICAgICAgIChhLnNjcm9sbFRvU2xpZGUoMCwgYS5wYXRocy52YWx1ZSwgZS5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0KSxcbiAgICAgICAgICAgICAgZS5wYXJhbXMuaGlzdG9yeS5yZXBsYWNlU3RhdGUgfHxcbiAgICAgICAgICAgICAgICB0LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBlLmhpc3Rvcnkuc2V0SGlzdG9yeVBvcFN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gbCgpO1xuICAgICAgICB0aGlzLnBhcmFtcy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSB8fFxuICAgICAgICAgIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMuaGlzdG9yeS5zZXRIaXN0b3J5UG9wU3RhdGUpO1xuICAgICAgfSxcbiAgICAgIHNldEhpc3RvcnlQb3BTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgIChlLmhpc3RvcnkucGF0aHMgPSBzZS5nZXRQYXRoVmFsdWVzKGUucGFyYW1zLnVybCkpLFxuICAgICAgICAgIGUuaGlzdG9yeS5zY3JvbGxUb1NsaWRlKGUucGFyYW1zLnNwZWVkLCBlLmhpc3RvcnkucGF0aHMudmFsdWUsICExKTtcbiAgICAgIH0sXG4gICAgICBnZXRQYXRoVmFsdWVzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdCA9IGwoKSxcbiAgICAgICAgICBhID0gKGUgPyBuZXcgVVJMKGUpIDogdC5sb2NhdGlvbikucGF0aG5hbWVcbiAgICAgICAgICAgIC5zbGljZSgxKVxuICAgICAgICAgICAgLnNwbGl0KFwiL1wiKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJcIiAhPT0gZTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIGkgPSBhLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHsga2V5OiBhW2kgLSAyXSwgdmFsdWU6IGFbaSAtIDFdIH07XG4gICAgICB9LFxuICAgICAgc2V0SGlzdG9yeTogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgIGkgPSBsKCk7XG4gICAgICAgIGlmIChhLmhpc3RvcnkuaW5pdGlhbGl6ZWQgJiYgYS5wYXJhbXMuaGlzdG9yeS5lbmFibGVkKSB7XG4gICAgICAgICAgdmFyIHM7XG4gICAgICAgICAgcyA9IGEucGFyYW1zLnVybCA/IG5ldyBVUkwoYS5wYXJhbXMudXJsKSA6IGkubG9jYXRpb247XG4gICAgICAgICAgdmFyIHIgPSBhLnNsaWRlcy5lcSh0KSxcbiAgICAgICAgICAgIG4gPSBzZS5zbHVnaWZ5KHIuYXR0cihcImRhdGEtaGlzdG9yeVwiKSk7XG4gICAgICAgICAgcy5wYXRobmFtZS5pbmNsdWRlcyhlKSB8fCAobiA9IGUgKyBcIi9cIiArIG4pO1xuICAgICAgICAgIHZhciBvID0gaS5oaXN0b3J5LnN0YXRlO1xuICAgICAgICAgIChvICYmIG8udmFsdWUgPT09IG4pIHx8XG4gICAgICAgICAgICAoYS5wYXJhbXMuaGlzdG9yeS5yZXBsYWNlU3RhdGVcbiAgICAgICAgICAgICAgPyBpLmhpc3RvcnkucmVwbGFjZVN0YXRlKHsgdmFsdWU6IG4gfSwgbnVsbCwgbilcbiAgICAgICAgICAgICAgOiBpLmhpc3RvcnkucHVzaFN0YXRlKHsgdmFsdWU6IG4gfSwgbnVsbCwgbikpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2x1Z2lmeTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXHMrL2csIFwiLVwiKVxuICAgICAgICAgIC5yZXBsYWNlKC9bXlxcdy1dKy9nLCBcIlwiKVxuICAgICAgICAgIC5yZXBsYWNlKC8tLSsvZywgXCItXCIpXG4gICAgICAgICAgLnJlcGxhY2UoL14tKy8sIFwiXCIpXG4gICAgICAgICAgLnJlcGxhY2UoLy0rJC8sIFwiXCIpO1xuICAgICAgfSxcbiAgICAgIHNjcm9sbFRvU2xpZGU6IGZ1bmN0aW9uIChlLCB0LCBhKSB7XG4gICAgICAgIHZhciBpID0gdGhpcztcbiAgICAgICAgaWYgKHQpXG4gICAgICAgICAgZm9yICh2YXIgcyA9IDAsIHIgPSBpLnNsaWRlcy5sZW5ndGg7IHMgPCByOyBzICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBuID0gaS5zbGlkZXMuZXEocyk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHNlLnNsdWdpZnkobi5hdHRyKFwiZGF0YS1oaXN0b3J5XCIpKSA9PT0gdCAmJlxuICAgICAgICAgICAgICAhbi5oYXNDbGFzcyhpLnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBsID0gbi5pbmRleCgpO1xuICAgICAgICAgICAgICBpLnNsaWRlVG8obCwgZSwgYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGkuc2xpZGVUbygwLCBlLCBhKTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICByZSA9IHtcbiAgICAgIG9uSGFzaENhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICB0ID0gcigpO1xuICAgICAgICBlLmVtaXQoXCJoYXNoQ2hhbmdlXCIpO1xuICAgICAgICB2YXIgYSA9IHQubG9jYXRpb24uaGFzaC5yZXBsYWNlKFwiI1wiLCBcIlwiKTtcbiAgICAgICAgaWYgKGEgIT09IGUuc2xpZGVzLmVxKGUuYWN0aXZlSW5kZXgpLmF0dHIoXCJkYXRhLWhhc2hcIikpIHtcbiAgICAgICAgICB2YXIgaSA9IGUuJHdyYXBwZXJFbFxuICAgICAgICAgICAgLmNoaWxkcmVuKFwiLlwiICsgZS5wYXJhbXMuc2xpZGVDbGFzcyArICdbZGF0YS1oYXNoPVwiJyArIGEgKyAnXCJdJylcbiAgICAgICAgICAgIC5pbmRleCgpO1xuICAgICAgICAgIGlmICh2b2lkIDAgPT09IGkpIHJldHVybjtcbiAgICAgICAgICBlLnNsaWRlVG8oaSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRIYXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICB0ID0gbCgpLFxuICAgICAgICAgIGEgPSByKCk7XG4gICAgICAgIGlmIChlLmhhc2hOYXZpZ2F0aW9uLmluaXRpYWxpemVkICYmIGUucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZS5wYXJhbXMuaGFzaE5hdmlnYXRpb24ucmVwbGFjZVN0YXRlICYmXG4gICAgICAgICAgICB0Lmhpc3RvcnkgJiZcbiAgICAgICAgICAgIHQuaGlzdG9yeS5yZXBsYWNlU3RhdGVcbiAgICAgICAgICApXG4gICAgICAgICAgICB0Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBcIiNcIiArIGUuc2xpZGVzLmVxKGUuYWN0aXZlSW5kZXgpLmF0dHIoXCJkYXRhLWhhc2hcIikgfHwgXCJcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgZS5lbWl0KFwiaGFzaFNldFwiKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpID0gZS5zbGlkZXMuZXEoZS5hY3RpdmVJbmRleCksXG4gICAgICAgICAgICAgIHMgPSBpLmF0dHIoXCJkYXRhLWhhc2hcIikgfHwgaS5hdHRyKFwiZGF0YS1oaXN0b3J5XCIpO1xuICAgICAgICAgICAgKGEubG9jYXRpb24uaGFzaCA9IHMgfHwgXCJcIiksIGUuZW1pdChcImhhc2hTZXRcIik7XG4gICAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgIHQgPSByKCksXG4gICAgICAgICAgYSA9IGwoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICEoXG4gICAgICAgICAgICAhZS5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCB8fFxuICAgICAgICAgICAgKGUucGFyYW1zLmhpc3RvcnkgJiYgZS5wYXJhbXMuaGlzdG9yeS5lbmFibGVkKVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgZS5oYXNoTmF2aWdhdGlvbi5pbml0aWFsaXplZCA9ICEwO1xuICAgICAgICAgIHZhciBpID0gdC5sb2NhdGlvbi5oYXNoLnJlcGxhY2UoXCIjXCIsIFwiXCIpO1xuICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgZm9yICh2YXIgcyA9IDAsIG4gPSBlLnNsaWRlcy5sZW5ndGg7IHMgPCBuOyBzICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIG8gPSBlLnNsaWRlcy5lcShzKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChvLmF0dHIoXCJkYXRhLWhhc2hcIikgfHwgby5hdHRyKFwiZGF0YS1oaXN0b3J5XCIpKSA9PT0gaSAmJlxuICAgICAgICAgICAgICAgICFvLmhhc0NsYXNzKGUucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gby5pbmRleCgpO1xuICAgICAgICAgICAgICAgIGUuc2xpZGVUbyhkLCAwLCBlLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQsICEwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGUucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLndhdGNoU3RhdGUgJiZcbiAgICAgICAgICAgIG0oYSkub24oXCJoYXNoY2hhbmdlXCIsIGUuaGFzaE5hdmlnYXRpb24ub25IYXNoQ2FuZ2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IGwoKTtcbiAgICAgICAgdGhpcy5wYXJhbXMuaGFzaE5hdmlnYXRpb24ud2F0Y2hTdGF0ZSAmJlxuICAgICAgICAgIG0oZSkub2ZmKFwiaGFzaGNoYW5nZVwiLCB0aGlzLmhhc2hOYXZpZ2F0aW9uLm9uSGFzaENhbmdlKTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICBuZSA9IHtcbiAgICAgIHJ1bjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgdCA9IGUuc2xpZGVzLmVxKGUuYWN0aXZlSW5kZXgpLFxuICAgICAgICAgIGEgPSBlLnBhcmFtcy5hdXRvcGxheS5kZWxheTtcbiAgICAgICAgdC5hdHRyKFwiZGF0YS1zd2lwZXItYXV0b3BsYXlcIikgJiZcbiAgICAgICAgICAoYSA9IHQuYXR0cihcImRhdGEtc3dpcGVyLWF1dG9wbGF5XCIpIHx8IGUucGFyYW1zLmF1dG9wbGF5LmRlbGF5KSxcbiAgICAgICAgICBjbGVhclRpbWVvdXQoZS5hdXRvcGxheS50aW1lb3V0KSxcbiAgICAgICAgICAoZS5hdXRvcGxheS50aW1lb3V0ID0gRShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgIGUucGFyYW1zLmF1dG9wbGF5LnJldmVyc2VEaXJlY3Rpb25cbiAgICAgICAgICAgICAgPyBlLnBhcmFtcy5sb29wXG4gICAgICAgICAgICAgICAgPyAoZS5sb29wRml4KCksXG4gICAgICAgICAgICAgICAgICAodCA9IGUuc2xpZGVQcmV2KGUucGFyYW1zLnNwZWVkLCAhMCwgITApKSxcbiAgICAgICAgICAgICAgICAgIGUuZW1pdChcImF1dG9wbGF5XCIpKVxuICAgICAgICAgICAgICAgIDogZS5pc0JlZ2lubmluZ1xuICAgICAgICAgICAgICAgID8gZS5wYXJhbXMuYXV0b3BsYXkuc3RvcE9uTGFzdFNsaWRlXG4gICAgICAgICAgICAgICAgICA/IGUuYXV0b3BsYXkuc3RvcCgpXG4gICAgICAgICAgICAgICAgICA6ICgodCA9IGUuc2xpZGVUbyhcbiAgICAgICAgICAgICAgICAgICAgICBlLnNsaWRlcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgICAgICAgIGUucGFyYW1zLnNwZWVkLFxuICAgICAgICAgICAgICAgICAgICAgICEwLFxuICAgICAgICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICBlLmVtaXQoXCJhdXRvcGxheVwiKSlcbiAgICAgICAgICAgICAgICA6ICgodCA9IGUuc2xpZGVQcmV2KGUucGFyYW1zLnNwZWVkLCAhMCwgITApKSxcbiAgICAgICAgICAgICAgICAgIGUuZW1pdChcImF1dG9wbGF5XCIpKVxuICAgICAgICAgICAgICA6IGUucGFyYW1zLmxvb3BcbiAgICAgICAgICAgICAgPyAoZS5sb29wRml4KCksXG4gICAgICAgICAgICAgICAgKHQgPSBlLnNsaWRlTmV4dChlLnBhcmFtcy5zcGVlZCwgITAsICEwKSksXG4gICAgICAgICAgICAgICAgZS5lbWl0KFwiYXV0b3BsYXlcIikpXG4gICAgICAgICAgICAgIDogZS5pc0VuZFxuICAgICAgICAgICAgICA/IGUucGFyYW1zLmF1dG9wbGF5LnN0b3BPbkxhc3RTbGlkZVxuICAgICAgICAgICAgICAgID8gZS5hdXRvcGxheS5zdG9wKClcbiAgICAgICAgICAgICAgICA6ICgodCA9IGUuc2xpZGVUbygwLCBlLnBhcmFtcy5zcGVlZCwgITAsICEwKSksXG4gICAgICAgICAgICAgICAgICBlLmVtaXQoXCJhdXRvcGxheVwiKSlcbiAgICAgICAgICAgICAgOiAoKHQgPSBlLnNsaWRlTmV4dChlLnBhcmFtcy5zcGVlZCwgITAsICEwKSksIGUuZW1pdChcImF1dG9wbGF5XCIpKSxcbiAgICAgICAgICAgICAgKChlLnBhcmFtcy5jc3NNb2RlICYmIGUuYXV0b3BsYXkucnVubmluZykgfHwgITEgPT09IHQpICYmXG4gICAgICAgICAgICAgICAgZS5hdXRvcGxheS5ydW4oKTtcbiAgICAgICAgICB9LCBhKSk7XG4gICAgICB9LFxuICAgICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHZvaWQgMCA9PT0gZS5hdXRvcGxheS50aW1lb3V0ICYmXG4gICAgICAgICAgIWUuYXV0b3BsYXkucnVubmluZyAmJlxuICAgICAgICAgICgoZS5hdXRvcGxheS5ydW5uaW5nID0gITApLFxuICAgICAgICAgIGUuZW1pdChcImF1dG9wbGF5U3RhcnRcIiksXG4gICAgICAgICAgZS5hdXRvcGxheS5ydW4oKSxcbiAgICAgICAgICAhMClcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAhIWUuYXV0b3BsYXkucnVubmluZyAmJlxuICAgICAgICAgIHZvaWQgMCAhPT0gZS5hdXRvcGxheS50aW1lb3V0ICYmXG4gICAgICAgICAgKGUuYXV0b3BsYXkudGltZW91dCAmJlxuICAgICAgICAgICAgKGNsZWFyVGltZW91dChlLmF1dG9wbGF5LnRpbWVvdXQpLCAoZS5hdXRvcGxheS50aW1lb3V0ID0gdm9pZCAwKSksXG4gICAgICAgICAgKGUuYXV0b3BsYXkucnVubmluZyA9ICExKSxcbiAgICAgICAgICBlLmVtaXQoXCJhdXRvcGxheVN0b3BcIiksXG4gICAgICAgICAgITApXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgcGF1c2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgICAgdC5hdXRvcGxheS5ydW5uaW5nICYmXG4gICAgICAgICAgKHQuYXV0b3BsYXkucGF1c2VkIHx8XG4gICAgICAgICAgICAodC5hdXRvcGxheS50aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0LmF1dG9wbGF5LnRpbWVvdXQpLFxuICAgICAgICAgICAgKHQuYXV0b3BsYXkucGF1c2VkID0gITApLFxuICAgICAgICAgICAgMCAhPT0gZSAmJiB0LnBhcmFtcy5hdXRvcGxheS53YWl0Rm9yVHJhbnNpdGlvblxuICAgICAgICAgICAgICA/ICh0LiR3cmFwcGVyRWxbMF0uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAgIFwidHJhbnNpdGlvbmVuZFwiLFxuICAgICAgICAgICAgICAgICAgdC5hdXRvcGxheS5vblRyYW5zaXRpb25FbmRcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHQuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICAgICAgXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsXG4gICAgICAgICAgICAgICAgICB0LmF1dG9wbGF5Lm9uVHJhbnNpdGlvbkVuZFxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgIDogKCh0LmF1dG9wbGF5LnBhdXNlZCA9ICExKSwgdC5hdXRvcGxheS5ydW4oKSkpKTtcbiAgICAgIH0sXG4gICAgICBvblZpc2liaWxpdHlDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgIHQgPSByKCk7XG4gICAgICAgIFwiaGlkZGVuXCIgPT09IHQudmlzaWJpbGl0eVN0YXRlICYmXG4gICAgICAgICAgZS5hdXRvcGxheS5ydW5uaW5nICYmXG4gICAgICAgICAgZS5hdXRvcGxheS5wYXVzZSgpLFxuICAgICAgICAgIFwidmlzaWJsZVwiID09PSB0LnZpc2liaWxpdHlTdGF0ZSAmJlxuICAgICAgICAgICAgZS5hdXRvcGxheS5wYXVzZWQgJiZcbiAgICAgICAgICAgIChlLmF1dG9wbGF5LnJ1bigpLCAoZS5hdXRvcGxheS5wYXVzZWQgPSAhMSkpO1xuICAgICAgfSxcbiAgICAgIG9uVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICB0ICYmXG4gICAgICAgICAgIXQuZGVzdHJveWVkICYmXG4gICAgICAgICAgdC4kd3JhcHBlckVsICYmXG4gICAgICAgICAgZS50YXJnZXQgPT09IHQuJHdyYXBwZXJFbFswXSAmJlxuICAgICAgICAgICh0LiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwidHJhbnNpdGlvbmVuZFwiLFxuICAgICAgICAgICAgdC5hdXRvcGxheS5vblRyYW5zaXRpb25FbmRcbiAgICAgICAgICApLFxuICAgICAgICAgIHQuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsXG4gICAgICAgICAgICB0LmF1dG9wbGF5Lm9uVHJhbnNpdGlvbkVuZFxuICAgICAgICAgICksXG4gICAgICAgICAgKHQuYXV0b3BsYXkucGF1c2VkID0gITEpLFxuICAgICAgICAgIHQuYXV0b3BsYXkucnVubmluZyA/IHQuYXV0b3BsYXkucnVuKCkgOiB0LmF1dG9wbGF5LnN0b3AoKSk7XG4gICAgICB9LFxuICAgIH0sXG4gICAgbGUgPSB7XG4gICAgICBzZXRUcmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMsIHQgPSBlLnNsaWRlcywgYSA9IDA7IGEgPCB0Lmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgICAgdmFyIGkgPSBlLnNsaWRlcy5lcShhKSxcbiAgICAgICAgICAgIHMgPSAtaVswXS5zd2lwZXJTbGlkZU9mZnNldDtcbiAgICAgICAgICBlLnBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlIHx8IChzIC09IGUudHJhbnNsYXRlKTtcbiAgICAgICAgICB2YXIgciA9IDA7XG4gICAgICAgICAgZS5pc0hvcml6b250YWwoKSB8fCAoKHIgPSBzKSwgKHMgPSAwKSk7XG4gICAgICAgICAgdmFyIG4gPSBlLnBhcmFtcy5mYWRlRWZmZWN0LmNyb3NzRmFkZVxuICAgICAgICAgICAgPyBNYXRoLm1heCgxIC0gTWF0aC5hYnMoaVswXS5wcm9ncmVzcyksIDApXG4gICAgICAgICAgICA6IDEgKyBNYXRoLm1pbihNYXRoLm1heChpWzBdLnByb2dyZXNzLCAtMSksIDApO1xuICAgICAgICAgIGkuY3NzKHsgb3BhY2l0eTogbiB9KS50cmFuc2Zvcm0oXG4gICAgICAgICAgICBcInRyYW5zbGF0ZTNkKFwiICsgcyArIFwicHgsIFwiICsgciArIFwicHgsIDBweClcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRUcmFuc2l0aW9uOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgYSA9IHQuc2xpZGVzLFxuICAgICAgICAgIGkgPSB0LiR3cmFwcGVyRWw7XG4gICAgICAgIGlmICgoYS50cmFuc2l0aW9uKGUpLCB0LnBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlICYmIDAgIT09IGUpKSB7XG4gICAgICAgICAgdmFyIHMgPSAhMTtcbiAgICAgICAgICBhLnRyYW5zaXRpb25FbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFzICYmIHQgJiYgIXQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgIChzID0gITApLCAodC5hbmltYXRpbmcgPSAhMSk7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBbXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsIFwidHJhbnNpdGlvbmVuZFwiXSwgYSA9IDA7XG4gICAgICAgICAgICAgICAgYSA8IGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGEgKz0gMVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgaS50cmlnZ2VyKGVbYV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0sXG4gICAgb2UgPSB7XG4gICAgICBzZXRUcmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUsXG4gICAgICAgICAgdCA9IHRoaXMsXG4gICAgICAgICAgYSA9IHQuJGVsLFxuICAgICAgICAgIGkgPSB0LiR3cmFwcGVyRWwsXG4gICAgICAgICAgcyA9IHQuc2xpZGVzLFxuICAgICAgICAgIHIgPSB0LndpZHRoLFxuICAgICAgICAgIG4gPSB0LmhlaWdodCxcbiAgICAgICAgICBsID0gdC5ydGxUcmFuc2xhdGUsXG4gICAgICAgICAgbyA9IHQuc2l6ZSxcbiAgICAgICAgICBkID0gdC5icm93c2VyLFxuICAgICAgICAgIHAgPSB0LnBhcmFtcy5jdWJlRWZmZWN0LFxuICAgICAgICAgIHUgPSB0LmlzSG9yaXpvbnRhbCgpLFxuICAgICAgICAgIGMgPSB0LnZpcnR1YWwgJiYgdC5wYXJhbXMudmlydHVhbC5lbmFibGVkLFxuICAgICAgICAgIGggPSAwO1xuICAgICAgICBwLnNoYWRvdyAmJlxuICAgICAgICAgICh1XG4gICAgICAgICAgICA/ICgwID09PSAoZSA9IGkuZmluZChcIi5zd2lwZXItY3ViZS1zaGFkb3dcIikpLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICgoZSA9IG0oJzxkaXYgY2xhc3M9XCJzd2lwZXItY3ViZS1zaGFkb3dcIj48L2Rpdj4nKSksXG4gICAgICAgICAgICAgICAgaS5hcHBlbmQoZSkpLFxuICAgICAgICAgICAgICBlLmNzcyh7IGhlaWdodDogciArIFwicHhcIiB9KSlcbiAgICAgICAgICAgIDogMCA9PT0gKGUgPSBhLmZpbmQoXCIuc3dpcGVyLWN1YmUtc2hhZG93XCIpKS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgKChlID0gbSgnPGRpdiBjbGFzcz1cInN3aXBlci1jdWJlLXNoYWRvd1wiPjwvZGl2PicpKSwgYS5hcHBlbmQoZSkpKTtcbiAgICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBzLmxlbmd0aDsgdiArPSAxKSB7XG4gICAgICAgICAgdmFyIGYgPSBzLmVxKHYpLFxuICAgICAgICAgICAgZyA9IHY7XG4gICAgICAgICAgYyAmJiAoZyA9IHBhcnNlSW50KGYuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpLCAxMCkpO1xuICAgICAgICAgIHZhciB5ID0gOTAgKiBnLFxuICAgICAgICAgICAgdyA9IE1hdGguZmxvb3IoeSAvIDM2MCk7XG4gICAgICAgICAgbCAmJiAoKHkgPSAteSksICh3ID0gTWF0aC5mbG9vcigteSAvIDM2MCkpKTtcbiAgICAgICAgICB2YXIgYiA9IE1hdGgubWF4KE1hdGgubWluKGZbMF0ucHJvZ3Jlc3MsIDEpLCAtMSksXG4gICAgICAgICAgICBFID0gMCxcbiAgICAgICAgICAgIHggPSAwLFxuICAgICAgICAgICAgVCA9IDA7XG4gICAgICAgICAgZyAlIDQgPT0gMFxuICAgICAgICAgICAgPyAoKEUgPSA0ICogLXcgKiBvKSwgKFQgPSAwKSlcbiAgICAgICAgICAgIDogKGcgLSAxKSAlIDQgPT0gMFxuICAgICAgICAgICAgPyAoKEUgPSAwKSwgKFQgPSA0ICogLXcgKiBvKSlcbiAgICAgICAgICAgIDogKGcgLSAyKSAlIDQgPT0gMFxuICAgICAgICAgICAgPyAoKEUgPSBvICsgNCAqIHcgKiBvKSwgKFQgPSBvKSlcbiAgICAgICAgICAgIDogKGcgLSAzKSAlIDQgPT0gMCAmJiAoKEUgPSAtbyksIChUID0gMyAqIG8gKyA0ICogbyAqIHcpKSxcbiAgICAgICAgICAgIGwgJiYgKEUgPSAtRSksXG4gICAgICAgICAgICB1IHx8ICgoeCA9IEUpLCAoRSA9IDApKTtcbiAgICAgICAgICB2YXIgQyA9XG4gICAgICAgICAgICBcInJvdGF0ZVgoXCIgK1xuICAgICAgICAgICAgKHUgPyAwIDogLXkpICtcbiAgICAgICAgICAgIFwiZGVnKSByb3RhdGVZKFwiICtcbiAgICAgICAgICAgICh1ID8geSA6IDApICtcbiAgICAgICAgICAgIFwiZGVnKSB0cmFuc2xhdGUzZChcIiArXG4gICAgICAgICAgICBFICtcbiAgICAgICAgICAgIFwicHgsIFwiICtcbiAgICAgICAgICAgIHggK1xuICAgICAgICAgICAgXCJweCwgXCIgK1xuICAgICAgICAgICAgVCArXG4gICAgICAgICAgICBcInB4KVwiO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChiIDw9IDEgJiZcbiAgICAgICAgICAgICAgYiA+IC0xICYmXG4gICAgICAgICAgICAgICgoaCA9IDkwICogZyArIDkwICogYiksIGwgJiYgKGggPSA5MCAqIC1nIC0gOTAgKiBiKSksXG4gICAgICAgICAgICBmLnRyYW5zZm9ybShDKSxcbiAgICAgICAgICAgIHAuc2xpZGVTaGFkb3dzKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIFMgPSB1XG4gICAgICAgICAgICAgICAgPyBmLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0XCIpXG4gICAgICAgICAgICAgICAgOiBmLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3BcIiksXG4gICAgICAgICAgICAgIE0gPSB1XG4gICAgICAgICAgICAgICAgPyBmLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodFwiKVxuICAgICAgICAgICAgICAgIDogZi5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tXCIpO1xuICAgICAgICAgICAgMCA9PT0gUy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgKChTID0gbShcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInN3aXBlci1zbGlkZS1zaGFkb3ctJyArXG4gICAgICAgICAgICAgICAgICAodSA/IFwibGVmdFwiIDogXCJ0b3BcIikgK1xuICAgICAgICAgICAgICAgICAgJ1wiPjwvZGl2PidcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGYuYXBwZW5kKFMpKSxcbiAgICAgICAgICAgICAgMCA9PT0gTS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAoKE0gPSBtKFxuICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LScgK1xuICAgICAgICAgICAgICAgICAgICAodSA/IFwicmlnaHRcIiA6IFwiYm90dG9tXCIpICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiPjwvZGl2PidcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBmLmFwcGVuZChNKSksXG4gICAgICAgICAgICAgIFMubGVuZ3RoICYmIChTWzBdLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1heCgtYiwgMCkpLFxuICAgICAgICAgICAgICBNLmxlbmd0aCAmJiAoTVswXS5zdHlsZS5vcGFjaXR5ID0gTWF0aC5tYXgoYiwgMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKGkuY3NzKHtcbiAgICAgICAgICAgIFwiLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luXCI6IFwiNTAlIDUwJSAtXCIgKyBvIC8gMiArIFwicHhcIixcbiAgICAgICAgICAgIFwiLW1vei10cmFuc2Zvcm0tb3JpZ2luXCI6IFwiNTAlIDUwJSAtXCIgKyBvIC8gMiArIFwicHhcIixcbiAgICAgICAgICAgIFwiLW1zLXRyYW5zZm9ybS1vcmlnaW5cIjogXCI1MCUgNTAlIC1cIiArIG8gLyAyICsgXCJweFwiLFxuICAgICAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IFwiNTAlIDUwJSAtXCIgKyBvIC8gMiArIFwicHhcIixcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBwLnNoYWRvdylcbiAgICAgICAgKVxuICAgICAgICAgIGlmICh1KVxuICAgICAgICAgICAgZS50cmFuc2Zvcm0oXG4gICAgICAgICAgICAgIFwidHJhbnNsYXRlM2QoMHB4LCBcIiArXG4gICAgICAgICAgICAgICAgKHIgLyAyICsgcC5zaGFkb3dPZmZzZXQpICtcbiAgICAgICAgICAgICAgICBcInB4LCBcIiArXG4gICAgICAgICAgICAgICAgLXIgLyAyICtcbiAgICAgICAgICAgICAgICBcInB4KSByb3RhdGVYKDkwZGVnKSByb3RhdGVaKDBkZWcpIHNjYWxlKFwiICtcbiAgICAgICAgICAgICAgICBwLnNoYWRvd1NjYWxlICtcbiAgICAgICAgICAgICAgICBcIilcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5hYnMoaCkgLSA5MCAqIE1hdGguZmxvb3IoTWF0aC5hYnMoaCkgLyA5MCksXG4gICAgICAgICAgICAgIFAgPVxuICAgICAgICAgICAgICAgIDEuNSAtXG4gICAgICAgICAgICAgICAgKE1hdGguc2luKCgyICogeiAqIE1hdGguUEkpIC8gMzYwKSAvIDIgK1xuICAgICAgICAgICAgICAgICAgTWF0aC5jb3MoKDIgKiB6ICogTWF0aC5QSSkgLyAzNjApIC8gMiksXG4gICAgICAgICAgICAgIGsgPSBwLnNoYWRvd1NjYWxlLFxuICAgICAgICAgICAgICBMID0gcC5zaGFkb3dTY2FsZSAvIFAsXG4gICAgICAgICAgICAgICQgPSBwLnNoYWRvd09mZnNldDtcbiAgICAgICAgICAgIGUudHJhbnNmb3JtKFxuICAgICAgICAgICAgICBcInNjYWxlM2QoXCIgK1xuICAgICAgICAgICAgICAgIGsgK1xuICAgICAgICAgICAgICAgIFwiLCAxLCBcIiArXG4gICAgICAgICAgICAgICAgTCArXG4gICAgICAgICAgICAgICAgXCIpIHRyYW5zbGF0ZTNkKDBweCwgXCIgK1xuICAgICAgICAgICAgICAgIChuIC8gMiArICQpICtcbiAgICAgICAgICAgICAgICBcInB4LCBcIiArXG4gICAgICAgICAgICAgICAgLW4gLyAyIC8gTCArXG4gICAgICAgICAgICAgICAgXCJweCkgcm90YXRlWCgtOTBkZWcpXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB2YXIgSSA9IGQuaXNTYWZhcmkgfHwgZC5pc1dlYlZpZXcgPyAtbyAvIDIgOiAwO1xuICAgICAgICBpLnRyYW5zZm9ybShcbiAgICAgICAgICBcInRyYW5zbGF0ZTNkKDBweCwwLFwiICtcbiAgICAgICAgICAgIEkgK1xuICAgICAgICAgICAgXCJweCkgcm90YXRlWChcIiArXG4gICAgICAgICAgICAodC5pc0hvcml6b250YWwoKSA/IDAgOiBoKSArXG4gICAgICAgICAgICBcImRlZykgcm90YXRlWShcIiArXG4gICAgICAgICAgICAodC5pc0hvcml6b250YWwoKSA/IC1oIDogMCkgK1xuICAgICAgICAgICAgXCJkZWcpXCJcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBzZXRUcmFuc2l0aW9uOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgYSA9IHQuJGVsO1xuICAgICAgICB0LnNsaWRlc1xuICAgICAgICAgIC50cmFuc2l0aW9uKGUpXG4gICAgICAgICAgLmZpbmQoXG4gICAgICAgICAgICBcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwgLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiXG4gICAgICAgICAgKVxuICAgICAgICAgIC50cmFuc2l0aW9uKGUpLFxuICAgICAgICAgIHQucGFyYW1zLmN1YmVFZmZlY3Quc2hhZG93ICYmXG4gICAgICAgICAgICAhdC5pc0hvcml6b250YWwoKSAmJlxuICAgICAgICAgICAgYS5maW5kKFwiLnN3aXBlci1jdWJlLXNoYWRvd1wiKS50cmFuc2l0aW9uKGUpO1xuICAgICAgfSxcbiAgICB9LFxuICAgIGRlID0ge1xuICAgICAgc2V0VHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGUgPSB0aGlzLCB0ID0gZS5zbGlkZXMsIGEgPSBlLnJ0bFRyYW5zbGF0ZSwgaSA9IDA7XG4gICAgICAgICAgaSA8IHQubGVuZ3RoO1xuICAgICAgICAgIGkgKz0gMVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgcyA9IHQuZXEoaSksXG4gICAgICAgICAgICByID0gc1swXS5wcm9ncmVzcztcbiAgICAgICAgICBlLnBhcmFtcy5mbGlwRWZmZWN0LmxpbWl0Um90YXRpb24gJiZcbiAgICAgICAgICAgIChyID0gTWF0aC5tYXgoTWF0aC5taW4oc1swXS5wcm9ncmVzcywgMSksIC0xKSk7XG4gICAgICAgICAgdmFyIG4gPSAtMTgwICogcixcbiAgICAgICAgICAgIGwgPSAwLFxuICAgICAgICAgICAgbyA9IC1zWzBdLnN3aXBlclNsaWRlT2Zmc2V0LFxuICAgICAgICAgICAgZCA9IDA7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGUuaXNIb3Jpem9udGFsKClcbiAgICAgICAgICAgICAgPyBhICYmIChuID0gLW4pXG4gICAgICAgICAgICAgIDogKChkID0gbyksIChvID0gMCksIChsID0gLW4pLCAobiA9IDApKSxcbiAgICAgICAgICAgIChzWzBdLnN0eWxlLnpJbmRleCA9IC1NYXRoLmFicyhNYXRoLnJvdW5kKHIpKSArIHQubGVuZ3RoKSxcbiAgICAgICAgICAgIGUucGFyYW1zLmZsaXBFZmZlY3Quc2xpZGVTaGFkb3dzKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHAgPSBlLmlzSG9yaXpvbnRhbCgpXG4gICAgICAgICAgICAgICAgPyBzLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0XCIpXG4gICAgICAgICAgICAgICAgOiBzLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3BcIiksXG4gICAgICAgICAgICAgIHUgPSBlLmlzSG9yaXpvbnRhbCgpXG4gICAgICAgICAgICAgICAgPyBzLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodFwiKVxuICAgICAgICAgICAgICAgIDogcy5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tXCIpO1xuICAgICAgICAgICAgMCA9PT0gcC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgKChwID0gbShcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInN3aXBlci1zbGlkZS1zaGFkb3ctJyArXG4gICAgICAgICAgICAgICAgICAoZS5pc0hvcml6b250YWwoKSA/IFwibGVmdFwiIDogXCJ0b3BcIikgK1xuICAgICAgICAgICAgICAgICAgJ1wiPjwvZGl2PidcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIHMuYXBwZW5kKHApKSxcbiAgICAgICAgICAgICAgMCA9PT0gdS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAoKHUgPSBtKFxuICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LScgK1xuICAgICAgICAgICAgICAgICAgICAoZS5pc0hvcml6b250YWwoKSA/IFwicmlnaHRcIiA6IFwiYm90dG9tXCIpICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiPjwvZGl2PidcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBzLmFwcGVuZCh1KSksXG4gICAgICAgICAgICAgIHAubGVuZ3RoICYmIChwWzBdLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1heCgtciwgMCkpLFxuICAgICAgICAgICAgICB1Lmxlbmd0aCAmJiAodVswXS5zdHlsZS5vcGFjaXR5ID0gTWF0aC5tYXgociwgMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzLnRyYW5zZm9ybShcbiAgICAgICAgICAgIFwidHJhbnNsYXRlM2QoXCIgK1xuICAgICAgICAgICAgICBvICtcbiAgICAgICAgICAgICAgXCJweCwgXCIgK1xuICAgICAgICAgICAgICBkICtcbiAgICAgICAgICAgICAgXCJweCwgMHB4KSByb3RhdGVYKFwiICtcbiAgICAgICAgICAgICAgbCArXG4gICAgICAgICAgICAgIFwiZGVnKSByb3RhdGVZKFwiICtcbiAgICAgICAgICAgICAgbiArXG4gICAgICAgICAgICAgIFwiZGVnKVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcyxcbiAgICAgICAgICBhID0gdC5zbGlkZXMsXG4gICAgICAgICAgaSA9IHQuYWN0aXZlSW5kZXgsXG4gICAgICAgICAgcyA9IHQuJHdyYXBwZXJFbDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChhXG4gICAgICAgICAgICAudHJhbnNpdGlvbihlKVxuICAgICAgICAgICAgLmZpbmQoXG4gICAgICAgICAgICAgIFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0XCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKGUpLFxuICAgICAgICAgIHQucGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUgJiYgMCAhPT0gZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIHIgPSAhMTtcbiAgICAgICAgICBhLmVxKGkpLnRyYW5zaXRpb25FbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFyICYmIHQgJiYgIXQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgIChyID0gITApLCAodC5hbmltYXRpbmcgPSAhMSk7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBbXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsIFwidHJhbnNpdGlvbmVuZFwiXSwgYSA9IDA7XG4gICAgICAgICAgICAgICAgYSA8IGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGEgKz0gMVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgcy50cmlnZ2VyKGVbYV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0sXG4gICAgcGUgPSB7XG4gICAgICBzZXRUcmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgICB0ID0gZS53aWR0aCxcbiAgICAgICAgICAgIGEgPSBlLmhlaWdodCxcbiAgICAgICAgICAgIGkgPSBlLnNsaWRlcyxcbiAgICAgICAgICAgIHMgPSBlLnNsaWRlc1NpemVzR3JpZCxcbiAgICAgICAgICAgIHIgPSBlLnBhcmFtcy5jb3ZlcmZsb3dFZmZlY3QsXG4gICAgICAgICAgICBuID0gZS5pc0hvcml6b250YWwoKSxcbiAgICAgICAgICAgIGwgPSBlLnRyYW5zbGF0ZSxcbiAgICAgICAgICAgIG8gPSBuID8gdCAvIDIgLSBsIDogYSAvIDIgLSBsLFxuICAgICAgICAgICAgZCA9IG4gPyByLnJvdGF0ZSA6IC1yLnJvdGF0ZSxcbiAgICAgICAgICAgIHAgPSByLmRlcHRoLFxuICAgICAgICAgICAgdSA9IDAsXG4gICAgICAgICAgICBjID0gaS5sZW5ndGg7XG4gICAgICAgICAgdSA8IGM7XG4gICAgICAgICAgdSArPSAxXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBoID0gaS5lcSh1KSxcbiAgICAgICAgICAgIHYgPSBzW3VdLFxuICAgICAgICAgICAgZiA9ICgobyAtIGhbMF0uc3dpcGVyU2xpZGVPZmZzZXQgLSB2IC8gMikgLyB2KSAqIHIubW9kaWZpZXIsXG4gICAgICAgICAgICBnID0gbiA/IGQgKiBmIDogMCxcbiAgICAgICAgICAgIHkgPSBuID8gMCA6IGQgKiBmLFxuICAgICAgICAgICAgdyA9IC1wICogTWF0aC5hYnMoZiksXG4gICAgICAgICAgICBiID0gci5zdHJldGNoO1xuICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIGIgJiZcbiAgICAgICAgICAgIC0xICE9PSBiLmluZGV4T2YoXCIlXCIpICYmXG4gICAgICAgICAgICAoYiA9IChwYXJzZUZsb2F0KHIuc3RyZXRjaCkgLyAxMDApICogdik7XG4gICAgICAgICAgdmFyIEUgPSBuID8gMCA6IGIgKiBmLFxuICAgICAgICAgICAgeCA9IG4gPyBiICogZiA6IDAsXG4gICAgICAgICAgICBUID0gMSAtICgxIC0gci5zY2FsZSkgKiBNYXRoLmFicyhmKTtcbiAgICAgICAgICBNYXRoLmFicyh4KSA8IDAuMDAxICYmICh4ID0gMCksXG4gICAgICAgICAgICBNYXRoLmFicyhFKSA8IDAuMDAxICYmIChFID0gMCksXG4gICAgICAgICAgICBNYXRoLmFicyh3KSA8IDAuMDAxICYmICh3ID0gMCksXG4gICAgICAgICAgICBNYXRoLmFicyhnKSA8IDAuMDAxICYmIChnID0gMCksXG4gICAgICAgICAgICBNYXRoLmFicyh5KSA8IDAuMDAxICYmICh5ID0gMCksXG4gICAgICAgICAgICBNYXRoLmFicyhUKSA8IDAuMDAxICYmIChUID0gMCk7XG4gICAgICAgICAgdmFyIEMgPVxuICAgICAgICAgICAgXCJ0cmFuc2xhdGUzZChcIiArXG4gICAgICAgICAgICB4ICtcbiAgICAgICAgICAgIFwicHgsXCIgK1xuICAgICAgICAgICAgRSArXG4gICAgICAgICAgICBcInB4LFwiICtcbiAgICAgICAgICAgIHcgK1xuICAgICAgICAgICAgXCJweCkgIHJvdGF0ZVgoXCIgK1xuICAgICAgICAgICAgeSArXG4gICAgICAgICAgICBcImRlZykgcm90YXRlWShcIiArXG4gICAgICAgICAgICBnICtcbiAgICAgICAgICAgIFwiZGVnKSBzY2FsZShcIiArXG4gICAgICAgICAgICBUICtcbiAgICAgICAgICAgIFwiKVwiO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChoLnRyYW5zZm9ybShDKSxcbiAgICAgICAgICAgIChoWzBdLnN0eWxlLnpJbmRleCA9IDEgLSBNYXRoLmFicyhNYXRoLnJvdW5kKGYpKSksXG4gICAgICAgICAgICByLnNsaWRlU2hhZG93cylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBTID0gblxuICAgICAgICAgICAgICAgID8gaC5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKVxuICAgICAgICAgICAgICAgIDogaC5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wXCIpLFxuICAgICAgICAgICAgICBNID0gblxuICAgICAgICAgICAgICAgID8gaC5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHRcIilcbiAgICAgICAgICAgICAgICA6IGguZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbVwiKTtcbiAgICAgICAgICAgIDAgPT09IFMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICgoUyA9IG0oXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LScgK1xuICAgICAgICAgICAgICAgICAgKG4gPyBcImxlZnRcIiA6IFwidG9wXCIpICtcbiAgICAgICAgICAgICAgICAgICdcIj48L2Rpdj4nXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBoLmFwcGVuZChTKSksXG4gICAgICAgICAgICAgIDAgPT09IE0ubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgKChNID0gbShcbiAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwic3dpcGVyLXNsaWRlLXNoYWRvdy0nICtcbiAgICAgICAgICAgICAgICAgICAgKG4gPyBcInJpZ2h0XCIgOiBcImJvdHRvbVwiKSArXG4gICAgICAgICAgICAgICAgICAgICdcIj48L2Rpdj4nXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgaC5hcHBlbmQoTSkpLFxuICAgICAgICAgICAgICBTLmxlbmd0aCAmJiAoU1swXS5zdHlsZS5vcGFjaXR5ID0gZiA+IDAgPyBmIDogMCksXG4gICAgICAgICAgICAgIE0ubGVuZ3RoICYmIChNWzBdLnN0eWxlLm9wYWNpdHkgPSAtZiA+IDAgPyAtZiA6IDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuc2xpZGVzXG4gICAgICAgICAgLnRyYW5zaXRpb24oZSlcbiAgICAgICAgICAuZmluZChcbiAgICAgICAgICAgIFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0XCJcbiAgICAgICAgICApXG4gICAgICAgICAgLnRyYW5zaXRpb24oZSk7XG4gICAgICB9LFxuICAgIH0sXG4gICAgdWUgPSB7XG4gICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICB0ID0gZS5wYXJhbXMudGh1bWJzO1xuICAgICAgICBpZiAoZS50aHVtYnMuaW5pdGlhbGl6ZWQpIHJldHVybiAhMTtcbiAgICAgICAgZS50aHVtYnMuaW5pdGlhbGl6ZWQgPSAhMDtcbiAgICAgICAgdmFyIGEgPSBlLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHQuc3dpcGVyIGluc3RhbmNlb2YgYVxuICAgICAgICAgICAgPyAoKGUudGh1bWJzLnN3aXBlciA9IHQuc3dpcGVyKSxcbiAgICAgICAgICAgICAgUyhlLnRodW1icy5zd2lwZXIub3JpZ2luYWxQYXJhbXMsIHtcbiAgICAgICAgICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiAhMCxcbiAgICAgICAgICAgICAgICBzbGlkZVRvQ2xpY2tlZFNsaWRlOiAhMSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIFMoZS50aHVtYnMuc3dpcGVyLnBhcmFtcywge1xuICAgICAgICAgICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6ICEwLFxuICAgICAgICAgICAgICAgIHNsaWRlVG9DbGlja2VkU2xpZGU6ICExLFxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIDogQyh0LnN3aXBlcikgJiZcbiAgICAgICAgICAgICAgKChlLnRodW1icy5zd2lwZXIgPSBuZXcgYShcbiAgICAgICAgICAgICAgICBTKHt9LCB0LnN3aXBlciwge1xuICAgICAgICAgICAgICAgICAgd2F0Y2hTbGlkZXNWaXNpYmlsaXR5OiAhMCxcbiAgICAgICAgICAgICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6ICEwLFxuICAgICAgICAgICAgICAgICAgc2xpZGVUb0NsaWNrZWRTbGlkZTogITEsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChlLnRodW1icy5zd2lwZXJDcmVhdGVkID0gITApKSxcbiAgICAgICAgICBlLnRodW1icy5zd2lwZXIuJGVsLmFkZENsYXNzKGUucGFyYW1zLnRodW1icy50aHVtYnNDb250YWluZXJDbGFzcyksXG4gICAgICAgICAgZS50aHVtYnMuc3dpcGVyLm9uKFwidGFwXCIsIGUudGh1bWJzLm9uVGh1bWJDbGljayksXG4gICAgICAgICAgITBcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBvblRodW1iQ2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgIHQgPSBlLnRodW1icy5zd2lwZXI7XG4gICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgdmFyIGEgPSB0LmNsaWNrZWRJbmRleCxcbiAgICAgICAgICAgIGkgPSB0LmNsaWNrZWRTbGlkZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAoaSAmJiBtKGkpLmhhc0NsYXNzKGUucGFyYW1zLnRodW1icy5zbGlkZVRodW1iQWN0aXZlQ2xhc3MpKSB8fFxuICAgICAgICAgICAgICBudWxsID09IGFcbiAgICAgICAgICAgIClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBzO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKHMgPSB0LnBhcmFtcy5sb29wXG4gICAgICAgICAgICAgICAgPyBwYXJzZUludChcbiAgICAgICAgICAgICAgICAgICAgbSh0LmNsaWNrZWRTbGlkZSkuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpLFxuICAgICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogYSksXG4gICAgICAgICAgICAgIGUucGFyYW1zLmxvb3ApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIHIgPSBlLmFjdGl2ZUluZGV4O1xuICAgICAgICAgICAgICBlLnNsaWRlcy5lcShyKS5oYXNDbGFzcyhlLnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSAmJlxuICAgICAgICAgICAgICAgIChlLmxvb3BGaXgoKSxcbiAgICAgICAgICAgICAgICAoZS5fY2xpZW50TGVmdCA9IGUuJHdyYXBwZXJFbFswXS5jbGllbnRMZWZ0KSxcbiAgICAgICAgICAgICAgICAociA9IGUuYWN0aXZlSW5kZXgpKTtcbiAgICAgICAgICAgICAgdmFyIG4gPSBlLnNsaWRlc1xuICAgICAgICAgICAgICAgICAgLmVxKHIpXG4gICAgICAgICAgICAgICAgICAucHJldkFsbCgnW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJyArIHMgKyAnXCJdJylcbiAgICAgICAgICAgICAgICAgIC5lcSgwKVxuICAgICAgICAgICAgICAgICAgLmluZGV4KCksXG4gICAgICAgICAgICAgICAgbCA9IGUuc2xpZGVzXG4gICAgICAgICAgICAgICAgICAuZXEocilcbiAgICAgICAgICAgICAgICAgIC5uZXh0QWxsKCdbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInICsgcyArICdcIl0nKVxuICAgICAgICAgICAgICAgICAgLmVxKDApXG4gICAgICAgICAgICAgICAgICAuaW5kZXgoKTtcbiAgICAgICAgICAgICAgcyA9IHZvaWQgMCA9PT0gbiA/IGwgOiB2b2lkIDAgPT09IGwgPyBuIDogbCAtIHIgPCByIC0gbiA/IGwgOiBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5zbGlkZVRvKHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLFxuICAgICAgICAgIGEgPSB0LnRodW1icy5zd2lwZXI7XG4gICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgdmFyIGkgPVxuICAgICAgICAgICAgICBcImF1dG9cIiA9PT0gYS5wYXJhbXMuc2xpZGVzUGVyVmlld1xuICAgICAgICAgICAgICAgID8gYS5zbGlkZXNQZXJWaWV3RHluYW1pYygpXG4gICAgICAgICAgICAgICAgOiBhLnBhcmFtcy5zbGlkZXNQZXJWaWV3LFxuICAgICAgICAgICAgcyA9IHQucGFyYW1zLnRodW1icy5hdXRvU2Nyb2xsT2Zmc2V0LFxuICAgICAgICAgICAgciA9IHMgJiYgIWEucGFyYW1zLmxvb3A7XG4gICAgICAgICAgaWYgKHQucmVhbEluZGV4ICE9PSBhLnJlYWxJbmRleCB8fCByKSB7XG4gICAgICAgICAgICB2YXIgbixcbiAgICAgICAgICAgICAgbCxcbiAgICAgICAgICAgICAgbyA9IGEuYWN0aXZlSW5kZXg7XG4gICAgICAgICAgICBpZiAoYS5wYXJhbXMubG9vcCkge1xuICAgICAgICAgICAgICBhLnNsaWRlcy5lcShvKS5oYXNDbGFzcyhhLnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSAmJlxuICAgICAgICAgICAgICAgIChhLmxvb3BGaXgoKSxcbiAgICAgICAgICAgICAgICAoYS5fY2xpZW50TGVmdCA9IGEuJHdyYXBwZXJFbFswXS5jbGllbnRMZWZ0KSxcbiAgICAgICAgICAgICAgICAobyA9IGEuYWN0aXZlSW5kZXgpKTtcbiAgICAgICAgICAgICAgdmFyIGQgPSBhLnNsaWRlc1xuICAgICAgICAgICAgICAgICAgLmVxKG8pXG4gICAgICAgICAgICAgICAgICAucHJldkFsbCgnW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJyArIHQucmVhbEluZGV4ICsgJ1wiXScpXG4gICAgICAgICAgICAgICAgICAuZXEoMClcbiAgICAgICAgICAgICAgICAgIC5pbmRleCgpLFxuICAgICAgICAgICAgICAgIHAgPSBhLnNsaWRlc1xuICAgICAgICAgICAgICAgICAgLmVxKG8pXG4gICAgICAgICAgICAgICAgICAubmV4dEFsbCgnW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJyArIHQucmVhbEluZGV4ICsgJ1wiXScpXG4gICAgICAgICAgICAgICAgICAuZXEoMClcbiAgICAgICAgICAgICAgICAgIC5pbmRleCgpO1xuICAgICAgICAgICAgICAobiA9XG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBkXG4gICAgICAgICAgICAgICAgICA/IHBcbiAgICAgICAgICAgICAgICAgIDogdm9pZCAwID09PSBwXG4gICAgICAgICAgICAgICAgICA/IGRcbiAgICAgICAgICAgICAgICAgIDogcCAtIG8gPT0gbyAtIGRcbiAgICAgICAgICAgICAgICAgID8gb1xuICAgICAgICAgICAgICAgICAgOiBwIC0gbyA8IG8gLSBkXG4gICAgICAgICAgICAgICAgICA/IHBcbiAgICAgICAgICAgICAgICAgIDogZCksXG4gICAgICAgICAgICAgICAgKGwgPSB0LmFjdGl2ZUluZGV4ID4gdC5wcmV2aW91c0luZGV4ID8gXCJuZXh0XCIgOiBcInByZXZcIik7XG4gICAgICAgICAgICB9IGVsc2UgbCA9IChuID0gdC5yZWFsSW5kZXgpID4gdC5wcmV2aW91c0luZGV4ID8gXCJuZXh0XCIgOiBcInByZXZcIjtcbiAgICAgICAgICAgIHIgJiYgKG4gKz0gXCJuZXh0XCIgPT09IGwgPyBzIDogLTEgKiBzKSxcbiAgICAgICAgICAgICAgYS52aXNpYmxlU2xpZGVzSW5kZXhlcyAmJlxuICAgICAgICAgICAgICAgIGEudmlzaWJsZVNsaWRlc0luZGV4ZXMuaW5kZXhPZihuKSA8IDAgJiZcbiAgICAgICAgICAgICAgICAoYS5wYXJhbXMuY2VudGVyZWRTbGlkZXNcbiAgICAgICAgICAgICAgICAgID8gKG4gPVxuICAgICAgICAgICAgICAgICAgICAgIG4gPiBvXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG4gLSBNYXRoLmZsb29yKGkgLyAyKSArIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbiArIE1hdGguZmxvb3IoaSAvIDIpIC0gMSlcbiAgICAgICAgICAgICAgICAgIDogbiA+IG8gJiYgKG4gPSBuIC0gaSArIDEpLFxuICAgICAgICAgICAgICAgIGEuc2xpZGVUbyhuLCBlID8gMCA6IHZvaWQgMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdSA9IDEsXG4gICAgICAgICAgICBjID0gdC5wYXJhbXMudGh1bWJzLnNsaWRlVGh1bWJBY3RpdmVDbGFzcztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAodC5wYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEgJiZcbiAgICAgICAgICAgICAgIXQucGFyYW1zLmNlbnRlcmVkU2xpZGVzICYmXG4gICAgICAgICAgICAgICh1ID0gdC5wYXJhbXMuc2xpZGVzUGVyVmlldyksXG4gICAgICAgICAgICB0LnBhcmFtcy50aHVtYnMubXVsdGlwbGVBY3RpdmVUaHVtYnMgfHwgKHUgPSAxKSxcbiAgICAgICAgICAgICh1ID0gTWF0aC5mbG9vcih1KSksXG4gICAgICAgICAgICBhLnNsaWRlcy5yZW1vdmVDbGFzcyhjKSxcbiAgICAgICAgICAgIGEucGFyYW1zLmxvb3AgfHwgKGEucGFyYW1zLnZpcnR1YWwgJiYgYS5wYXJhbXMudmlydHVhbC5lbmFibGVkKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IHU7IGggKz0gMSlcbiAgICAgICAgICAgICAgYS4kd3JhcHBlckVsXG4gICAgICAgICAgICAgICAgLmNoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgJ1tkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicgKyAodC5yZWFsSW5kZXggKyBoKSArICdcIl0nXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhjKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IHU7IHYgKz0gMSlcbiAgICAgICAgICAgICAgYS5zbGlkZXMuZXEodC5yZWFsSW5kZXggKyB2KS5hZGRDbGFzcyhjKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9LFxuICAgIGNlID0gW1xuICAgICAgcSxcbiAgICAgIF8sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwibW91c2V3aGVlbFwiLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBtb3VzZXdoZWVsOiB7XG4gICAgICAgICAgICBlbmFibGVkOiAhMSxcbiAgICAgICAgICAgIHJlbGVhc2VPbkVkZ2VzOiAhMSxcbiAgICAgICAgICAgIGludmVydDogITEsXG4gICAgICAgICAgICBmb3JjZVRvQXhpczogITEsXG4gICAgICAgICAgICBzZW5zaXRpdml0eTogMSxcbiAgICAgICAgICAgIGV2ZW50c1RhcmdldDogXCJjb250YWluZXJcIixcbiAgICAgICAgICAgIHRocmVzaG9sZERlbHRhOiBudWxsLFxuICAgICAgICAgICAgdGhyZXNob2xkVGltZTogbnVsbCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBNKHRoaXMsIHtcbiAgICAgICAgICAgIG1vdXNld2hlZWw6IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogITEsXG4gICAgICAgICAgICAgIGxhc3RTY3JvbGxUaW1lOiB4KCksXG4gICAgICAgICAgICAgIGxhc3RFdmVudEJlZm9yZVNuYXA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgcmVjZW50V2hlZWxFdmVudHM6IFtdLFxuICAgICAgICAgICAgICBlbmFibGU6IFUuZW5hYmxlLFxuICAgICAgICAgICAgICBkaXNhYmxlOiBVLmRpc2FibGUsXG4gICAgICAgICAgICAgIGhhbmRsZTogVS5oYW5kbGUsXG4gICAgICAgICAgICAgIGhhbmRsZU1vdXNlRW50ZXI6IFUuaGFuZGxlTW91c2VFbnRlcixcbiAgICAgICAgICAgICAgaGFuZGxlTW91c2VMZWF2ZTogVS5oYW5kbGVNb3VzZUxlYXZlLFxuICAgICAgICAgICAgICBhbmltYXRlU2xpZGVyOiBVLmFuaW1hdGVTbGlkZXIsXG4gICAgICAgICAgICAgIHJlbGVhc2VTY3JvbGw6IFUucmVsZWFzZVNjcm9sbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgaW5pdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICFlLnBhcmFtcy5tb3VzZXdoZWVsLmVuYWJsZWQgJiZcbiAgICAgICAgICAgICAgZS5wYXJhbXMuY3NzTW9kZSAmJlxuICAgICAgICAgICAgICBlLm1vdXNld2hlZWwuZGlzYWJsZSgpLFxuICAgICAgICAgICAgICBlLnBhcmFtcy5tb3VzZXdoZWVsLmVuYWJsZWQgJiYgZS5tb3VzZXdoZWVsLmVuYWJsZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucGFyYW1zLmNzc01vZGUgJiYgZS5tb3VzZXdoZWVsLmVuYWJsZSgpLFxuICAgICAgICAgICAgICBlLm1vdXNld2hlZWwuZW5hYmxlZCAmJiBlLm1vdXNld2hlZWwuZGlzYWJsZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIm5hdmlnYXRpb25cIixcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgbmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgbmV4dEVsOiBudWxsLFxuICAgICAgICAgICAgcHJldkVsOiBudWxsLFxuICAgICAgICAgICAgaGlkZU9uQ2xpY2s6ICExLFxuICAgICAgICAgICAgZGlzYWJsZWRDbGFzczogXCJzd2lwZXItYnV0dG9uLWRpc2FibGVkXCIsXG4gICAgICAgICAgICBoaWRkZW5DbGFzczogXCJzd2lwZXItYnV0dG9uLWhpZGRlblwiLFxuICAgICAgICAgICAgbG9ja0NsYXNzOiBcInN3aXBlci1idXR0b24tbG9ja1wiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIE0odGhpcywgeyBuYXZpZ2F0aW9uOiB0KHt9LCBLKSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5uYXZpZ2F0aW9uLmluaXQoKSwgZS5uYXZpZ2F0aW9uLnVwZGF0ZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9FZGdlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5uYXZpZ2F0aW9uLnVwZGF0ZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnJvbUVkZ2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLm5hdmlnYXRpb24udXBkYXRlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5uYXZpZ2F0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgdmFyIGEsXG4gICAgICAgICAgICAgIGkgPSBlLm5hdmlnYXRpb24sXG4gICAgICAgICAgICAgIHMgPSBpLiRuZXh0RWwsXG4gICAgICAgICAgICAgIHIgPSBpLiRwcmV2RWw7XG4gICAgICAgICAgICAhZS5wYXJhbXMubmF2aWdhdGlvbi5oaWRlT25DbGljayB8fFxuICAgICAgICAgICAgICBtKHQudGFyZ2V0KS5pcyhyKSB8fFxuICAgICAgICAgICAgICBtKHQudGFyZ2V0KS5pcyhzKSB8fFxuICAgICAgICAgICAgICAoc1xuICAgICAgICAgICAgICAgID8gKGEgPSBzLmhhc0NsYXNzKGUucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpKVxuICAgICAgICAgICAgICAgIDogciAmJiAoYSA9IHIuaGFzQ2xhc3MoZS5wYXJhbXMubmF2aWdhdGlvbi5oaWRkZW5DbGFzcykpLFxuICAgICAgICAgICAgICAhMCA9PT0gYSA/IGUuZW1pdChcIm5hdmlnYXRpb25TaG93XCIpIDogZS5lbWl0KFwibmF2aWdhdGlvbkhpZGVcIiksXG4gICAgICAgICAgICAgIHMgJiYgcy50b2dnbGVDbGFzcyhlLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKSxcbiAgICAgICAgICAgICAgciAmJiByLnRvZ2dsZUNsYXNzKGUucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJwYWdpbmF0aW9uXCIsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgICAgIGVsOiBudWxsLFxuICAgICAgICAgICAgYnVsbGV0RWxlbWVudDogXCJzcGFuXCIsXG4gICAgICAgICAgICBjbGlja2FibGU6ICExLFxuICAgICAgICAgICAgaGlkZU9uQ2xpY2s6ICExLFxuICAgICAgICAgICAgcmVuZGVyQnVsbGV0OiBudWxsLFxuICAgICAgICAgICAgcmVuZGVyUHJvZ3Jlc3NiYXI6IG51bGwsXG4gICAgICAgICAgICByZW5kZXJGcmFjdGlvbjogbnVsbCxcbiAgICAgICAgICAgIHJlbmRlckN1c3RvbTogbnVsbCxcbiAgICAgICAgICAgIHByb2dyZXNzYmFyT3Bwb3NpdGU6ICExLFxuICAgICAgICAgICAgdHlwZTogXCJidWxsZXRzXCIsXG4gICAgICAgICAgICBkeW5hbWljQnVsbGV0czogITEsXG4gICAgICAgICAgICBkeW5hbWljTWFpbkJ1bGxldHM6IDEsXG4gICAgICAgICAgICBmb3JtYXRGcmFjdGlvbkN1cnJlbnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcm1hdEZyYWN0aW9uVG90YWw6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJ1bGxldENsYXNzOiBcInN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldFwiLFxuICAgICAgICAgICAgYnVsbGV0QWN0aXZlQ2xhc3M6IFwic3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LWFjdGl2ZVwiLFxuICAgICAgICAgICAgbW9kaWZpZXJDbGFzczogXCJzd2lwZXItcGFnaW5hdGlvbi1cIixcbiAgICAgICAgICAgIGN1cnJlbnRDbGFzczogXCJzd2lwZXItcGFnaW5hdGlvbi1jdXJyZW50XCIsXG4gICAgICAgICAgICB0b3RhbENsYXNzOiBcInN3aXBlci1wYWdpbmF0aW9uLXRvdGFsXCIsXG4gICAgICAgICAgICBoaWRkZW5DbGFzczogXCJzd2lwZXItcGFnaW5hdGlvbi1oaWRkZW5cIixcbiAgICAgICAgICAgIHByb2dyZXNzYmFyRmlsbENsYXNzOiBcInN3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFyLWZpbGxcIixcbiAgICAgICAgICAgIHByb2dyZXNzYmFyT3Bwb3NpdGVDbGFzczogXCJzd2lwZXItcGFnaW5hdGlvbi1wcm9ncmVzc2Jhci1vcHBvc2l0ZVwiLFxuICAgICAgICAgICAgY2xpY2thYmxlQ2xhc3M6IFwic3dpcGVyLXBhZ2luYXRpb24tY2xpY2thYmxlXCIsXG4gICAgICAgICAgICBsb2NrQ2xhc3M6IFwic3dpcGVyLXBhZ2luYXRpb24tbG9ja1wiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIE0odGhpcywgeyBwYWdpbmF0aW9uOiB0KHsgZHluYW1pY0J1bGxldEluZGV4OiAwIH0sIFopIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnBhZ2luYXRpb24uaW5pdCgpLCBlLnBhZ2luYXRpb24ucmVuZGVyKCksIGUucGFnaW5hdGlvbi51cGRhdGUoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFjdGl2ZUluZGV4Q2hhbmdlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgKGUucGFyYW1zLmxvb3AgfHwgdm9pZCAwID09PSBlLnNuYXBJbmRleCkgJiYgZS5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc25hcEluZGV4Q2hhbmdlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wYXJhbXMubG9vcCB8fCBlLnBhZ2luYXRpb24udXBkYXRlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzbGlkZXNMZW5ndGhDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnBhcmFtcy5sb29wICYmIChlLnBhZ2luYXRpb24ucmVuZGVyKCksIGUucGFnaW5hdGlvbi51cGRhdGUoKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzbmFwR3JpZExlbmd0aENoYW5nZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucGFyYW1zLmxvb3AgfHwgKGUucGFnaW5hdGlvbi5yZW5kZXIoKSwgZS5wYWdpbmF0aW9uLnVwZGF0ZSgpKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnBhZ2luYXRpb24uZGVzdHJveSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICBlLnBhcmFtcy5wYWdpbmF0aW9uLmVsICYmXG4gICAgICAgICAgICAgIGUucGFyYW1zLnBhZ2luYXRpb24uaGlkZU9uQ2xpY2sgJiZcbiAgICAgICAgICAgICAgZS5wYWdpbmF0aW9uLiRlbC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICFtKHQudGFyZ2V0KS5oYXNDbGFzcyhlLnBhcmFtcy5wYWdpbmF0aW9uLmJ1bGxldENsYXNzKSAmJlxuICAgICAgICAgICAgICAoITAgPT09IGUucGFnaW5hdGlvbi4kZWwuaGFzQ2xhc3MoZS5wYXJhbXMucGFnaW5hdGlvbi5oaWRkZW5DbGFzcylcbiAgICAgICAgICAgICAgICA/IGUuZW1pdChcInBhZ2luYXRpb25TaG93XCIpXG4gICAgICAgICAgICAgICAgOiBlLmVtaXQoXCJwYWdpbmF0aW9uSGlkZVwiKSxcbiAgICAgICAgICAgICAgZS5wYWdpbmF0aW9uLiRlbC50b2dnbGVDbGFzcyhlLnBhcmFtcy5wYWdpbmF0aW9uLmhpZGRlbkNsYXNzKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwic2Nyb2xsYmFyXCIsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIHNjcm9sbGJhcjoge1xuICAgICAgICAgICAgZWw6IG51bGwsXG4gICAgICAgICAgICBkcmFnU2l6ZTogXCJhdXRvXCIsXG4gICAgICAgICAgICBoaWRlOiAhMSxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogITEsXG4gICAgICAgICAgICBzbmFwT25SZWxlYXNlOiAhMCxcbiAgICAgICAgICAgIGxvY2tDbGFzczogXCJzd2lwZXItc2Nyb2xsYmFyLWxvY2tcIixcbiAgICAgICAgICAgIGRyYWdDbGFzczogXCJzd2lwZXItc2Nyb2xsYmFyLWRyYWdcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBNKHRoaXMsIHtcbiAgICAgICAgICAgIHNjcm9sbGJhcjogdChcbiAgICAgICAgICAgICAgeyBpc1RvdWNoZWQ6ICExLCB0aW1lb3V0OiBudWxsLCBkcmFnVGltZW91dDogbnVsbCB9LFxuICAgICAgICAgICAgICBKXG4gICAgICAgICAgICApLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnNjcm9sbGJhci5pbml0KCksXG4gICAgICAgICAgICAgIGUuc2Nyb2xsYmFyLnVwZGF0ZVNpemUoKSxcbiAgICAgICAgICAgICAgZS5zY3JvbGxiYXIuc2V0VHJhbnNsYXRlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnNjcm9sbGJhci51cGRhdGVTaXplKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNpemU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnNjcm9sbGJhci51cGRhdGVTaXplKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvYnNlcnZlclVwZGF0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuc2Nyb2xsYmFyLnVwZGF0ZVNpemUoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldFRyYW5zbGF0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuc2Nyb2xsYmFyLnNldFRyYW5zbGF0ZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0VHJhbnNpdGlvbjogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIGUuc2Nyb2xsYmFyLnNldFRyYW5zaXRpb24odCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5zY3JvbGxiYXIuZGVzdHJveSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcInBhcmFsbGF4XCIsXG4gICAgICAgIHBhcmFtczogeyBwYXJhbGxheDogeyBlbmFibGVkOiAhMSB9IH0sXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIE0odGhpcywgeyBwYXJhbGxheDogdCh7fSwgUSkgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgYmVmb3JlSW5pdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucGFyYW1zLnBhcmFsbGF4LmVuYWJsZWQgJiZcbiAgICAgICAgICAgICAgKChlLnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gITApLFxuICAgICAgICAgICAgICAoZS5vcmlnaW5hbFBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gITApKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnBhcmFtcy5wYXJhbGxheC5lbmFibGVkICYmIGUucGFyYWxsYXguc2V0VHJhbnNsYXRlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXRUcmFuc2xhdGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnBhcmFtcy5wYXJhbGxheC5lbmFibGVkICYmIGUucGFyYWxsYXguc2V0VHJhbnNsYXRlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgZS5wYXJhbXMucGFyYWxsYXguZW5hYmxlZCAmJiBlLnBhcmFsbGF4LnNldFRyYW5zaXRpb24odCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiem9vbVwiLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICB6b29tOiB7XG4gICAgICAgICAgICBlbmFibGVkOiAhMSxcbiAgICAgICAgICAgIG1heFJhdGlvOiAzLFxuICAgICAgICAgICAgbWluUmF0aW86IDEsXG4gICAgICAgICAgICB0b2dnbGU6ICEwLFxuICAgICAgICAgICAgY29udGFpbmVyQ2xhc3M6IFwic3dpcGVyLXpvb20tY29udGFpbmVyXCIsXG4gICAgICAgICAgICB6b29tZWRTbGlkZUNsYXNzOiBcInN3aXBlci1zbGlkZS16b29tZWRcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgICAgTShlLCB7XG4gICAgICAgICAgICB6b29tOiB0KFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogITEsXG4gICAgICAgICAgICAgICAgc2NhbGU6IDEsXG4gICAgICAgICAgICAgICAgY3VycmVudFNjYWxlOiAxLFxuICAgICAgICAgICAgICAgIGlzU2NhbGluZzogITEsXG4gICAgICAgICAgICAgICAgZ2VzdHVyZToge1xuICAgICAgICAgICAgICAgICAgJHNsaWRlRWw6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgIHNsaWRlV2lkdGg6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgIHNsaWRlSGVpZ2h0OiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAkaW1hZ2VFbDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgJGltYWdlV3JhcEVsOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICBtYXhSYXRpbzogMyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGltYWdlOiB7XG4gICAgICAgICAgICAgICAgICBpc1RvdWNoZWQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgIGlzTW92ZWQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRYOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50WTogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgbWluWDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgbWluWTogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgbWF4WDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgbWF4WTogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgd2lkdGg6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgc3RhcnRYOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICBzdGFydFk6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgIHRvdWNoZXNTdGFydDoge30sXG4gICAgICAgICAgICAgICAgICB0b3VjaGVzQ3VycmVudDoge30sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eToge1xuICAgICAgICAgICAgICAgICAgeDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgeTogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgcHJldlBvc2l0aW9uWDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgcHJldlBvc2l0aW9uWTogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgcHJldlRpbWU6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgYSA9IDE7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUuem9vbSwgXCJzY2FsZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICBpZiAoYSAhPT0gdCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gZS56b29tLmdlc3R1cmUuJGltYWdlRWxcbiAgICAgICAgICAgICAgICAgICAgPyBlLnpvb20uZ2VzdHVyZS4kaW1hZ2VFbFswXVxuICAgICAgICAgICAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgIHMgPSBlLnpvb20uZ2VzdHVyZS4kc2xpZGVFbFxuICAgICAgICAgICAgICAgICAgICA/IGUuem9vbS5nZXN0dXJlLiRzbGlkZUVsWzBdXG4gICAgICAgICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgIGUuZW1pdChcInpvb21DaGFuZ2VcIiwgdCwgaSwgcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYSA9IHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnBhcmFtcy56b29tLmVuYWJsZWQgJiYgZS56b29tLmVuYWJsZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuem9vbS5kaXNhYmxlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgZS56b29tLmVuYWJsZWQgJiYgZS56b29tLm9uVG91Y2hTdGFydCh0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvdWNoRW5kOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgZS56b29tLmVuYWJsZWQgJiYgZS56b29tLm9uVG91Y2hFbmQodCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkb3VibGVUYXA6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICBlLnBhcmFtcy56b29tLmVuYWJsZWQgJiZcbiAgICAgICAgICAgICAgZS56b29tLmVuYWJsZWQgJiZcbiAgICAgICAgICAgICAgZS5wYXJhbXMuem9vbS50b2dnbGUgJiZcbiAgICAgICAgICAgICAgZS56b29tLnRvZ2dsZSh0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnpvb20uZW5hYmxlZCAmJiBlLnBhcmFtcy56b29tLmVuYWJsZWQgJiYgZS56b29tLm9uVHJhbnNpdGlvbkVuZCgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2xpZGVDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnpvb20uZW5hYmxlZCAmJlxuICAgICAgICAgICAgICBlLnBhcmFtcy56b29tLmVuYWJsZWQgJiZcbiAgICAgICAgICAgICAgZS5wYXJhbXMuY3NzTW9kZSAmJlxuICAgICAgICAgICAgICBlLnpvb20ub25UcmFuc2l0aW9uRW5kKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwibGF6eVwiLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBsYXp5OiB7XG4gICAgICAgICAgICBjaGVja0luVmlldzogITEsXG4gICAgICAgICAgICBlbmFibGVkOiAhMSxcbiAgICAgICAgICAgIGxvYWRQcmV2TmV4dDogITEsXG4gICAgICAgICAgICBsb2FkUHJldk5leHRBbW91bnQ6IDEsXG4gICAgICAgICAgICBsb2FkT25UcmFuc2l0aW9uU3RhcnQ6ICExLFxuICAgICAgICAgICAgc2Nyb2xsaW5nRWxlbWVudDogXCJcIixcbiAgICAgICAgICAgIGVsZW1lbnRDbGFzczogXCJzd2lwZXItbGF6eVwiLFxuICAgICAgICAgICAgbG9hZGluZ0NsYXNzOiBcInN3aXBlci1sYXp5LWxvYWRpbmdcIixcbiAgICAgICAgICAgIGxvYWRlZENsYXNzOiBcInN3aXBlci1sYXp5LWxvYWRlZFwiLFxuICAgICAgICAgICAgcHJlbG9hZGVyQ2xhc3M6IFwic3dpcGVyLWxhenktcHJlbG9hZGVyXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgTSh0aGlzLCB7IGxhenk6IHQoeyBpbml0aWFsSW1hZ2VMb2FkZWQ6ICExIH0sIHRlKSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBiZWZvcmVJbml0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wYXJhbXMubGF6eS5lbmFibGVkICYmXG4gICAgICAgICAgICAgIGUucGFyYW1zLnByZWxvYWRJbWFnZXMgJiZcbiAgICAgICAgICAgICAgKGUucGFyYW1zLnByZWxvYWRJbWFnZXMgPSAhMSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wYXJhbXMubGF6eS5lbmFibGVkICYmXG4gICAgICAgICAgICAgICFlLnBhcmFtcy5sb29wICYmXG4gICAgICAgICAgICAgIDAgPT09IGUucGFyYW1zLmluaXRpYWxTbGlkZSAmJlxuICAgICAgICAgICAgICAoZS5wYXJhbXMubGF6eS5jaGVja0luVmlld1xuICAgICAgICAgICAgICAgID8gZS5sYXp5LmNoZWNrSW5WaWV3T25Mb2FkKClcbiAgICAgICAgICAgICAgICA6IGUubGF6eS5sb2FkKCkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2Nyb2xsOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wYXJhbXMuZnJlZU1vZGUgJiYgIWUucGFyYW1zLmZyZWVNb2RlU3RpY2t5ICYmIGUubGF6eS5sb2FkKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNpemU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnBhcmFtcy5sYXp5LmVuYWJsZWQgJiYgZS5sYXp5LmxvYWQoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNjcm9sbGJhckRyYWdNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wYXJhbXMubGF6eS5lbmFibGVkICYmIGUubGF6eS5sb2FkKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmFuc2l0aW9uU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnBhcmFtcy5sYXp5LmVuYWJsZWQgJiZcbiAgICAgICAgICAgICAgKGUucGFyYW1zLmxhenkubG9hZE9uVHJhbnNpdGlvblN0YXJ0IHx8XG4gICAgICAgICAgICAgICAgKCFlLnBhcmFtcy5sYXp5LmxvYWRPblRyYW5zaXRpb25TdGFydCAmJlxuICAgICAgICAgICAgICAgICAgIWUubGF6eS5pbml0aWFsSW1hZ2VMb2FkZWQpKSAmJlxuICAgICAgICAgICAgICBlLmxhenkubG9hZCgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucGFyYW1zLmxhenkuZW5hYmxlZCAmJlxuICAgICAgICAgICAgICAhZS5wYXJhbXMubGF6eS5sb2FkT25UcmFuc2l0aW9uU3RhcnQgJiZcbiAgICAgICAgICAgICAgZS5sYXp5LmxvYWQoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNsaWRlQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wYXJhbXMubGF6eS5lbmFibGVkICYmIGUucGFyYW1zLmNzc01vZGUgJiYgZS5sYXp5LmxvYWQoKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJjb250cm9sbGVyXCIsXG4gICAgICAgIHBhcmFtczogeyBjb250cm9sbGVyOiB7IGNvbnRyb2w6IHZvaWQgMCwgaW52ZXJzZTogITEsIGJ5OiBcInNsaWRlXCIgfSB9LFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBNKHRoaXMsIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IHQoeyBjb250cm9sOiB0aGlzLnBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2wgfSwgYWUpLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuY29udHJvbGxlci5jb250cm9sICYmXG4gICAgICAgICAgICAgIGUuY29udHJvbGxlci5zcGxpbmUgJiZcbiAgICAgICAgICAgICAgKChlLmNvbnRyb2xsZXIuc3BsaW5lID0gdm9pZCAwKSwgZGVsZXRlIGUuY29udHJvbGxlci5zcGxpbmUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5jb250cm9sbGVyLmNvbnRyb2wgJiZcbiAgICAgICAgICAgICAgZS5jb250cm9sbGVyLnNwbGluZSAmJlxuICAgICAgICAgICAgICAoKGUuY29udHJvbGxlci5zcGxpbmUgPSB2b2lkIDApLCBkZWxldGUgZS5jb250cm9sbGVyLnNwbGluZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvYnNlcnZlclVwZGF0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuY29udHJvbGxlci5jb250cm9sICYmXG4gICAgICAgICAgICAgIGUuY29udHJvbGxlci5zcGxpbmUgJiZcbiAgICAgICAgICAgICAgKChlLmNvbnRyb2xsZXIuc3BsaW5lID0gdm9pZCAwKSwgZGVsZXRlIGUuY29udHJvbGxlci5zcGxpbmUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0VHJhbnNsYXRlOiBmdW5jdGlvbiAoZSwgdCwgYSkge1xuICAgICAgICAgICAgZS5jb250cm9sbGVyLmNvbnRyb2wgJiYgZS5jb250cm9sbGVyLnNldFRyYW5zbGF0ZSh0LCBhKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uIChlLCB0LCBhKSB7XG4gICAgICAgICAgICBlLmNvbnRyb2xsZXIuY29udHJvbCAmJiBlLmNvbnRyb2xsZXIuc2V0VHJhbnNpdGlvbih0LCBhKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJhMTF5XCIsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGExMXk6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6ICEwLFxuICAgICAgICAgICAgbm90aWZpY2F0aW9uQ2xhc3M6IFwic3dpcGVyLW5vdGlmaWNhdGlvblwiLFxuICAgICAgICAgICAgcHJldlNsaWRlTWVzc2FnZTogXCJQcmV2aW91cyBzbGlkZVwiLFxuICAgICAgICAgICAgbmV4dFNsaWRlTWVzc2FnZTogXCJOZXh0IHNsaWRlXCIsXG4gICAgICAgICAgICBmaXJzdFNsaWRlTWVzc2FnZTogXCJUaGlzIGlzIHRoZSBmaXJzdCBzbGlkZVwiLFxuICAgICAgICAgICAgbGFzdFNsaWRlTWVzc2FnZTogXCJUaGlzIGlzIHRoZSBsYXN0IHNsaWRlXCIsXG4gICAgICAgICAgICBwYWdpbmF0aW9uQnVsbGV0TWVzc2FnZTogXCJHbyB0byBzbGlkZSB7e2luZGV4fX1cIixcbiAgICAgICAgICAgIGNvbnRhaW5lck1lc3NhZ2U6IG51bGwsXG4gICAgICAgICAgICBjb250YWluZXJSb2xlRGVzY3JpcHRpb25NZXNzYWdlOiBudWxsLFxuICAgICAgICAgICAgaXRlbVJvbGVEZXNjcmlwdGlvbk1lc3NhZ2U6IG51bGwsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgTSh0aGlzLCB7XG4gICAgICAgICAgICBhMTF5OiB0KHt9LCBpZSwge1xuICAgICAgICAgICAgICBsaXZlUmVnaW9uOiBtKFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cIicgK1xuICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMuYTExeS5ub3RpZmljYXRpb25DbGFzcyArXG4gICAgICAgICAgICAgICAgICAnXCIgYXJpYS1saXZlPVwiYXNzZXJ0aXZlXCIgYXJpYS1hdG9taWM9XCJ0cnVlXCI+PC9zcGFuPidcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGFmdGVySW5pdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucGFyYW1zLmExMXkuZW5hYmxlZCAmJiAoZS5hMTF5LmluaXQoKSwgZS5hMTF5LnVwZGF0ZU5hdmlnYXRpb24oKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b0VkZ2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnBhcmFtcy5hMTF5LmVuYWJsZWQgJiYgZS5hMTF5LnVwZGF0ZU5hdmlnYXRpb24oKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZyb21FZGdlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wYXJhbXMuYTExeS5lbmFibGVkICYmIGUuYTExeS51cGRhdGVOYXZpZ2F0aW9uKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYWdpbmF0aW9uVXBkYXRlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wYXJhbXMuYTExeS5lbmFibGVkICYmIGUuYTExeS51cGRhdGVQYWdpbmF0aW9uKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wYXJhbXMuYTExeS5lbmFibGVkICYmIGUuYTExeS5kZXN0cm95KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiaGlzdG9yeVwiLFxuICAgICAgICBwYXJhbXM6IHsgaGlzdG9yeTogeyBlbmFibGVkOiAhMSwgcmVwbGFjZVN0YXRlOiAhMSwga2V5OiBcInNsaWRlc1wiIH0gfSxcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgTSh0aGlzLCB7IGhpc3Rvcnk6IHQoe30sIHNlKSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wYXJhbXMuaGlzdG9yeS5lbmFibGVkICYmIGUuaGlzdG9yeS5pbml0KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wYXJhbXMuaGlzdG9yeS5lbmFibGVkICYmIGUuaGlzdG9yeS5kZXN0cm95KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5oaXN0b3J5LmluaXRpYWxpemVkICYmXG4gICAgICAgICAgICAgIGUuaGlzdG9yeS5zZXRIaXN0b3J5KGUucGFyYW1zLmhpc3Rvcnkua2V5LCBlLmFjdGl2ZUluZGV4KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNsaWRlQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5oaXN0b3J5LmluaXRpYWxpemVkICYmXG4gICAgICAgICAgICAgIGUucGFyYW1zLmNzc01vZGUgJiZcbiAgICAgICAgICAgICAgZS5oaXN0b3J5LnNldEhpc3RvcnkoZS5wYXJhbXMuaGlzdG9yeS5rZXksIGUuYWN0aXZlSW5kZXgpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcImhhc2gtbmF2aWdhdGlvblwiLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBoYXNoTmF2aWdhdGlvbjogeyBlbmFibGVkOiAhMSwgcmVwbGFjZVN0YXRlOiAhMSwgd2F0Y2hTdGF0ZTogITEgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgTSh0aGlzLCB7IGhhc2hOYXZpZ2F0aW9uOiB0KHsgaW5pdGlhbGl6ZWQ6ICExIH0sIHJlKSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCAmJiBlLmhhc2hOYXZpZ2F0aW9uLmluaXQoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnBhcmFtcy5oYXNoTmF2aWdhdGlvbi5lbmFibGVkICYmIGUuaGFzaE5hdmlnYXRpb24uZGVzdHJveSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuaGFzaE5hdmlnYXRpb24uaW5pdGlhbGl6ZWQgJiYgZS5oYXNoTmF2aWdhdGlvbi5zZXRIYXNoKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzbGlkZUNoYW5nZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuaGFzaE5hdmlnYXRpb24uaW5pdGlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgZS5wYXJhbXMuY3NzTW9kZSAmJlxuICAgICAgICAgICAgICBlLmhhc2hOYXZpZ2F0aW9uLnNldEhhc2goKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJhdXRvcGxheVwiLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBhdXRvcGxheToge1xuICAgICAgICAgICAgZW5hYmxlZDogITEsXG4gICAgICAgICAgICBkZWxheTogM2UzLFxuICAgICAgICAgICAgd2FpdEZvclRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgZGlzYWJsZU9uSW50ZXJhY3Rpb246ICEwLFxuICAgICAgICAgICAgc3RvcE9uTGFzdFNsaWRlOiAhMSxcbiAgICAgICAgICAgIHJldmVyc2VEaXJlY3Rpb246ICExLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIE0odGhpcywgeyBhdXRvcGxheTogdCh7fSwgbmUsIHsgcnVubmluZzogITEsIHBhdXNlZDogITEgfSkgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgaW5pdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucGFyYW1zLmF1dG9wbGF5LmVuYWJsZWQgJiZcbiAgICAgICAgICAgICAgKGUuYXV0b3BsYXkuc3RhcnQoKSxcbiAgICAgICAgICAgICAgcigpLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsXG4gICAgICAgICAgICAgICAgZS5hdXRvcGxheS5vblZpc2liaWxpdHlDaGFuZ2VcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBiZWZvcmVUcmFuc2l0aW9uU3RhcnQ6IGZ1bmN0aW9uIChlLCB0LCBhKSB7XG4gICAgICAgICAgICBlLmF1dG9wbGF5LnJ1bm5pbmcgJiZcbiAgICAgICAgICAgICAgKGEgfHwgIWUucGFyYW1zLmF1dG9wbGF5LmRpc2FibGVPbkludGVyYWN0aW9uXG4gICAgICAgICAgICAgICAgPyBlLmF1dG9wbGF5LnBhdXNlKHQpXG4gICAgICAgICAgICAgICAgOiBlLmF1dG9wbGF5LnN0b3AoKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzbGlkZXJGaXJzdE1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLmF1dG9wbGF5LnJ1bm5pbmcgJiZcbiAgICAgICAgICAgICAgKGUucGFyYW1zLmF1dG9wbGF5LmRpc2FibGVPbkludGVyYWN0aW9uXG4gICAgICAgICAgICAgICAgPyBlLmF1dG9wbGF5LnN0b3AoKVxuICAgICAgICAgICAgICAgIDogZS5hdXRvcGxheS5wYXVzZSgpKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvdWNoRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wYXJhbXMuY3NzTW9kZSAmJlxuICAgICAgICAgICAgICBlLmF1dG9wbGF5LnBhdXNlZCAmJlxuICAgICAgICAgICAgICAhZS5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24gJiZcbiAgICAgICAgICAgICAgZS5hdXRvcGxheS5ydW4oKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLmF1dG9wbGF5LnJ1bm5pbmcgJiYgZS5hdXRvcGxheS5zdG9wKCksXG4gICAgICAgICAgICAgIHIoKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eWNoYW5nZVwiLFxuICAgICAgICAgICAgICAgIGUuYXV0b3BsYXkub25WaXNpYmlsaXR5Q2hhbmdlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiZWZmZWN0LWZhZGVcIixcbiAgICAgICAgcGFyYW1zOiB7IGZhZGVFZmZlY3Q6IHsgY3Jvc3NGYWRlOiAhMSB9IH0sXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIE0odGhpcywgeyBmYWRlRWZmZWN0OiB0KHt9LCBsZSkgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgYmVmb3JlSW5pdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChcImZhZGVcIiA9PT0gZS5wYXJhbXMuZWZmZWN0KSB7XG4gICAgICAgICAgICAgIGUuY2xhc3NOYW1lcy5wdXNoKGUucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBcImZhZGVcIik7XG4gICAgICAgICAgICAgIHZhciB0ID0ge1xuICAgICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDEsXG4gICAgICAgICAgICAgICAgc2xpZGVzUGVyQ29sdW1uOiAxLFxuICAgICAgICAgICAgICAgIHNsaWRlc1Blckdyb3VwOiAxLFxuICAgICAgICAgICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6ICEwLFxuICAgICAgICAgICAgICAgIHNwYWNlQmV0d2VlbjogMCxcbiAgICAgICAgICAgICAgICB2aXJ0dWFsVHJhbnNsYXRlOiAhMCxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgUyhlLnBhcmFtcywgdCksIFMoZS5vcmlnaW5hbFBhcmFtcywgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXRUcmFuc2xhdGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBcImZhZGVcIiA9PT0gZS5wYXJhbXMuZWZmZWN0ICYmIGUuZmFkZUVmZmVjdC5zZXRUcmFuc2xhdGUoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICBcImZhZGVcIiA9PT0gZS5wYXJhbXMuZWZmZWN0ICYmIGUuZmFkZUVmZmVjdC5zZXRUcmFuc2l0aW9uKHQpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcImVmZmVjdC1jdWJlXCIsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGN1YmVFZmZlY3Q6IHtcbiAgICAgICAgICAgIHNsaWRlU2hhZG93czogITAsXG4gICAgICAgICAgICBzaGFkb3c6ICEwLFxuICAgICAgICAgICAgc2hhZG93T2Zmc2V0OiAyMCxcbiAgICAgICAgICAgIHNoYWRvd1NjYWxlOiAwLjk0LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIE0odGhpcywgeyBjdWJlRWZmZWN0OiB0KHt9LCBvZSkgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgYmVmb3JlSW5pdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChcImN1YmVcIiA9PT0gZS5wYXJhbXMuZWZmZWN0KSB7XG4gICAgICAgICAgICAgIGUuY2xhc3NOYW1lcy5wdXNoKGUucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBcImN1YmVcIiksXG4gICAgICAgICAgICAgICAgZS5jbGFzc05hbWVzLnB1c2goZS5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcyArIFwiM2RcIik7XG4gICAgICAgICAgICAgIHZhciB0ID0ge1xuICAgICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDEsXG4gICAgICAgICAgICAgICAgc2xpZGVzUGVyQ29sdW1uOiAxLFxuICAgICAgICAgICAgICAgIHNsaWRlc1Blckdyb3VwOiAxLFxuICAgICAgICAgICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6ICEwLFxuICAgICAgICAgICAgICAgIHJlc2lzdGFuY2VSYXRpbzogMCxcbiAgICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDAsXG4gICAgICAgICAgICAgICAgY2VudGVyZWRTbGlkZXM6ICExLFxuICAgICAgICAgICAgICAgIHZpcnR1YWxUcmFuc2xhdGU6ICEwLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBTKGUucGFyYW1zLCB0KSwgUyhlLm9yaWdpbmFsUGFyYW1zLCB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldFRyYW5zbGF0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIFwiY3ViZVwiID09PSBlLnBhcmFtcy5lZmZlY3QgJiYgZS5jdWJlRWZmZWN0LnNldFRyYW5zbGF0ZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0VHJhbnNpdGlvbjogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIFwiY3ViZVwiID09PSBlLnBhcmFtcy5lZmZlY3QgJiYgZS5jdWJlRWZmZWN0LnNldFRyYW5zaXRpb24odCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiZWZmZWN0LWZsaXBcIixcbiAgICAgICAgcGFyYW1zOiB7IGZsaXBFZmZlY3Q6IHsgc2xpZGVTaGFkb3dzOiAhMCwgbGltaXRSb3RhdGlvbjogITAgfSB9LFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBNKHRoaXMsIHsgZmxpcEVmZmVjdDogdCh7fSwgZGUpIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGJlZm9yZUluaXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoXCJmbGlwXCIgPT09IGUucGFyYW1zLmVmZmVjdCkge1xuICAgICAgICAgICAgICBlLmNsYXNzTmFtZXMucHVzaChlLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzICsgXCJmbGlwXCIpLFxuICAgICAgICAgICAgICAgIGUuY2xhc3NOYW1lcy5wdXNoKGUucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBcIjNkXCIpO1xuICAgICAgICAgICAgICB2YXIgdCA9IHtcbiAgICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxuICAgICAgICAgICAgICAgIHNsaWRlc1BlckNvbHVtbjogMSxcbiAgICAgICAgICAgICAgICBzbGlkZXNQZXJHcm91cDogMSxcbiAgICAgICAgICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiAhMCxcbiAgICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDAsXG4gICAgICAgICAgICAgICAgdmlydHVhbFRyYW5zbGF0ZTogITAsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFMoZS5wYXJhbXMsIHQpLCBTKGUub3JpZ2luYWxQYXJhbXMsIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0VHJhbnNsYXRlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgXCJmbGlwXCIgPT09IGUucGFyYW1zLmVmZmVjdCAmJiBlLmZsaXBFZmZlY3Quc2V0VHJhbnNsYXRlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgXCJmbGlwXCIgPT09IGUucGFyYW1zLmVmZmVjdCAmJiBlLmZsaXBFZmZlY3Quc2V0VHJhbnNpdGlvbih0KTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJlZmZlY3QtY292ZXJmbG93XCIsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGNvdmVyZmxvd0VmZmVjdDoge1xuICAgICAgICAgICAgcm90YXRlOiA1MCxcbiAgICAgICAgICAgIHN0cmV0Y2g6IDAsXG4gICAgICAgICAgICBkZXB0aDogMTAwLFxuICAgICAgICAgICAgc2NhbGU6IDEsXG4gICAgICAgICAgICBtb2RpZmllcjogMSxcbiAgICAgICAgICAgIHNsaWRlU2hhZG93czogITAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgTSh0aGlzLCB7IGNvdmVyZmxvd0VmZmVjdDogdCh7fSwgcGUpIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGJlZm9yZUluaXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBcImNvdmVyZmxvd1wiID09PSBlLnBhcmFtcy5lZmZlY3QgJiZcbiAgICAgICAgICAgICAgKGUuY2xhc3NOYW1lcy5wdXNoKGUucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBcImNvdmVyZmxvd1wiKSxcbiAgICAgICAgICAgICAgZS5jbGFzc05hbWVzLnB1c2goZS5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcyArIFwiM2RcIiksXG4gICAgICAgICAgICAgIChlLnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gITApLFxuICAgICAgICAgICAgICAoZS5vcmlnaW5hbFBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gITApKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldFRyYW5zbGF0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIFwiY292ZXJmbG93XCIgPT09IGUucGFyYW1zLmVmZmVjdCAmJiBlLmNvdmVyZmxvd0VmZmVjdC5zZXRUcmFuc2xhdGUoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICBcImNvdmVyZmxvd1wiID09PSBlLnBhcmFtcy5lZmZlY3QgJiZcbiAgICAgICAgICAgICAgZS5jb3ZlcmZsb3dFZmZlY3Quc2V0VHJhbnNpdGlvbih0KTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJ0aHVtYnNcIixcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgdGh1bWJzOiB7XG4gICAgICAgICAgICBzd2lwZXI6IG51bGwsXG4gICAgICAgICAgICBtdWx0aXBsZUFjdGl2ZVRodW1iczogITAsXG4gICAgICAgICAgICBhdXRvU2Nyb2xsT2Zmc2V0OiAwLFxuICAgICAgICAgICAgc2xpZGVUaHVtYkFjdGl2ZUNsYXNzOiBcInN3aXBlci1zbGlkZS10aHVtYi1hY3RpdmVcIixcbiAgICAgICAgICAgIHRodW1ic0NvbnRhaW5lckNsYXNzOiBcInN3aXBlci1jb250YWluZXItdGh1bWJzXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgTSh0aGlzLCB7IHRodW1iczogdCh7IHN3aXBlcjogbnVsbCwgaW5pdGlhbGl6ZWQ6ICExIH0sIHVlKSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBiZWZvcmVJbml0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHQgPSBlLnBhcmFtcy50aHVtYnM7XG4gICAgICAgICAgICB0ICYmIHQuc3dpcGVyICYmIChlLnRodW1icy5pbml0KCksIGUudGh1bWJzLnVwZGF0ZSghMCkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2xpZGVDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnRodW1icy5zd2lwZXIgJiYgZS50aHVtYnMudXBkYXRlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnRodW1icy5zd2lwZXIgJiYgZS50aHVtYnMudXBkYXRlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNpemU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnRodW1icy5zd2lwZXIgJiYgZS50aHVtYnMudXBkYXRlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvYnNlcnZlclVwZGF0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUudGh1bWJzLnN3aXBlciAmJiBlLnRodW1icy51cGRhdGUoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICB2YXIgYSA9IGUudGh1bWJzLnN3aXBlcjtcbiAgICAgICAgICAgIGEgJiYgYS5zZXRUcmFuc2l0aW9uKHQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0gZS50aHVtYnMuc3dpcGVyO1xuICAgICAgICAgICAgdCAmJiBlLnRodW1icy5zd2lwZXJDcmVhdGVkICYmIHQgJiYgdC5kZXN0cm95KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXTtcbiAgcmV0dXJuIFIudXNlKGNlKSwgUjtcbn0pO1xuXHJcblxyXG5sZXQgbWFpblNsaWRlciA9IG5ldyBTd2lwZXIoXCIudG9wLXNsaWRlcl9faW5uZXJcIiwge1xyXG4gICAgbmF2aWdhdGlvbjoge1xyXG4gICAgICAgIG5leHRFbDogXCIuc3dpcGVyLWJ1dHRvbi1uZXh0XCIsXHJcbiAgICAgICAgcHJldkVsOiBcIi5zd2lwZXItYnV0dG9uLXByZXZcIixcclxuICAgIH0sXHJcbiAgICBwYWdpbmF0aW9uOiB7XHJcbiAgICAgICAgZWw6IFwiLnN3aXBlci1wYWdpbmF0aW9uXCIsXHJcbiAgICAgICAgY2xpY2thYmxlOiB0cnVlLFxyXG4gICAgfSxcclxuICAgIHNsaWRlc1BlclZpZXc6IDEsXHJcbiAgICBhdXRvcGxheToge1xyXG4gICAgICAgIGRlbGF5OiAyMDAwLFxyXG4gICAgICAgIGRpc2FibGVPbkludGVyYWN0aW9uOiBmYWxzZVxyXG4gICAgfSxcclxuICAgIHNwZWVkOiA4MDAsXHJcbiAgICBlZmZlY3Q6ICdzbGlkZScsXHJcbiAgICBwcmVsb2FkSW1hZ2VzOiBmYWxzZSxcclxuICAgIGxhenk6IHtcclxuICAgICAgICBsb2FkT25UcmFuc2l0aW9uU3RhcnQ6IGZhbHNlLFxyXG4gICAgICAgIGxvYWRQcmV2TmV4dDogdHJ1ZSxcclxuICAgIH0sXHJcbiAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiB0cnVlLFxyXG4gICAgd2F0Y2hTbGlkZXNWaXNpYmlsaXR5OiB0cnVlLFxyXG59KTtcclxuXHJcbmxldCByZXZpZXdzX19TbGlkZXIgPSBuZXcgU3dpcGVyKFwiLnJldmlld3NfX3NsaWRlclwiLCB7XHJcbiAgICBuYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgbmV4dEVsOiBcIi5zd2lwZXItYnV0dG9uLW5leHRcIixcclxuICAgICAgICBwcmV2RWw6IFwiLnN3aXBlci1idXR0b24tcHJldlwiLFxyXG4gICAgfSxcclxuICAgIHBhZ2luYXRpb246IHtcclxuICAgICAgICBlbDogXCIuc3dpcGVyLXBhZ2luYXRpb25cIixcclxuICAgICAgICBjbGlja2FibGU6IHRydWUsXHJcbiAgICB9LFxyXG4gICAgc2xpZGVzUGVyVmlldzogMSxcclxuICAgIC8vIGF1dG9wbGF5OiB7XHJcbiAgICAvLyAgICAgZGVsYXk6IDIwMDAsXHJcbiAgICAvLyAgICAgZGlzYWJsZU9uSW50ZXJhY3Rpb246IGZhbHNlXHJcbiAgICAvLyB9LFxyXG4gICAgc3BlZWQ6IDgwMCxcclxuICAgIGVmZmVjdDogJ3NsaWRlJyxcclxuICAgIHByZWxvYWRJbWFnZXM6IGZhbHNlLFxyXG4gICAgbGF6eToge1xyXG4gICAgICAgIGxvYWRPblRyYW5zaXRpb25TdGFydDogZmFsc2UsXHJcbiAgICAgICAgbG9hZFByZXZOZXh0OiB0cnVlLFxyXG4gICAgfSxcclxuICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IHRydWUsXHJcbiAgICB3YXRjaFNsaWRlc1Zpc2liaWxpdHk6IHRydWUsXHJcbiAgICBicmVha3BvaW50czoge1xyXG4gICAgICAgIDkwMDoge1xyXG4gICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAyLFxyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubGV0IGZhZ19fU2xpZGVyID0gbmV3IFN3aXBlcihcIi5mYWdfX3NsaWRlclwiLCB7XHJcbiAgICBuYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgbmV4dEVsOiBcIi5zd2lwZXItYnV0dG9uLW5leHRcIixcclxuICAgICAgICBwcmV2RWw6IFwiLnN3aXBlci1idXR0b24tcHJldlwiLFxyXG4gICAgfSxcclxuICAgIHBhZ2luYXRpb246IHtcclxuICAgICAgICBlbDogXCIuc3dpcGVyLXBhZ2luYXRpb25cIixcclxuICAgICAgICBjbGlja2FibGU6IHRydWUsXHJcbiAgICB9LFxyXG4gICAgc2xpZGVzUGVyVmlldzogMSxcclxuICAgIC8vIGF1dG9wbGF5OiB7XHJcbiAgICAvLyAgICAgZGVsYXk6IDIwMDAsXHJcbiAgICAvLyAgICAgZGlzYWJsZU9uSW50ZXJhY3Rpb246IGZhbHNlXHJcbiAgICAvLyB9LFxyXG4gICAgc3BlZWQ6IDgwMCxcclxuICAgIGVmZmVjdDogJ3NsaWRlJyxcclxuICAgIHByZWxvYWRJbWFnZXM6IGZhbHNlLFxyXG4gICAgbGF6eToge1xyXG4gICAgICAgIGxvYWRPblRyYW5zaXRpb25TdGFydDogZmFsc2UsXHJcbiAgICAgICAgbG9hZFByZXZOZXh0OiB0cnVlLFxyXG4gICAgfSxcclxuICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IHRydWUsXHJcbiAgICB3YXRjaFNsaWRlc1Zpc2liaWxpdHk6IHRydWUsXHJcbiAgICBicmVha3BvaW50czoge1xyXG4gICAgICAgIDkwMDoge1xyXG4gICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAyLFxyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xuZG9jdW1lbnQuYm9keS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsICc8ZGl2IGNsYXNzPVwic2Nyb2xsVG9Ub3AgX2ljb24tYXJyXCI+PC9kaXY+JylcclxubGV0IHNjcm9sbEJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zY3JvbGxUb1RvcCcpO1xyXG5cclxuXHJcblxyXG5zY3JvbGxCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xyXG4gIGRvY3VtZW50LmJvZHkuc2Nyb2xsSW50b1ZpZXcoe1xyXG4gICAgYmVoYXZpb3I6ICdzbW9vdGgnLFxyXG4gICAgYmxvY2s6ICdzdGFydCdcclxuICB9KVxyXG59KVxyXG5cclxud2luZG93Lm9uc2Nyb2xsID0gZnVuY3Rpb24oKSB7XHJcbiAgbGV0IHNjcm9sbFRvcCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XHJcbiAgaWYgKHNjcm9sbFRvcCA+IDQwMCkge1xyXG4gICAgc2Nyb2xsQnRuLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNjcm9sbEJ0bi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gIH1cclxufVxyXG5cclxuXHJcblxuXHJcblxyXG5cclxuLyohIG5vdWlzbGlkZXIgLSAxNC42LjIgLSA5LzE2LzIwMjAgKi9cclxuIShmdW5jdGlvbiAodCkge1xyXG5cdFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWRcclxuXHRcdD8gZGVmaW5lKFtdLCB0KVxyXG5cdFx0OiBcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzXHJcblx0XHQ/IChtb2R1bGUuZXhwb3J0cyA9IHQoKSlcclxuXHRcdDogKHdpbmRvdy5ub1VpU2xpZGVyID0gdCgpKTtcclxufSkoZnVuY3Rpb24gKCkge1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdHZhciBsdCA9IFwiMTQuNi4yXCI7XHJcblx0ZnVuY3Rpb24gdXQodCkge1xyXG5cdFx0dC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHQpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBhKHQpIHtcclxuXHRcdHJldHVybiBudWxsICE9IHQ7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGN0KHQpIHtcclxuXHRcdHQucHJldmVudERlZmF1bHQoKTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gbyh0KSB7XHJcblx0XHRyZXR1cm4gXCJudW1iZXJcIiA9PSB0eXBlb2YgdCAmJiAhaXNOYU4odCkgJiYgaXNGaW5pdGUodCk7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIHB0KHQsIGUsIHIpIHtcclxuXHRcdDAgPCByICYmXHJcblx0XHQoaHQodCwgZSksXHJcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdG10KHQsIGUpO1xyXG5cdFx0XHR9LCByKSk7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGZ0KHQpIHtcclxuXHRcdHJldHVybiBNYXRoLm1heChNYXRoLm1pbih0LCAxMDApLCAwKTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gZHQodCkge1xyXG5cdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyB0IDogW3RdO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBlKHQpIHtcclxuXHRcdHZhciBlID0gKHQgPSBTdHJpbmcodCkpLnNwbGl0KFwiLlwiKTtcclxuXHRcdHJldHVybiAxIDwgZS5sZW5ndGggPyBlWzFdLmxlbmd0aCA6IDA7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGh0KHQsIGUpIHtcclxuXHRcdHQuY2xhc3NMaXN0ICYmICEvXFxzLy50ZXN0KGUpXHJcblx0XHRcdD8gdC5jbGFzc0xpc3QuYWRkKGUpXHJcblx0XHRcdDogKHQuY2xhc3NOYW1lICs9IFwiIFwiICsgZSk7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIG10KHQsIGUpIHtcclxuXHRcdHQuY2xhc3NMaXN0ICYmICEvXFxzLy50ZXN0KGUpXHJcblx0XHRcdD8gdC5jbGFzc0xpc3QucmVtb3ZlKGUpXHJcblx0XHRcdDogKHQuY2xhc3NOYW1lID0gdC5jbGFzc05hbWUucmVwbGFjZShcclxuXHRcdFx0bmV3IFJlZ0V4cChcIihefFxcXFxiKVwiICsgZS5zcGxpdChcIiBcIikuam9pbihcInxcIikgKyBcIihcXFxcYnwkKVwiLCBcImdpXCIpLFxyXG5cdFx0XHRcIiBcIlxyXG5cdFx0XHQpKTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gZ3QodCkge1xyXG5cdFx0dmFyIGUgPSB2b2lkIDAgIT09IHdpbmRvdy5wYWdlWE9mZnNldCxcclxuXHRcdFx0ciA9IFwiQ1NTMUNvbXBhdFwiID09PSAodC5jb21wYXRNb2RlIHx8IFwiXCIpO1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0eDogZVxyXG5cdFx0XHRcdD8gd2luZG93LnBhZ2VYT2Zmc2V0XHJcblx0XHRcdFx0OiByXHJcblx0XHRcdFx0XHQ/IHQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnRcclxuXHRcdFx0XHRcdDogdC5ib2R5LnNjcm9sbExlZnQsXHJcblx0XHRcdHk6IGVcclxuXHRcdFx0XHQ/IHdpbmRvdy5wYWdlWU9mZnNldFxyXG5cdFx0XHRcdDogclxyXG5cdFx0XHRcdFx0PyB0LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcclxuXHRcdFx0XHRcdDogdC5ib2R5LnNjcm9sbFRvcCxcclxuXHRcdH07XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGModCwgZSkge1xyXG5cdFx0cmV0dXJuIDEwMCAvIChlIC0gdCk7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIHAodCwgZSwgcikge1xyXG5cdFx0cmV0dXJuICgxMDAgKiBlKSAvICh0W3IgKyAxXSAtIHRbcl0pO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBmKHQsIGUpIHtcclxuXHRcdGZvciAodmFyIHIgPSAxOyB0ID49IGVbcl07ICkgciArPSAxO1xyXG5cdFx0cmV0dXJuIHI7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIHIodCwgZSwgcikge1xyXG5cdFx0aWYgKHIgPj0gdC5zbGljZSgtMSlbMF0pIHJldHVybiAxMDA7XHJcblx0XHR2YXIgbixcclxuXHRcdFx0aSxcclxuXHRcdFx0byA9IGYociwgdCksXHJcblx0XHRcdHMgPSB0W28gLSAxXSxcclxuXHRcdFx0YSA9IHRbb10sXHJcblx0XHRcdGwgPSBlW28gLSAxXSxcclxuXHRcdFx0dSA9IGVbb107XHJcblx0XHRyZXR1cm4gKFxyXG5cdFx0XHRsICtcclxuXHRcdFx0KChpID0gciksXHJcblx0XHRcdHAoKG4gPSBbcywgYV0pLCBuWzBdIDwgMCA/IGkgKyBNYXRoLmFicyhuWzBdKSA6IGkgLSBuWzBdLCAwKSAvIGMobCwgdSkpXHJcblx0XHQpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBuKHQsIGUsIHIsIG4pIHtcclxuXHRcdGlmICgxMDAgPT09IG4pIHJldHVybiBuO1xyXG5cdFx0dmFyIGksXHJcblx0XHRcdG8sXHJcblx0XHRcdHMgPSBmKG4sIHQpLFxyXG5cdFx0XHRhID0gdFtzIC0gMV0sXHJcblx0XHRcdGwgPSB0W3NdO1xyXG5cdFx0cmV0dXJuIHJcclxuXHRcdFx0PyAobCAtIGEpIC8gMiA8IG4gLSBhXHJcblx0XHRcdFx0PyBsXHJcblx0XHRcdFx0OiBhXHJcblx0XHRcdDogZVtzIC0gMV1cclxuXHRcdFx0XHQ/IHRbcyAtIDFdICsgKChpID0gbiAtIHRbcyAtIDFdKSwgKG8gPSBlW3MgLSAxXSksIE1hdGgucm91bmQoaSAvIG8pICogbylcclxuXHRcdFx0XHQ6IG47XHJcblx0fVxyXG5cdGZ1bmN0aW9uIHModCwgZSwgcikge1xyXG5cdFx0dmFyIG47XHJcblx0XHRpZiAoKFwibnVtYmVyXCIgPT0gdHlwZW9mIGUgJiYgKGUgPSBbZV0pLCAhQXJyYXkuaXNBcnJheShlKSkpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcclxuXHRcdFx0XHRcIm5vVWlTbGlkZXIgKFwiICsgbHQgKyBcIik6ICdyYW5nZScgY29udGFpbnMgaW52YWxpZCB2YWx1ZS5cIlxyXG5cdFx0XHQpO1xyXG5cdFx0aWYgKFxyXG5cdFx0XHQhbygobiA9IFwibWluXCIgPT09IHQgPyAwIDogXCJtYXhcIiA9PT0gdCA/IDEwMCA6IHBhcnNlRmxvYXQodCkpKSB8fFxyXG5cdFx0XHQhbyhlWzBdKVxyXG5cdFx0KVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIGx0ICsgXCIpOiAncmFuZ2UnIHZhbHVlIGlzbid0IG51bWVyaWMuXCIpO1xyXG5cdFx0ci54UGN0LnB1c2gobiksXHJcblx0XHRcdHIueFZhbC5wdXNoKGVbMF0pLFxyXG5cdFx0XHRuXHJcblx0XHRcdFx0PyByLnhTdGVwcy5wdXNoKCFpc05hTihlWzFdKSAmJiBlWzFdKVxyXG5cdFx0XHRcdDogaXNOYU4oZVsxXSkgfHwgKHIueFN0ZXBzWzBdID0gZVsxXSksXHJcblx0XHRcdHIueEhpZ2hlc3RDb21wbGV0ZVN0ZXAucHVzaCgwKTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gbCh0LCBlLCByKSB7XHJcblx0XHRpZiAoZSlcclxuXHRcdFx0aWYgKHIueFZhbFt0XSAhPT0gci54VmFsW3QgKyAxXSkge1xyXG5cdFx0XHRcdHIueFN0ZXBzW3RdID1cclxuXHRcdFx0XHRcdHAoW3IueFZhbFt0XSwgci54VmFsW3QgKyAxXV0sIGUsIDApIC8gYyhyLnhQY3RbdF0sIHIueFBjdFt0ICsgMV0pO1xyXG5cdFx0XHRcdHZhciBuID0gKHIueFZhbFt0ICsgMV0gLSByLnhWYWxbdF0pIC8gci54TnVtU3RlcHNbdF0sXHJcblx0XHRcdFx0XHRpID0gTWF0aC5jZWlsKE51bWJlcihuLnRvRml4ZWQoMykpIC0gMSksXHJcblx0XHRcdFx0XHRvID0gci54VmFsW3RdICsgci54TnVtU3RlcHNbdF0gKiBpO1xyXG5cdFx0XHRcdHIueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbdF0gPSBvO1xyXG5cdFx0XHR9IGVsc2Ugci54U3RlcHNbdF0gPSByLnhIaWdoZXN0Q29tcGxldGVTdGVwW3RdID0gci54VmFsW3RdO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBpKHQsIGUsIHIpIHtcclxuXHRcdHZhciBuO1xyXG5cdFx0KHRoaXMueFBjdCA9IFtdKSxcclxuXHRcdFx0KHRoaXMueFZhbCA9IFtdKSxcclxuXHRcdFx0KHRoaXMueFN0ZXBzID0gW3IgfHwgITFdKSxcclxuXHRcdFx0KHRoaXMueE51bVN0ZXBzID0gWyExXSksXHJcblx0XHRcdCh0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwID0gW10pLFxyXG5cdFx0XHQodGhpcy5zbmFwID0gZSk7XHJcblx0XHR2YXIgaSA9IFtdO1xyXG5cdFx0Zm9yIChuIGluIHQpIHQuaGFzT3duUHJvcGVydHkobikgJiYgaS5wdXNoKFt0W25dLCBuXSk7XHJcblx0XHRmb3IgKFxyXG5cdFx0XHRpLmxlbmd0aCAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBpWzBdWzBdXHJcblx0XHRcdFx0PyBpLnNvcnQoZnVuY3Rpb24gKHQsIGUpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0WzBdWzBdIC0gZVswXVswXTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdDogaS5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdFswXSAtIGVbMF07XHJcblx0XHRcdFx0fSksXHJcblx0XHRcdFx0biA9IDA7XHJcblx0XHRcdG4gPCBpLmxlbmd0aDtcclxuXHRcdFx0bisrXHJcblx0XHQpXHJcblx0XHRcdHMoaVtuXVsxXSwgaVtuXVswXSwgdGhpcyk7XHJcblx0XHRmb3IgKFxyXG5cdFx0XHR0aGlzLnhOdW1TdGVwcyA9IHRoaXMueFN0ZXBzLnNsaWNlKDApLCBuID0gMDtcclxuXHRcdFx0biA8IHRoaXMueE51bVN0ZXBzLmxlbmd0aDtcclxuXHRcdFx0bisrXHJcblx0XHQpXHJcblx0XHRcdGwobiwgdGhpcy54TnVtU3RlcHNbbl0sIHRoaXMpO1xyXG5cdH1cclxuXHQoaS5wcm90b3R5cGUuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiAodCkge1xyXG5cdFx0dmFyIGUsXHJcblx0XHRcdHIgPSBbXTtcclxuXHRcdGZvciAoZSA9IDA7IGUgPCB0aGlzLnhOdW1TdGVwcy5sZW5ndGggLSAxOyBlKyspIHtcclxuXHRcdFx0dmFyIG4gPSB0aGlzLnhOdW1TdGVwc1tlXTtcclxuXHRcdFx0aWYgKG4gJiYgKHQgLyBuKSAlIDEgIT0gMClcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXHJcblx0XHRcdFx0XHRcIm5vVWlTbGlkZXIgKFwiICtcclxuXHRcdFx0XHRcdGx0ICtcclxuXHRcdFx0XHRcdFwiKTogJ2xpbWl0JywgJ21hcmdpbicgYW5kICdwYWRkaW5nJyBvZiBcIiArXHJcblx0XHRcdFx0XHR0aGlzLnhQY3RbZV0gK1xyXG5cdFx0XHRcdFx0XCIlIHJhbmdlIG11c3QgYmUgZGl2aXNpYmxlIGJ5IHN0ZXAuXCJcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRyW2VdID0gcCh0aGlzLnhWYWwsIHQsIGUpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHI7XHJcblx0fSksXHJcblx0XHQoaS5wcm90b3R5cGUuZ2V0QWJzb2x1dGVEaXN0YW5jZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XHJcblx0XHRcdHZhciBuLFxyXG5cdFx0XHRcdGkgPSAwO1xyXG5cdFx0XHRpZiAodCA8IHRoaXMueFBjdFt0aGlzLnhQY3QubGVuZ3RoIC0gMV0pXHJcblx0XHRcdFx0Zm9yICg7IHQgPiB0aGlzLnhQY3RbaSArIDFdOyApIGkrKztcclxuXHRcdFx0ZWxzZSB0ID09PSB0aGlzLnhQY3RbdGhpcy54UGN0Lmxlbmd0aCAtIDFdICYmIChpID0gdGhpcy54UGN0Lmxlbmd0aCAtIDIpO1xyXG5cdFx0XHRyIHx8IHQgIT09IHRoaXMueFBjdFtpICsgMV0gfHwgaSsrO1xyXG5cdFx0XHR2YXIgbyA9IDEsXHJcblx0XHRcdFx0cyA9IGVbaV0sXHJcblx0XHRcdFx0YSA9IDAsXHJcblx0XHRcdFx0bCA9IDAsXHJcblx0XHRcdFx0dSA9IDAsXHJcblx0XHRcdFx0YyA9IDA7XHJcblx0XHRcdGZvciAoXHJcblx0XHRcdFx0biA9IHJcclxuXHRcdFx0XHRcdD8gKHQgLSB0aGlzLnhQY3RbaV0pIC8gKHRoaXMueFBjdFtpICsgMV0gLSB0aGlzLnhQY3RbaV0pXHJcblx0XHRcdFx0XHQ6ICh0aGlzLnhQY3RbaSArIDFdIC0gdCkgLyAodGhpcy54UGN0W2kgKyAxXSAtIHRoaXMueFBjdFtpXSk7XHJcblx0XHRcdFx0MCA8IHM7XHJcblxyXG5cdFx0XHQpXHJcblx0XHRcdFx0KGEgPSB0aGlzLnhQY3RbaSArIDEgKyBjXSAtIHRoaXMueFBjdFtpICsgY10pLFxyXG5cdFx0XHRcdFx0MTAwIDwgZVtpICsgY10gKiBvICsgMTAwIC0gMTAwICogblxyXG5cdFx0XHRcdFx0XHQ/ICgobCA9IGEgKiBuKSwgKG8gPSAocyAtIDEwMCAqIG4pIC8gZVtpICsgY10pLCAobiA9IDEpKVxyXG5cdFx0XHRcdFx0XHQ6ICgobCA9ICgoZVtpICsgY10gKiBhKSAvIDEwMCkgKiBvKSwgKG8gPSAwKSksXHJcblx0XHRcdFx0XHRyXHJcblx0XHRcdFx0XHRcdD8gKCh1IC09IGwpLCAxIDw9IHRoaXMueFBjdC5sZW5ndGggKyBjICYmIGMtLSlcclxuXHRcdFx0XHRcdFx0OiAoKHUgKz0gbCksIDEgPD0gdGhpcy54UGN0Lmxlbmd0aCAtIGMgJiYgYysrKSxcclxuXHRcdFx0XHRcdChzID0gZVtpICsgY10gKiBvKTtcclxuXHRcdFx0cmV0dXJuIHQgKyB1O1xyXG5cdFx0fSksXHJcblx0XHQoaS5wcm90b3R5cGUudG9TdGVwcGluZyA9IGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdHJldHVybiAodCA9IHIodGhpcy54VmFsLCB0aGlzLnhQY3QsIHQpKTtcclxuXHRcdH0pLFxyXG5cdFx0KGkucHJvdG90eXBlLmZyb21TdGVwcGluZyA9IGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdHJldHVybiAoZnVuY3Rpb24gKHQsIGUsIHIpIHtcclxuXHRcdFx0XHRpZiAoMTAwIDw9IHIpIHJldHVybiB0LnNsaWNlKC0xKVswXTtcclxuXHRcdFx0XHR2YXIgbixcclxuXHRcdFx0XHRcdGkgPSBmKHIsIGUpLFxyXG5cdFx0XHRcdFx0byA9IHRbaSAtIDFdLFxyXG5cdFx0XHRcdFx0cyA9IHRbaV0sXHJcblx0XHRcdFx0XHRhID0gZVtpIC0gMV0sXHJcblx0XHRcdFx0XHRsID0gZVtpXTtcclxuXHRcdFx0XHRyZXR1cm4gKG4gPSBbbywgc10pLCAoKHIgLSBhKSAqIGMoYSwgbCkgKiAoblsxXSAtIG5bMF0pKSAvIDEwMCArIG5bMF07XHJcblx0XHRcdH0pKHRoaXMueFZhbCwgdGhpcy54UGN0LCB0KTtcclxuXHRcdH0pLFxyXG5cdFx0KGkucHJvdG90eXBlLmdldFN0ZXAgPSBmdW5jdGlvbiAodCkge1xyXG5cdFx0XHRyZXR1cm4gKHQgPSBuKHRoaXMueFBjdCwgdGhpcy54U3RlcHMsIHRoaXMuc25hcCwgdCkpO1xyXG5cdFx0fSksXHJcblx0XHQoaS5wcm90b3R5cGUuZ2V0RGVmYXVsdFN0ZXAgPSBmdW5jdGlvbiAodCwgZSwgcikge1xyXG5cdFx0XHR2YXIgbiA9IGYodCwgdGhpcy54UGN0KTtcclxuXHRcdFx0cmV0dXJuIChcclxuXHRcdFx0XHQoMTAwID09PSB0IHx8IChlICYmIHQgPT09IHRoaXMueFBjdFtuIC0gMV0pKSAmJlxyXG5cdFx0XHRcdChuID0gTWF0aC5tYXgobiAtIDEsIDEpKSxcclxuXHRcdFx0XHQodGhpcy54VmFsW25dIC0gdGhpcy54VmFsW24gLSAxXSkgLyByXHJcblx0XHRcdCk7XHJcblx0XHR9KSxcclxuXHRcdChpLnByb3RvdHlwZS5nZXROZWFyYnlTdGVwcyA9IGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdHZhciBlID0gZih0LCB0aGlzLnhQY3QpO1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHN0ZXBCZWZvcmU6IHtcclxuXHRcdFx0XHRcdHN0YXJ0VmFsdWU6IHRoaXMueFZhbFtlIC0gMl0sXHJcblx0XHRcdFx0XHRzdGVwOiB0aGlzLnhOdW1TdGVwc1tlIC0gMl0sXHJcblx0XHRcdFx0XHRoaWdoZXN0U3RlcDogdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcFtlIC0gMl0sXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHR0aGlzU3RlcDoge1xyXG5cdFx0XHRcdFx0c3RhcnRWYWx1ZTogdGhpcy54VmFsW2UgLSAxXSxcclxuXHRcdFx0XHRcdHN0ZXA6IHRoaXMueE51bVN0ZXBzW2UgLSAxXSxcclxuXHRcdFx0XHRcdGhpZ2hlc3RTdGVwOiB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwW2UgLSAxXSxcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHN0ZXBBZnRlcjoge1xyXG5cdFx0XHRcdFx0c3RhcnRWYWx1ZTogdGhpcy54VmFsW2VdLFxyXG5cdFx0XHRcdFx0c3RlcDogdGhpcy54TnVtU3RlcHNbZV0sXHJcblx0XHRcdFx0XHRoaWdoZXN0U3RlcDogdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcFtlXSxcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHR9O1xyXG5cdFx0fSksXHJcblx0XHQoaS5wcm90b3R5cGUuY291bnRTdGVwRGVjaW1hbHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciB0ID0gdGhpcy54TnVtU3RlcHMubWFwKGUpO1xyXG5cdFx0XHRyZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgdCk7XHJcblx0XHR9KSxcclxuXHRcdChpLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKHQpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0U3RlcCh0aGlzLnRvU3RlcHBpbmcodCkpO1xyXG5cdFx0fSk7XHJcblx0dmFyIHUgPSB7XHJcblx0XHRcdHRvOiBmdW5jdGlvbiAodCkge1xyXG5cdFx0XHRcdHJldHVybiB2b2lkIDAgIT09IHQgJiYgdC50b0ZpeGVkKDIpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRmcm9tOiBOdW1iZXIsXHJcblx0XHR9LFxyXG5cdFx0ZCA9IHtcclxuXHRcdFx0dGFyZ2V0OiBcInRhcmdldFwiLFxyXG5cdFx0XHRiYXNlOiBcImJhc2VcIixcclxuXHRcdFx0b3JpZ2luOiBcIm9yaWdpblwiLFxyXG5cdFx0XHRoYW5kbGU6IFwiaGFuZGxlXCIsXHJcblx0XHRcdGhhbmRsZUxvd2VyOiBcImhhbmRsZS1sb3dlclwiLFxyXG5cdFx0XHRoYW5kbGVVcHBlcjogXCJoYW5kbGUtdXBwZXJcIixcclxuXHRcdFx0dG91Y2hBcmVhOiBcInRvdWNoLWFyZWFcIixcclxuXHRcdFx0aG9yaXpvbnRhbDogXCJob3Jpem9udGFsXCIsXHJcblx0XHRcdHZlcnRpY2FsOiBcInZlcnRpY2FsXCIsXHJcblx0XHRcdGJhY2tncm91bmQ6IFwiYmFja2dyb3VuZFwiLFxyXG5cdFx0XHRjb25uZWN0OiBcImNvbm5lY3RcIixcclxuXHRcdFx0Y29ubmVjdHM6IFwiY29ubmVjdHNcIixcclxuXHRcdFx0bHRyOiBcImx0clwiLFxyXG5cdFx0XHRydGw6IFwicnRsXCIsXHJcblx0XHRcdHRleHREaXJlY3Rpb25MdHI6IFwidHh0LWRpci1sdHJcIixcclxuXHRcdFx0dGV4dERpcmVjdGlvblJ0bDogXCJ0eHQtZGlyLXJ0bFwiLFxyXG5cdFx0XHRkcmFnZ2FibGU6IFwiZHJhZ2dhYmxlXCIsXHJcblx0XHRcdGRyYWc6IFwic3RhdGUtZHJhZ1wiLFxyXG5cdFx0XHR0YXA6IFwic3RhdGUtdGFwXCIsXHJcblx0XHRcdGFjdGl2ZTogXCJhY3RpdmVcIixcclxuXHRcdFx0dG9vbHRpcDogXCJ0b29sdGlwXCIsXHJcblx0XHRcdHBpcHM6IFwicGlwc1wiLFxyXG5cdFx0XHRwaXBzSG9yaXpvbnRhbDogXCJwaXBzLWhvcml6b250YWxcIixcclxuXHRcdFx0cGlwc1ZlcnRpY2FsOiBcInBpcHMtdmVydGljYWxcIixcclxuXHRcdFx0bWFya2VyOiBcIm1hcmtlclwiLFxyXG5cdFx0XHRtYXJrZXJIb3Jpem9udGFsOiBcIm1hcmtlci1ob3Jpem9udGFsXCIsXHJcblx0XHRcdG1hcmtlclZlcnRpY2FsOiBcIm1hcmtlci12ZXJ0aWNhbFwiLFxyXG5cdFx0XHRtYXJrZXJOb3JtYWw6IFwibWFya2VyLW5vcm1hbFwiLFxyXG5cdFx0XHRtYXJrZXJMYXJnZTogXCJtYXJrZXItbGFyZ2VcIixcclxuXHRcdFx0bWFya2VyU3ViOiBcIm1hcmtlci1zdWJcIixcclxuXHRcdFx0dmFsdWU6IFwidmFsdWVcIixcclxuXHRcdFx0dmFsdWVIb3Jpem9udGFsOiBcInZhbHVlLWhvcml6b250YWxcIixcclxuXHRcdFx0dmFsdWVWZXJ0aWNhbDogXCJ2YWx1ZS12ZXJ0aWNhbFwiLFxyXG5cdFx0XHR2YWx1ZU5vcm1hbDogXCJ2YWx1ZS1ub3JtYWxcIixcclxuXHRcdFx0dmFsdWVMYXJnZTogXCJ2YWx1ZS1sYXJnZVwiLFxyXG5cdFx0XHR2YWx1ZVN1YjogXCJ2YWx1ZS1zdWJcIixcclxuXHRcdH07XHJcblx0ZnVuY3Rpb24gaCh0KSB7XHJcblx0XHRpZiAoXHJcblx0XHRcdFwib2JqZWN0XCIgPT0gdHlwZW9mIChlID0gdCkgJiZcclxuXHRcdFx0XCJmdW5jdGlvblwiID09IHR5cGVvZiBlLnRvICYmXHJcblx0XHRcdFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZS5mcm9tXHJcblx0XHQpXHJcblx0XHRcdHJldHVybiAhMDtcclxuXHRcdHZhciBlO1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcIm5vVWlTbGlkZXIgKFwiICsgbHQgKyBcIik6ICdmb3JtYXQnIHJlcXVpcmVzICd0bycgYW5kICdmcm9tJyBtZXRob2RzLlwiXHJcblx0XHQpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBtKHQsIGUpIHtcclxuXHRcdGlmICghbyhlKSlcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBsdCArIFwiKTogJ3N0ZXAnIGlzIG5vdCBudW1lcmljLlwiKTtcclxuXHRcdHQuc2luZ2xlU3RlcCA9IGU7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGcodCwgZSkge1xyXG5cdFx0aWYgKCFvKGUpKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXHJcblx0XHRcdFx0XCJub1VpU2xpZGVyIChcIiArIGx0ICsgXCIpOiAna2V5Ym9hcmRQYWdlTXVsdGlwbGllcicgaXMgbm90IG51bWVyaWMuXCJcclxuXHRcdFx0KTtcclxuXHRcdHQua2V5Ym9hcmRQYWdlTXVsdGlwbGllciA9IGU7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIHYodCwgZSkge1xyXG5cdFx0aWYgKCFvKGUpKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXHJcblx0XHRcdFx0XCJub1VpU2xpZGVyIChcIiArIGx0ICsgXCIpOiAna2V5Ym9hcmREZWZhdWx0U3RlcCcgaXMgbm90IG51bWVyaWMuXCJcclxuXHRcdFx0KTtcclxuXHRcdHQua2V5Ym9hcmREZWZhdWx0U3RlcCA9IGU7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGIodCwgZSkge1xyXG5cdFx0aWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGUgfHwgQXJyYXkuaXNBcnJheShlKSlcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBsdCArIFwiKTogJ3JhbmdlJyBpcyBub3QgYW4gb2JqZWN0LlwiKTtcclxuXHRcdGlmICh2b2lkIDAgPT09IGUubWluIHx8IHZvaWQgMCA9PT0gZS5tYXgpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcclxuXHRcdFx0XHRcIm5vVWlTbGlkZXIgKFwiICsgbHQgKyBcIik6IE1pc3NpbmcgJ21pbicgb3IgJ21heCcgaW4gJ3JhbmdlJy5cIlxyXG5cdFx0XHQpO1xyXG5cdFx0aWYgKGUubWluID09PSBlLm1heClcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcdFwibm9VaVNsaWRlciAoXCIgKyBsdCArIFwiKTogJ3JhbmdlJyAnbWluJyBhbmQgJ21heCcgY2Fubm90IGJlIGVxdWFsLlwiXHJcblx0XHRcdCk7XHJcblx0XHR0LnNwZWN0cnVtID0gbmV3IGkoZSwgdC5zbmFwLCB0LnNpbmdsZVN0ZXApO1xyXG5cdH1cclxuXHRmdW5jdGlvbiB4KHQsIGUpIHtcclxuXHRcdGlmICgoKGUgPSBkdChlKSksICFBcnJheS5pc0FycmF5KGUpIHx8ICFlLmxlbmd0aCkpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgbHQgKyBcIik6ICdzdGFydCcgb3B0aW9uIGlzIGluY29ycmVjdC5cIik7XHJcblx0XHQodC5oYW5kbGVzID0gZS5sZW5ndGgpLCAodC5zdGFydCA9IGUpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBTKHQsIGUpIHtcclxuXHRcdGlmIChcImJvb2xlYW5cIiAhPSB0eXBlb2YgKHQuc25hcCA9IGUpKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXHJcblx0XHRcdFx0XCJub1VpU2xpZGVyIChcIiArIGx0ICsgXCIpOiAnc25hcCcgb3B0aW9uIG11c3QgYmUgYSBib29sZWFuLlwiXHJcblx0XHRcdCk7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIHcodCwgZSkge1xyXG5cdFx0aWYgKFwiYm9vbGVhblwiICE9IHR5cGVvZiAodC5hbmltYXRlID0gZSkpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcclxuXHRcdFx0XHRcIm5vVWlTbGlkZXIgKFwiICsgbHQgKyBcIik6ICdhbmltYXRlJyBvcHRpb24gbXVzdCBiZSBhIGJvb2xlYW4uXCJcclxuXHRcdFx0KTtcclxuXHR9XHJcblx0ZnVuY3Rpb24geSh0LCBlKSB7XHJcblx0XHRpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgKHQuYW5pbWF0aW9uRHVyYXRpb24gPSBlKSlcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcdFwibm9VaVNsaWRlciAoXCIgKyBsdCArIFwiKTogJ2FuaW1hdGlvbkR1cmF0aW9uJyBvcHRpb24gbXVzdCBiZSBhIG51bWJlci5cIlxyXG5cdFx0XHQpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBFKHQsIGUpIHtcclxuXHRcdHZhciByLFxyXG5cdFx0XHRuID0gWyExXTtcclxuXHRcdGlmIChcclxuXHRcdFx0KFwibG93ZXJcIiA9PT0gZSA/IChlID0gWyEwLCAhMV0pIDogXCJ1cHBlclwiID09PSBlICYmIChlID0gWyExLCAhMF0pLFxyXG5cdFx0XHQhMCA9PT0gZSB8fCAhMSA9PT0gZSlcclxuXHRcdCkge1xyXG5cdFx0XHRmb3IgKHIgPSAxOyByIDwgdC5oYW5kbGVzOyByKyspIG4ucHVzaChlKTtcclxuXHRcdFx0bi5wdXNoKCExKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICghQXJyYXkuaXNBcnJheShlKSB8fCAhZS5sZW5ndGggfHwgZS5sZW5ndGggIT09IHQuaGFuZGxlcyArIDEpXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcdFx0XCJub1VpU2xpZGVyIChcIiArXHJcblx0XHRcdFx0XHRsdCArXHJcblx0XHRcdFx0XHRcIik6ICdjb25uZWN0JyBvcHRpb24gZG9lc24ndCBtYXRjaCBoYW5kbGUgY291bnQuXCJcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRuID0gZTtcclxuXHRcdH1cclxuXHRcdHQuY29ubmVjdCA9IG47XHJcblx0fVxyXG5cdGZ1bmN0aW9uIEModCwgZSkge1xyXG5cdFx0c3dpdGNoIChlKSB7XHJcblx0XHRcdGNhc2UgXCJob3Jpem9udGFsXCI6XHJcblx0XHRcdFx0dC5vcnQgPSAwO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwidmVydGljYWxcIjpcclxuXHRcdFx0XHR0Lm9ydCA9IDE7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcdFx0XCJub1VpU2xpZGVyIChcIiArIGx0ICsgXCIpOiAnb3JpZW50YXRpb24nIG9wdGlvbiBpcyBpbnZhbGlkLlwiXHJcblx0XHRcdFx0KTtcclxuXHRcdH1cclxuXHR9XHJcblx0ZnVuY3Rpb24gUCh0LCBlKSB7XHJcblx0XHRpZiAoIW8oZSkpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcclxuXHRcdFx0XHRcIm5vVWlTbGlkZXIgKFwiICsgbHQgKyBcIik6ICdtYXJnaW4nIG9wdGlvbiBtdXN0IGJlIG51bWVyaWMuXCJcclxuXHRcdFx0KTtcclxuXHRcdDAgIT09IGUgJiYgKHQubWFyZ2luID0gdC5zcGVjdHJ1bS5nZXREaXN0YW5jZShlKSk7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIE4odCwgZSkge1xyXG5cdFx0aWYgKCFvKGUpKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXHJcblx0XHRcdFx0XCJub1VpU2xpZGVyIChcIiArIGx0ICsgXCIpOiAnbGltaXQnIG9wdGlvbiBtdXN0IGJlIG51bWVyaWMuXCJcclxuXHRcdFx0KTtcclxuXHRcdGlmICgoKHQubGltaXQgPSB0LnNwZWN0cnVtLmdldERpc3RhbmNlKGUpKSwgIXQubGltaXQgfHwgdC5oYW5kbGVzIDwgMikpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcclxuXHRcdFx0XHRcIm5vVWlTbGlkZXIgKFwiICtcclxuXHRcdFx0XHRsdCArXHJcblx0XHRcdFx0XCIpOiAnbGltaXQnIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBsaW5lYXIgc2xpZGVycyB3aXRoIDIgb3IgbW9yZSBoYW5kbGVzLlwiXHJcblx0XHRcdCk7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGsodCwgZSkge1xyXG5cdFx0dmFyIHI7XHJcblx0XHRpZiAoIW8oZSkgJiYgIUFycmF5LmlzQXJyYXkoZSkpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcclxuXHRcdFx0XHRcIm5vVWlTbGlkZXIgKFwiICtcclxuXHRcdFx0XHRsdCArXHJcblx0XHRcdFx0XCIpOiAncGFkZGluZycgb3B0aW9uIG11c3QgYmUgbnVtZXJpYyBvciBhcnJheSBvZiBleGFjdGx5IDIgbnVtYmVycy5cIlxyXG5cdFx0XHQpO1xyXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZSkgJiYgMiAhPT0gZS5sZW5ndGggJiYgIW8oZVswXSkgJiYgIW8oZVsxXSkpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcclxuXHRcdFx0XHRcIm5vVWlTbGlkZXIgKFwiICtcclxuXHRcdFx0XHRsdCArXHJcblx0XHRcdFx0XCIpOiAncGFkZGluZycgb3B0aW9uIG11c3QgYmUgbnVtZXJpYyBvciBhcnJheSBvZiBleGFjdGx5IDIgbnVtYmVycy5cIlxyXG5cdFx0XHQpO1xyXG5cdFx0aWYgKDAgIT09IGUpIHtcclxuXHRcdFx0Zm9yIChcclxuXHRcdFx0XHRBcnJheS5pc0FycmF5KGUpIHx8IChlID0gW2UsIGVdKSxcclxuXHRcdFx0XHRcdHQucGFkZGluZyA9IFtcclxuXHRcdFx0XHRcdFx0dC5zcGVjdHJ1bS5nZXREaXN0YW5jZShlWzBdKSxcclxuXHRcdFx0XHRcdFx0dC5zcGVjdHJ1bS5nZXREaXN0YW5jZShlWzFdKSxcclxuXHRcdFx0XHRcdF0sXHJcblx0XHRcdFx0XHRyID0gMDtcclxuXHRcdFx0XHRyIDwgdC5zcGVjdHJ1bS54TnVtU3RlcHMubGVuZ3RoIC0gMTtcclxuXHRcdFx0XHRyKytcclxuXHRcdFx0KVxyXG5cdFx0XHRcdGlmICh0LnBhZGRpbmdbMF1bcl0gPCAwIHx8IHQucGFkZGluZ1sxXVtyXSA8IDApXHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXHJcblx0XHRcdFx0XHRcdFwibm9VaVNsaWRlciAoXCIgK1xyXG5cdFx0XHRcdFx0XHRsdCArXHJcblx0XHRcdFx0XHRcdFwiKTogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyKHMpLlwiXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHR2YXIgbiA9IGVbMF0gKyBlWzFdLFxyXG5cdFx0XHRcdGkgPSB0LnNwZWN0cnVtLnhWYWxbMF07XHJcblx0XHRcdGlmICgxIDwgbiAvICh0LnNwZWN0cnVtLnhWYWxbdC5zcGVjdHJ1bS54VmFsLmxlbmd0aCAtIDFdIC0gaSkpXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcdFx0XCJub1VpU2xpZGVyIChcIiArXHJcblx0XHRcdFx0XHRsdCArXHJcblx0XHRcdFx0XHRcIik6ICdwYWRkaW5nJyBvcHRpb24gbXVzdCBub3QgZXhjZWVkIDEwMCUgb2YgdGhlIHJhbmdlLlwiXHJcblx0XHRcdFx0KTtcclxuXHRcdH1cclxuXHR9XHJcblx0ZnVuY3Rpb24gVSh0LCBlKSB7XHJcblx0XHRzd2l0Y2ggKGUpIHtcclxuXHRcdFx0Y2FzZSBcImx0clwiOlxyXG5cdFx0XHRcdHQuZGlyID0gMDtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBcInJ0bFwiOlxyXG5cdFx0XHRcdHQuZGlyID0gMTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXHJcblx0XHRcdFx0XHRcIm5vVWlTbGlkZXIgKFwiICsgbHQgKyBcIik6ICdkaXJlY3Rpb24nIG9wdGlvbiB3YXMgbm90IHJlY29nbml6ZWQuXCJcclxuXHRcdFx0XHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRmdW5jdGlvbiBBKHQsIGUpIHtcclxuXHRcdGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiBlKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXHJcblx0XHRcdFx0XCJub1VpU2xpZGVyIChcIiArXHJcblx0XHRcdFx0bHQgK1xyXG5cdFx0XHRcdFwiKTogJ2JlaGF2aW91cicgbXVzdCBiZSBhIHN0cmluZyBjb250YWluaW5nIG9wdGlvbnMuXCJcclxuXHRcdFx0KTtcclxuXHRcdHZhciByID0gMCA8PSBlLmluZGV4T2YoXCJ0YXBcIiksXHJcblx0XHRcdG4gPSAwIDw9IGUuaW5kZXhPZihcImRyYWdcIiksXHJcblx0XHRcdGkgPSAwIDw9IGUuaW5kZXhPZihcImZpeGVkXCIpLFxyXG5cdFx0XHRvID0gMCA8PSBlLmluZGV4T2YoXCJzbmFwXCIpLFxyXG5cdFx0XHRzID0gMCA8PSBlLmluZGV4T2YoXCJob3ZlclwiKSxcclxuXHRcdFx0YSA9IDAgPD0gZS5pbmRleE9mKFwidW5jb25zdHJhaW5lZFwiKTtcclxuXHRcdGlmIChpKSB7XHJcblx0XHRcdGlmICgyICE9PSB0LmhhbmRsZXMpXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcdFx0XCJub1VpU2xpZGVyIChcIiArXHJcblx0XHRcdFx0XHRsdCArXHJcblx0XHRcdFx0XHRcIik6ICdmaXhlZCcgYmVoYXZpb3VyIG11c3QgYmUgdXNlZCB3aXRoIDIgaGFuZGxlc1wiXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0UCh0LCB0LnN0YXJ0WzFdIC0gdC5zdGFydFswXSk7XHJcblx0XHR9XHJcblx0XHRpZiAoYSAmJiAodC5tYXJnaW4gfHwgdC5saW1pdCkpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcclxuXHRcdFx0XHRcIm5vVWlTbGlkZXIgKFwiICtcclxuXHRcdFx0XHRsdCArXHJcblx0XHRcdFx0XCIpOiAndW5jb25zdHJhaW5lZCcgYmVoYXZpb3VyIGNhbm5vdCBiZSB1c2VkIHdpdGggbWFyZ2luIG9yIGxpbWl0XCJcclxuXHRcdFx0KTtcclxuXHRcdHQuZXZlbnRzID0ge1xyXG5cdFx0XHR0YXA6IHIgfHwgbyxcclxuXHRcdFx0ZHJhZzogbixcclxuXHRcdFx0Zml4ZWQ6IGksXHJcblx0XHRcdHNuYXA6IG8sXHJcblx0XHRcdGhvdmVyOiBzLFxyXG5cdFx0XHR1bmNvbnN0cmFpbmVkOiBhLFxyXG5cdFx0fTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gVih0LCBlKSB7XHJcblx0XHRpZiAoITEgIT09IGUpXHJcblx0XHRcdGlmICghMCA9PT0gZSkge1xyXG5cdFx0XHRcdHQudG9vbHRpcHMgPSBbXTtcclxuXHRcdFx0XHRmb3IgKHZhciByID0gMDsgciA8IHQuaGFuZGxlczsgcisrKSB0LnRvb2x0aXBzLnB1c2goITApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmICgoKHQudG9vbHRpcHMgPSBkdChlKSksIHQudG9vbHRpcHMubGVuZ3RoICE9PSB0LmhhbmRsZXMpKVxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcdFx0XHRcIm5vVWlTbGlkZXIgKFwiICsgbHQgKyBcIik6IG11c3QgcGFzcyBhIGZvcm1hdHRlciBmb3IgYWxsIGhhbmRsZXMuXCJcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0dC50b29sdGlwcy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdFx0XHRpZiAoXHJcblx0XHRcdFx0XHRcdFwiYm9vbGVhblwiICE9IHR5cGVvZiB0ICYmXHJcblx0XHRcdFx0XHRcdChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8IFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdC50bylcclxuXHRcdFx0XHRcdClcclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcdFx0XHRcdFwibm9VaVNsaWRlciAoXCIgK1xyXG5cdFx0XHRcdFx0XHRcdGx0ICtcclxuXHRcdFx0XHRcdFx0XHRcIik6ICd0b29sdGlwcycgbXVzdCBiZSBwYXNzZWQgYSBmb3JtYXR0ZXIgb3IgJ2ZhbHNlJy5cIlxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0fVxyXG5cdGZ1bmN0aW9uIEQodCwgZSkge1xyXG5cdFx0aCgodC5hcmlhRm9ybWF0ID0gZSkpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBNKHQsIGUpIHtcclxuXHRcdGgoKHQuZm9ybWF0ID0gZSkpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBPKHQsIGUpIHtcclxuXHRcdGlmIChcImJvb2xlYW5cIiAhPSB0eXBlb2YgKHQua2V5Ym9hcmRTdXBwb3J0ID0gZSkpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcclxuXHRcdFx0XHRcIm5vVWlTbGlkZXIgKFwiICsgbHQgKyBcIik6ICdrZXlib2FyZFN1cHBvcnQnIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi5cIlxyXG5cdFx0XHQpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBMKHQsIGUpIHtcclxuXHRcdHQuZG9jdW1lbnRFbGVtZW50ID0gZTtcclxuXHR9XHJcblx0ZnVuY3Rpb24geih0LCBlKSB7XHJcblx0XHRpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSAmJiAhMSAhPT0gZSlcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcdFwibm9VaVNsaWRlciAoXCIgKyBsdCArIFwiKTogJ2Nzc1ByZWZpeCcgbXVzdCBiZSBhIHN0cmluZyBvciBgZmFsc2VgLlwiXHJcblx0XHRcdCk7XHJcblx0XHR0LmNzc1ByZWZpeCA9IGU7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIEgodCwgZSkge1xyXG5cdFx0aWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGUpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcclxuXHRcdFx0XHRcIm5vVWlTbGlkZXIgKFwiICsgbHQgKyBcIik6ICdjc3NDbGFzc2VzJyBtdXN0IGJlIGFuIG9iamVjdC5cIlxyXG5cdFx0XHQpO1xyXG5cdFx0aWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQuY3NzUHJlZml4KVxyXG5cdFx0XHRmb3IgKHZhciByIGluICgodC5jc3NDbGFzc2VzID0ge30pLCBlKSlcclxuXHRcdFx0XHRlLmhhc093blByb3BlcnR5KHIpICYmICh0LmNzc0NsYXNzZXNbcl0gPSB0LmNzc1ByZWZpeCArIGVbcl0pO1xyXG5cdFx0ZWxzZSB0LmNzc0NsYXNzZXMgPSBlO1xyXG5cdH1cclxuXHRmdW5jdGlvbiB2dChlKSB7XHJcblx0XHR2YXIgciA9IHtcclxuXHRcdFx0XHRtYXJnaW46IDAsXHJcblx0XHRcdFx0bGltaXQ6IDAsXHJcblx0XHRcdFx0cGFkZGluZzogMCxcclxuXHRcdFx0XHRhbmltYXRlOiAhMCxcclxuXHRcdFx0XHRhbmltYXRpb25EdXJhdGlvbjogMzAwLFxyXG5cdFx0XHRcdGFyaWFGb3JtYXQ6IHUsXHJcblx0XHRcdFx0Zm9ybWF0OiB1LFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRuID0ge1xyXG5cdFx0XHRcdHN0ZXA6IHsgcjogITEsIHQ6IG0gfSxcclxuXHRcdFx0XHRrZXlib2FyZFBhZ2VNdWx0aXBsaWVyOiB7IHI6ICExLCB0OiBnIH0sXHJcblx0XHRcdFx0a2V5Ym9hcmREZWZhdWx0U3RlcDogeyByOiAhMSwgdDogdiB9LFxyXG5cdFx0XHRcdHN0YXJ0OiB7IHI6ICEwLCB0OiB4IH0sXHJcblx0XHRcdFx0Y29ubmVjdDogeyByOiAhMCwgdDogRSB9LFxyXG5cdFx0XHRcdGRpcmVjdGlvbjogeyByOiAhMCwgdDogVSB9LFxyXG5cdFx0XHRcdHNuYXA6IHsgcjogITEsIHQ6IFMgfSxcclxuXHRcdFx0XHRhbmltYXRlOiB7IHI6ICExLCB0OiB3IH0sXHJcblx0XHRcdFx0YW5pbWF0aW9uRHVyYXRpb246IHsgcjogITEsIHQ6IHkgfSxcclxuXHRcdFx0XHRyYW5nZTogeyByOiAhMCwgdDogYiB9LFxyXG5cdFx0XHRcdG9yaWVudGF0aW9uOiB7IHI6ICExLCB0OiBDIH0sXHJcblx0XHRcdFx0bWFyZ2luOiB7IHI6ICExLCB0OiBQIH0sXHJcblx0XHRcdFx0bGltaXQ6IHsgcjogITEsIHQ6IE4gfSxcclxuXHRcdFx0XHRwYWRkaW5nOiB7IHI6ICExLCB0OiBrIH0sXHJcblx0XHRcdFx0YmVoYXZpb3VyOiB7IHI6ICEwLCB0OiBBIH0sXHJcblx0XHRcdFx0YXJpYUZvcm1hdDogeyByOiAhMSwgdDogRCB9LFxyXG5cdFx0XHRcdGZvcm1hdDogeyByOiAhMSwgdDogTSB9LFxyXG5cdFx0XHRcdHRvb2x0aXBzOiB7IHI6ICExLCB0OiBWIH0sXHJcblx0XHRcdFx0a2V5Ym9hcmRTdXBwb3J0OiB7IHI6ICEwLCB0OiBPIH0sXHJcblx0XHRcdFx0ZG9jdW1lbnRFbGVtZW50OiB7IHI6ICExLCB0OiBMIH0sXHJcblx0XHRcdFx0Y3NzUHJlZml4OiB7IHI6ICEwLCB0OiB6IH0sXHJcblx0XHRcdFx0Y3NzQ2xhc3NlczogeyByOiAhMCwgdDogSCB9LFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRpID0ge1xyXG5cdFx0XHRcdGNvbm5lY3Q6ICExLFxyXG5cdFx0XHRcdGRpcmVjdGlvbjogXCJsdHJcIixcclxuXHRcdFx0XHRiZWhhdmlvdXI6IFwidGFwXCIsXHJcblx0XHRcdFx0b3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxyXG5cdFx0XHRcdGtleWJvYXJkU3VwcG9ydDogITAsXHJcblx0XHRcdFx0Y3NzUHJlZml4OiBcIm5vVWktXCIsXHJcblx0XHRcdFx0Y3NzQ2xhc3NlczogZCxcclxuXHRcdFx0XHRrZXlib2FyZFBhZ2VNdWx0aXBsaWVyOiA1LFxyXG5cdFx0XHRcdGtleWJvYXJkRGVmYXVsdFN0ZXA6IDEwLFxyXG5cdFx0XHR9O1xyXG5cdFx0ZS5mb3JtYXQgJiYgIWUuYXJpYUZvcm1hdCAmJiAoZS5hcmlhRm9ybWF0ID0gZS5mb3JtYXQpLFxyXG5cdFx0XHRPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdFx0aWYgKCFhKGVbdF0pICYmIHZvaWQgMCA9PT0gaVt0XSkge1xyXG5cdFx0XHRcdFx0aWYgKG5bdF0ucilcclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcdFx0XHRcdFwibm9VaVNsaWRlciAoXCIgKyBsdCArIFwiKTogJ1wiICsgdCArIFwiJyBpcyByZXF1aXJlZC5cIlxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0cmV0dXJuICEwO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRuW3RdLnQociwgYShlW3RdKSA/IGVbdF0gOiBpW3RdKTtcclxuXHRcdFx0fSksXHJcblx0XHRcdChyLnBpcHMgPSBlLnBpcHMpO1xyXG5cdFx0dmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxyXG5cdFx0XHRvID0gdm9pZCAwICE9PSB0LnN0eWxlLm1zVHJhbnNmb3JtLFxyXG5cdFx0XHRzID0gdm9pZCAwICE9PSB0LnN0eWxlLnRyYW5zZm9ybTtcclxuXHRcdHIudHJhbnNmb3JtUnVsZSA9IHMgPyBcInRyYW5zZm9ybVwiIDogbyA/IFwibXNUcmFuc2Zvcm1cIiA6IFwid2Via2l0VHJhbnNmb3JtXCI7XHJcblx0XHRyZXR1cm4gKFxyXG5cdFx0XHQoci5zdHlsZSA9IFtcclxuXHRcdFx0XHRbXCJsZWZ0XCIsIFwidG9wXCJdLFxyXG5cdFx0XHRcdFtcInJpZ2h0XCIsIFwiYm90dG9tXCJdLFxyXG5cdFx0XHRdW3IuZGlyXVtyLm9ydF0pLFxyXG5cdFx0XHRcdHJcclxuXHRcdCk7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGoodCwgYiwgbykge1xyXG5cdFx0dmFyIGwsXHJcblx0XHRcdHUsXHJcblx0XHRcdHMsXHJcblx0XHRcdGMsXHJcblx0XHRcdGksXHJcblx0XHRcdGEsXHJcblx0XHRcdGUsXHJcblx0XHRcdHAsXHJcblx0XHRcdGYgPSB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkXHJcblx0XHRcdFx0PyB7IHN0YXJ0OiBcInBvaW50ZXJkb3duXCIsIG1vdmU6IFwicG9pbnRlcm1vdmVcIiwgZW5kOiBcInBvaW50ZXJ1cFwiIH1cclxuXHRcdFx0XHQ6IHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZFxyXG5cdFx0XHRcdFx0PyB7IHN0YXJ0OiBcIk1TUG9pbnRlckRvd25cIiwgbW92ZTogXCJNU1BvaW50ZXJNb3ZlXCIsIGVuZDogXCJNU1BvaW50ZXJVcFwiIH1cclxuXHRcdFx0XHRcdDoge1xyXG5cdFx0XHRcdFx0XHRzdGFydDogXCJtb3VzZWRvd24gdG91Y2hzdGFydFwiLFxyXG5cdFx0XHRcdFx0XHRtb3ZlOiBcIm1vdXNlbW92ZSB0b3VjaG1vdmVcIixcclxuXHRcdFx0XHRcdFx0ZW5kOiBcIm1vdXNldXAgdG91Y2hlbmRcIixcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdGQgPVxyXG5cdFx0XHRcdHdpbmRvdy5DU1MgJiZcclxuXHRcdFx0XHRDU1Muc3VwcG9ydHMgJiZcclxuXHRcdFx0XHRDU1Muc3VwcG9ydHMoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpICYmXHJcblx0XHRcdFx0KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdHZhciB0ID0gITE7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHR2YXIgZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJwYXNzaXZlXCIsIHtcclxuXHRcdFx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHQgPSAhMDtcclxuXHRcdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIG51bGwsIGUpO1xyXG5cdFx0XHRcdFx0fSBjYXRjaCAodCkge31cclxuXHRcdFx0XHRcdHJldHVybiB0O1xyXG5cdFx0XHRcdH0pKCksXHJcblx0XHRcdGggPSB0LFxyXG5cdFx0XHR5ID0gYi5zcGVjdHJ1bSxcclxuXHRcdFx0eCA9IFtdLFxyXG5cdFx0XHRTID0gW10sXHJcblx0XHRcdG0gPSBbXSxcclxuXHRcdFx0ZyA9IDAsXHJcblx0XHRcdHYgPSB7fSxcclxuXHRcdFx0dyA9IHQub3duZXJEb2N1bWVudCxcclxuXHRcdFx0RSA9IGIuZG9jdW1lbnRFbGVtZW50IHx8IHcuZG9jdW1lbnRFbGVtZW50LFxyXG5cdFx0XHRDID0gdy5ib2R5LFxyXG5cdFx0XHRQID0gLTEsXHJcblx0XHRcdE4gPSAwLFxyXG5cdFx0XHRrID0gMSxcclxuXHRcdFx0VSA9IDIsXHJcblx0XHRcdEEgPSBcInJ0bFwiID09PSB3LmRpciB8fCAxID09PSBiLm9ydCA/IDAgOiAxMDA7XHJcblx0XHRmdW5jdGlvbiBWKHQsIGUpIHtcclxuXHRcdFx0dmFyIHIgPSB3LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblx0XHRcdHJldHVybiBlICYmIGh0KHIsIGUpLCB0LmFwcGVuZENoaWxkKHIpLCByO1xyXG5cdFx0fVxyXG5cdFx0ZnVuY3Rpb24gRCh0LCBlKSB7XHJcblx0XHRcdHZhciByID0gVih0LCBiLmNzc0NsYXNzZXMub3JpZ2luKSxcclxuXHRcdFx0XHRuID0gVihyLCBiLmNzc0NsYXNzZXMuaGFuZGxlKTtcclxuXHRcdFx0cmV0dXJuIChcclxuXHRcdFx0XHRWKG4sIGIuY3NzQ2xhc3Nlcy50b3VjaEFyZWEpLFxyXG5cdFx0XHRcdFx0bi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWhhbmRsZVwiLCBlKSxcclxuXHRcdFx0XHRiLmtleWJvYXJkU3VwcG9ydCAmJlxyXG5cdFx0XHRcdChuLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKSxcclxuXHRcdFx0XHRcdG4uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZnVuY3Rpb24gKHQpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIChmdW5jdGlvbiAodCwgZSkge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChPKCkgfHwgTChlKSkgcmV0dXJuICExO1xyXG5cdFx0XHRcdFx0XHRcdHZhciByID0gW1wiTGVmdFwiLCBcIlJpZ2h0XCJdLFxyXG5cdFx0XHRcdFx0XHRcdFx0biA9IFtcIkRvd25cIiwgXCJVcFwiXSxcclxuXHRcdFx0XHRcdFx0XHRcdGkgPSBbXCJQYWdlRG93blwiLCBcIlBhZ2VVcFwiXSxcclxuXHRcdFx0XHRcdFx0XHRcdG8gPSBbXCJIb21lXCIsIFwiRW5kXCJdO1xyXG5cdFx0XHRcdFx0XHRcdGIuZGlyICYmICFiLm9ydFxyXG5cdFx0XHRcdFx0XHRcdFx0PyByLnJldmVyc2UoKVxyXG5cdFx0XHRcdFx0XHRcdFx0OiBiLm9ydCAmJiAhYi5kaXIgJiYgKG4ucmV2ZXJzZSgpLCBpLnJldmVyc2UoKSk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHMsXHJcblx0XHRcdFx0XHRcdFx0XHRhID0gdC5rZXkucmVwbGFjZShcIkFycm93XCIsIFwiXCIpLFxyXG5cdFx0XHRcdFx0XHRcdFx0bCA9IGEgPT09IGlbMF0sXHJcblx0XHRcdFx0XHRcdFx0XHR1ID0gYSA9PT0gaVsxXSxcclxuXHRcdFx0XHRcdFx0XHRcdGMgPSBhID09PSBuWzBdIHx8IGEgPT09IHJbMF0gfHwgbCxcclxuXHRcdFx0XHRcdFx0XHRcdHAgPSBhID09PSBuWzFdIHx8IGEgPT09IHJbMV0gfHwgdSxcclxuXHRcdFx0XHRcdFx0XHRcdGYgPSBhID09PSBvWzBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZCA9IGEgPT09IG9bMV07XHJcblx0XHRcdFx0XHRcdFx0aWYgKCEoYyB8fCBwIHx8IGYgfHwgZCkpIHJldHVybiAhMDtcclxuXHRcdFx0XHRcdFx0XHRpZiAoKHQucHJldmVudERlZmF1bHQoKSwgcCB8fCBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGggPSBiLmtleWJvYXJkUGFnZU11bHRpcGxpZXIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdG0gPSBjID8gMCA6IDEsXHJcblx0XHRcdFx0XHRcdFx0XHRcdGcgPSBhdChlKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0diA9IGdbbV07XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAobnVsbCA9PT0gdikgcmV0dXJuICExO1xyXG5cdFx0XHRcdFx0XHRcdFx0ITEgPT09IHYgJiZcclxuXHRcdFx0XHRcdFx0XHRcdCh2ID0geS5nZXREZWZhdWx0U3RlcChTW2VdLCBjLCBiLmtleWJvYXJkRGVmYXVsdFN0ZXApKSxcclxuXHRcdFx0XHRcdFx0XHRcdCh1IHx8IGwpICYmICh2ICo9IGgpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQodiA9IE1hdGgubWF4KHYsIDFlLTcpKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0KHYgKj0gYyA/IC0xIDogMSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdChzID0geFtlXSArIHYpO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBzID0gZCA/IGIuc3BlY3RydW0ueFZhbFtiLnNwZWN0cnVtLnhWYWwubGVuZ3RoIC0gMV0gOiBiLnNwZWN0cnVtLnhWYWxbMF07XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChcclxuXHRcdFx0XHRcdFx0XHRcdHJ0KGUsIHkudG9TdGVwcGluZyhzKSwgITAsICEwKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0SihcInNsaWRlXCIsIGUpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRKKFwidXBkYXRlXCIsIGUpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRKKFwiY2hhbmdlXCIsIGUpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRKKFwic2V0XCIsIGUpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQhMVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdH0pKHQsIGUpO1xyXG5cdFx0XHRcdFx0fSkpLFxyXG5cdFx0XHRcdFx0bi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwic2xpZGVyXCIpLFxyXG5cdFx0XHRcdFx0bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLW9yaWVudGF0aW9uXCIsIGIub3J0ID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCIpLFxyXG5cdFx0XHRcdFx0MCA9PT0gZVxyXG5cdFx0XHRcdFx0XHQ/IGh0KG4sIGIuY3NzQ2xhc3Nlcy5oYW5kbGVMb3dlcilcclxuXHRcdFx0XHRcdFx0OiBlID09PSBiLmhhbmRsZXMgLSAxICYmIGh0KG4sIGIuY3NzQ2xhc3Nlcy5oYW5kbGVVcHBlciksXHJcblx0XHRcdFx0XHRyXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblx0XHRmdW5jdGlvbiBNKHQsIGUpIHtcclxuXHRcdFx0cmV0dXJuICEhZSAmJiBWKHQsIGIuY3NzQ2xhc3Nlcy5jb25uZWN0KTtcclxuXHRcdH1cclxuXHRcdGZ1bmN0aW9uIHIodCwgZSkge1xyXG5cdFx0XHRyZXR1cm4gISFiLnRvb2x0aXBzW2VdICYmIFYodC5maXJzdENoaWxkLCBiLmNzc0NsYXNzZXMudG9vbHRpcCk7XHJcblx0XHR9XHJcblx0XHRmdW5jdGlvbiBPKCkge1xyXG5cdFx0XHRyZXR1cm4gaC5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcclxuXHRcdH1cclxuXHRcdGZ1bmN0aW9uIEwodCkge1xyXG5cdFx0XHRyZXR1cm4gdVt0XS5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcclxuXHRcdH1cclxuXHRcdGZ1bmN0aW9uIHooKSB7XHJcblx0XHRcdGkgJiZcclxuXHRcdFx0KEcoXCJ1cGRhdGUudG9vbHRpcHNcIiksXHJcblx0XHRcdFx0aS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdFx0XHR0ICYmIHV0KHQpO1xyXG5cdFx0XHRcdH0pLFxyXG5cdFx0XHRcdChpID0gbnVsbCkpO1xyXG5cdFx0fVxyXG5cdFx0ZnVuY3Rpb24gSCgpIHtcclxuXHRcdFx0eigpLFxyXG5cdFx0XHRcdChpID0gdS5tYXAocikpLFxyXG5cdFx0XHRcdCQoXCJ1cGRhdGUudG9vbHRpcHNcIiwgZnVuY3Rpb24gKHQsIGUsIHIpIHtcclxuXHRcdFx0XHRcdGlmIChpW2VdKSB7XHJcblx0XHRcdFx0XHRcdHZhciBuID0gdFtlXTtcclxuXHRcdFx0XHRcdFx0ITAgIT09IGIudG9vbHRpcHNbZV0gJiYgKG4gPSBiLnRvb2x0aXBzW2VdLnRvKHJbZV0pKSxcclxuXHRcdFx0XHRcdFx0XHQoaVtlXS5pbm5lckhUTUwgPSBuKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdGZ1bmN0aW9uIGooZSwgaSwgbykge1xyXG5cdFx0XHR2YXIgcyA9IHcuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcclxuXHRcdFx0XHRhID0gW107XHJcblx0XHRcdChhW05dID0gYi5jc3NDbGFzc2VzLnZhbHVlTm9ybWFsKSxcclxuXHRcdFx0XHQoYVtrXSA9IGIuY3NzQ2xhc3Nlcy52YWx1ZUxhcmdlKSxcclxuXHRcdFx0XHQoYVtVXSA9IGIuY3NzQ2xhc3Nlcy52YWx1ZVN1Yik7XHJcblx0XHRcdHZhciBsID0gW107XHJcblx0XHRcdChsW05dID0gYi5jc3NDbGFzc2VzLm1hcmtlck5vcm1hbCksXHJcblx0XHRcdFx0KGxba10gPSBiLmNzc0NsYXNzZXMubWFya2VyTGFyZ2UpLFxyXG5cdFx0XHRcdChsW1VdID0gYi5jc3NDbGFzc2VzLm1hcmtlclN1Yik7XHJcblx0XHRcdHZhciB1ID0gW2IuY3NzQ2xhc3Nlcy52YWx1ZUhvcml6b250YWwsIGIuY3NzQ2xhc3Nlcy52YWx1ZVZlcnRpY2FsXSxcclxuXHRcdFx0XHRjID0gW2IuY3NzQ2xhc3Nlcy5tYXJrZXJIb3Jpem9udGFsLCBiLmNzc0NsYXNzZXMubWFya2VyVmVydGljYWxdO1xyXG5cdFx0XHRmdW5jdGlvbiBwKHQsIGUpIHtcclxuXHRcdFx0XHR2YXIgciA9IGUgPT09IGIuY3NzQ2xhc3Nlcy52YWx1ZSxcclxuXHRcdFx0XHRcdG4gPSByID8gYSA6IGw7XHJcblx0XHRcdFx0cmV0dXJuIGUgKyBcIiBcIiArIChyID8gdSA6IGMpW2Iub3J0XSArIFwiIFwiICsgblt0XTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcdGh0KHMsIGIuY3NzQ2xhc3Nlcy5waXBzKSxcclxuXHRcdFx0XHRcdGh0KFxyXG5cdFx0XHRcdFx0XHRzLFxyXG5cdFx0XHRcdFx0XHQwID09PSBiLm9ydCA/IGIuY3NzQ2xhc3Nlcy5waXBzSG9yaXpvbnRhbCA6IGIuY3NzQ2xhc3Nlcy5waXBzVmVydGljYWxcclxuXHRcdFx0XHRcdCksXHJcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdFx0XHRcdCEoZnVuY3Rpb24gKHQsIGUsIHIpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoKHIgPSBpID8gaShlLCByKSA6IHIpICE9PSBQKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgbiA9IFYocywgITEpO1xyXG5cdFx0XHRcdFx0XHRcdFx0KG4uY2xhc3NOYW1lID0gcChyLCBiLmNzc0NsYXNzZXMubWFya2VyKSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdChuLnN0eWxlW2Iuc3R5bGVdID0gdCArIFwiJVwiKSxcclxuXHRcdFx0XHRcdFx0XHRcdE4gPCByICYmXHJcblx0XHRcdFx0XHRcdFx0XHQoKChuID0gVihzLCAhMSkpLmNsYXNzTmFtZSA9IHAociwgYi5jc3NDbGFzc2VzLnZhbHVlKSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdG4uc2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiLCBlKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0KG4uc3R5bGVbYi5zdHlsZV0gPSB0ICsgXCIlXCIpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQobi5pbm5lckhUTUwgPSBvLnRvKGUpKSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9KSh0LCBlW3RdWzBdLCBlW3RdWzFdKTtcclxuXHRcdFx0XHRcdH0pLFxyXG5cdFx0XHRcdFx0c1xyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cdFx0ZnVuY3Rpb24gRigpIHtcclxuXHRcdFx0YyAmJiAodXQoYyksIChjID0gbnVsbCkpO1xyXG5cdFx0fVxyXG5cdFx0ZnVuY3Rpb24gUih0KSB7XHJcblx0XHRcdEYoKTtcclxuXHRcdFx0dmFyIG0sXHJcblx0XHRcdFx0ZyxcclxuXHRcdFx0XHR2LFxyXG5cdFx0XHRcdGIsXHJcblx0XHRcdFx0ZSxcclxuXHRcdFx0XHRyLFxyXG5cdFx0XHRcdHgsXHJcblx0XHRcdFx0UyxcclxuXHRcdFx0XHR3LFxyXG5cdFx0XHRcdG4gPSB0Lm1vZGUsXHJcblx0XHRcdFx0aSA9IHQuZGVuc2l0eSB8fCAxLFxyXG5cdFx0XHRcdG8gPSB0LmZpbHRlciB8fCAhMSxcclxuXHRcdFx0XHRzID0gKGZ1bmN0aW9uICh0LCBlLCByKSB7XHJcblx0XHRcdFx0XHRpZiAoXCJyYW5nZVwiID09PSB0IHx8IFwic3RlcHNcIiA9PT0gdCkgcmV0dXJuIHkueFZhbDtcclxuXHRcdFx0XHRcdGlmIChcImNvdW50XCIgPT09IHQpIHtcclxuXHRcdFx0XHRcdFx0aWYgKGUgPCAyKVxyXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcclxuXHRcdFx0XHRcdFx0XHRcdFwibm9VaVNsaWRlciAoXCIgK1xyXG5cdFx0XHRcdFx0XHRcdFx0bHQgK1xyXG5cdFx0XHRcdFx0XHRcdFx0XCIpOiAndmFsdWVzJyAoPj0gMikgcmVxdWlyZWQgZm9yIG1vZGUgJ2NvdW50Jy5cIlxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdHZhciBuID0gZSAtIDEsXHJcblx0XHRcdFx0XHRcdFx0aSA9IDEwMCAvIG47XHJcblx0XHRcdFx0XHRcdGZvciAoZSA9IFtdOyBuLS07ICkgZVtuXSA9IG4gKiBpO1xyXG5cdFx0XHRcdFx0XHRlLnB1c2goMTAwKSwgKHQgPSBcInBvc2l0aW9uc1wiKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBcInBvc2l0aW9uc1wiID09PSB0XHJcblx0XHRcdFx0XHRcdD8gZS5tYXAoZnVuY3Rpb24gKHQpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4geS5mcm9tU3RlcHBpbmcociA/IHkuZ2V0U3RlcCh0KSA6IHQpO1xyXG5cdFx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0XHQ6IFwidmFsdWVzXCIgPT09IHRcclxuXHRcdFx0XHRcdFx0XHQ/IHJcclxuXHRcdFx0XHRcdFx0XHRcdD8gZS5tYXAoZnVuY3Rpb24gKHQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHkuZnJvbVN0ZXBwaW5nKHkuZ2V0U3RlcCh5LnRvU3RlcHBpbmcodCkpKTtcclxuXHRcdFx0XHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHRcdFx0XHQ6IGVcclxuXHRcdFx0XHRcdFx0XHQ6IHZvaWQgMDtcclxuXHRcdFx0XHR9KShuLCB0LnZhbHVlcyB8fCAhMSwgdC5zdGVwcGVkIHx8ICExKSxcclxuXHRcdFx0XHRhID1cclxuXHRcdFx0XHRcdCgobSA9IGkpLFxyXG5cdFx0XHRcdFx0XHQoZyA9IG4pLFxyXG5cdFx0XHRcdFx0XHQodiA9IHMpLFxyXG5cdFx0XHRcdFx0XHQoYiA9IHt9KSxcclxuXHRcdFx0XHRcdFx0KGUgPSB5LnhWYWxbMF0pLFxyXG5cdFx0XHRcdFx0XHQociA9IHkueFZhbFt5LnhWYWwubGVuZ3RoIC0gMV0pLFxyXG5cdFx0XHRcdFx0XHQoUyA9IHggPSAhMSksXHJcblx0XHRcdFx0XHRcdCh3ID0gMCksXHJcblx0XHRcdFx0XHQodiA9IHZcclxuXHRcdFx0XHRcdC5zbGljZSgpXHJcblx0XHRcdFx0XHQuc29ydChmdW5jdGlvbiAodCwgZSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdCAtIGU7XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbiAodCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gIXRoaXNbdF0gJiYgKHRoaXNbdF0gPSAhMCk7XHJcblx0XHRcdFx0XHR9LCB7fSkpWzBdICE9PSBlICYmICh2LnVuc2hpZnQoZSksICh4ID0gITApKSxcclxuXHRcdFx0XHRcdHZbdi5sZW5ndGggLSAxXSAhPT0gciAmJiAodi5wdXNoKHIpLCAoUyA9ICEwKSksXHJcblx0XHRcdFx0XHRcdHYuZm9yRWFjaChmdW5jdGlvbiAodCwgZSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciByLFxyXG5cdFx0XHRcdFx0XHRcdFx0bixcclxuXHRcdFx0XHRcdFx0XHRcdGksXHJcblx0XHRcdFx0XHRcdFx0XHRvLFxyXG5cdFx0XHRcdFx0XHRcdFx0cyxcclxuXHRcdFx0XHRcdFx0XHRcdGEsXHJcblx0XHRcdFx0XHRcdFx0XHRsLFxyXG5cdFx0XHRcdFx0XHRcdFx0dSxcclxuXHRcdFx0XHRcdFx0XHRcdGMsXHJcblx0XHRcdFx0XHRcdFx0XHRwLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZiA9IHQsXHJcblx0XHRcdFx0XHRcdFx0XHRkID0gdltlICsgMV0sXHJcblx0XHRcdFx0XHRcdFx0XHRoID0gXCJzdGVwc1wiID09PSBnO1xyXG5cdFx0XHRcdFx0XHRcdGlmICgoaCAmJiAociA9IHkueE51bVN0ZXBzW2VdKSwgciB8fCAociA9IGQgLSBmKSwgITEgIT09IGYpKVxyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChcclxuXHRcdFx0XHRcdFx0XHRcdFx0dm9pZCAwID09PSBkICYmIChkID0gZiksIHIgPSBNYXRoLm1heChyLCAxZS03KSwgbiA9IGY7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG4gPD0gZDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0biA9IChuICsgcikudG9GaXhlZCg3KSAvIDFcclxuXHRcdFx0XHRcdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IgKFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHUgPSAocyA9IChvID0geS50b1N0ZXBwaW5nKG4pKSAtIHcpIC8gbSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHAgPSBzIC8gKGMgPSBNYXRoLnJvdW5kKHUpKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGkgPSAxO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGkgPD0gYztcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpICs9IDFcclxuXHRcdFx0XHRcdFx0XHRcdFx0KVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJbKGEgPSB3ICsgaSAqIHApLnRvRml4ZWQoNSldID0gW3kuZnJvbVN0ZXBwaW5nKGEpLCAwXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0KGwgPSAtMSA8IHYuaW5kZXhPZihuKSA/IGsgOiBoID8gVSA6IE4pLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQhZSAmJiB4ICYmIG4gIT09IGQgJiYgKGwgPSAwKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0KG4gPT09IGQgJiYgUykgfHwgKGJbby50b0ZpeGVkKDUpXSA9IFtuLCBsXSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0KHcgPSBvKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSksXHJcblx0XHRcdFx0XHRcdGIpLFxyXG5cdFx0XHRcdGwgPSB0LmZvcm1hdCB8fCB7IHRvOiBNYXRoLnJvdW5kIH07XHJcblx0XHRcdHJldHVybiAoYyA9IGguYXBwZW5kQ2hpbGQoaihhLCBvLCBsKSkpO1xyXG5cdFx0fVxyXG5cdFx0ZnVuY3Rpb24gVCgpIHtcclxuXHRcdFx0dmFyIHQgPSBsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxyXG5cdFx0XHRcdGUgPSBcIm9mZnNldFwiICsgW1wiV2lkdGhcIiwgXCJIZWlnaHRcIl1bYi5vcnRdO1xyXG5cdFx0XHRyZXR1cm4gMCA9PT0gYi5vcnQgPyB0LndpZHRoIHx8IGxbZV0gOiB0LmhlaWdodCB8fCBsW2VdO1xyXG5cdFx0fVxyXG5cdFx0ZnVuY3Rpb24gQihuLCBpLCBvLCBzKSB7XHJcblx0XHRcdHZhciBlID0gZnVuY3Rpb24gKHQpIHtcclxuXHRcdFx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0XHRcdCEhKHQgPSAoZnVuY3Rpb24gKHQsIGUsIHIpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgbixcclxuXHRcdFx0XHRcdFx0XHRcdGksXHJcblx0XHRcdFx0XHRcdFx0XHRvID0gMCA9PT0gdC50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSxcclxuXHRcdFx0XHRcdFx0XHRcdHMgPSAwID09PSB0LnR5cGUuaW5kZXhPZihcIm1vdXNlXCIpLFxyXG5cdFx0XHRcdFx0XHRcdFx0YSA9IDAgPT09IHQudHlwZS5pbmRleE9mKFwicG9pbnRlclwiKTtcclxuXHRcdFx0XHRcdFx0XHQwID09PSB0LnR5cGUuaW5kZXhPZihcIk1TUG9pbnRlclwiKSAmJiAoYSA9ICEwKTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoXCJtb3VzZWRvd25cIiA9PT0gdC50eXBlICYmICF0LmJ1dHRvbnMgJiYgIXQudG91Y2hlcykgcmV0dXJuICExO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChvKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgbCA9IGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dC50YXJnZXQgPT09IHIgfHxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyLmNvbnRhaW5zKHQudGFyZ2V0KSB8fFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCh0LnRhcmdldC5zaGFkb3dSb290ICYmIHQudGFyZ2V0LnNoYWRvd1Jvb3QuY29udGFpbnMocikpXHJcblx0XHRcdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKFwidG91Y2hzdGFydFwiID09PSB0LnR5cGUpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHUgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwodC50b3VjaGVzLCBsKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKDEgPCB1Lmxlbmd0aCkgcmV0dXJuICExO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHQobiA9IHVbMF0ucGFnZVgpLCAoaSA9IHVbMF0ucGFnZVkpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGMgPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKHQuY2hhbmdlZFRvdWNoZXMsIGwpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIWMpIHJldHVybiAhMTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0KG4gPSBjLnBhZ2VYKSwgKGkgPSBjLnBhZ2VZKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0KGUgPSBlIHx8IGd0KHcpKSxcclxuXHRcdFx0XHRcdFx0XHQocyB8fCBhKSAmJiAoKG4gPSB0LmNsaWVudFggKyBlLngpLCAoaSA9IHQuY2xpZW50WSArIGUueSkpO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0XHRcdFx0XHQodC5wYWdlT2Zmc2V0ID0gZSksICh0LnBvaW50cyA9IFtuLCBpXSksICh0LmN1cnNvciA9IHMgfHwgYSksIHRcclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0XHR9KSh0LCBzLnBhZ2VPZmZzZXQsIHMudGFyZ2V0IHx8IGkpKSAmJlxyXG5cdFx0XHRcdFx0XHQhKE8oKSAmJiAhcy5kb05vdFJlamVjdCkgJiZcclxuXHRcdFx0XHRcdFx0KChlID0gaCksXHJcblx0XHRcdFx0XHRcdFx0KHIgPSBiLmNzc0NsYXNzZXMudGFwKSxcclxuXHRcdFx0XHRcdFx0IShcclxuXHRcdFx0XHRcdFx0XHQoZS5jbGFzc0xpc3RcclxuXHRcdFx0XHRcdFx0XHRcdD8gZS5jbGFzc0xpc3QuY29udGFpbnMocilcclxuXHRcdFx0XHRcdFx0XHRcdDogbmV3IFJlZ0V4cChcIlxcXFxiXCIgKyByICsgXCJcXFxcYlwiKS50ZXN0KGUuY2xhc3NOYW1lKSkgJiZcclxuXHRcdFx0XHRcdFx0XHQhcy5kb05vdFJlamVjdFxyXG5cdFx0XHRcdFx0XHQpICYmXHJcblx0XHRcdFx0XHRcdCEobiA9PT0gZi5zdGFydCAmJiB2b2lkIDAgIT09IHQuYnV0dG9ucyAmJiAxIDwgdC5idXR0b25zKSAmJlxyXG5cdFx0XHRcdFx0XHQoIXMuaG92ZXIgfHwgIXQuYnV0dG9ucykgJiZcclxuXHRcdFx0XHRcdFx0KGQgfHwgdC5wcmV2ZW50RGVmYXVsdCgpLFxyXG5cdFx0XHRcdFx0XHRcdCh0LmNhbGNQb2ludCA9IHQucG9pbnRzW2Iub3J0XSksXHJcblx0XHRcdFx0XHRcdFx0dm9pZCBvKHQsIHMpKSlcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHR2YXIgZSwgcjtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHIgPSBbXTtcclxuXHRcdFx0cmV0dXJuIChcclxuXHRcdFx0XHRuLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdFx0XHRpLmFkZEV2ZW50TGlzdGVuZXIodCwgZSwgISFkICYmIHsgcGFzc2l2ZTogITAgfSksIHIucHVzaChbdCwgZV0pO1xyXG5cdFx0XHRcdH0pLFxyXG5cdFx0XHRcdFx0clxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cdFx0ZnVuY3Rpb24gcSh0KSB7XHJcblx0XHRcdHZhciBlLFxyXG5cdFx0XHRcdHIsXHJcblx0XHRcdFx0bixcclxuXHRcdFx0XHRpLFxyXG5cdFx0XHRcdG8sXHJcblx0XHRcdFx0cyxcclxuXHRcdFx0XHRhID1cclxuXHRcdFx0XHRcdCgxMDAgKlxyXG5cdFx0XHRcdFx0XHQodCAtXHJcblx0XHRcdFx0XHRcdFx0KChlID0gbCksXHJcblx0XHRcdFx0XHRcdFx0XHQociA9IGIub3J0KSxcclxuXHRcdFx0XHRcdFx0XHRcdChuID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksXHJcblx0XHRcdFx0XHRcdFx0XHQoaSA9IGUub3duZXJEb2N1bWVudCksXHJcblx0XHRcdFx0XHRcdFx0XHQobyA9IGkuZG9jdW1lbnRFbGVtZW50KSxcclxuXHRcdFx0XHRcdFx0XHRcdChzID0gZ3QoaSkpLFxyXG5cdFx0XHRcdFx0XHRcdC93ZWJraXQuKkNocm9tZS4qTW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAocy54ID0gMCksXHJcblx0XHRcdFx0XHRcdFx0XHRyID8gbi50b3AgKyBzLnkgLSBvLmNsaWVudFRvcCA6IG4ubGVmdCArIHMueCAtIG8uY2xpZW50TGVmdCkpKSAvXHJcblx0XHRcdFx0XHRUKCk7XHJcblx0XHRcdHJldHVybiAoYSA9IGZ0KGEpKSwgYi5kaXIgPyAxMDAgLSBhIDogYTtcclxuXHRcdH1cclxuXHRcdGZ1bmN0aW9uIFgodCwgZSkge1xyXG5cdFx0XHRcIm1vdXNlb3V0XCIgPT09IHQudHlwZSAmJlxyXG5cdFx0XHRcIkhUTUxcIiA9PT0gdC50YXJnZXQubm9kZU5hbWUgJiZcclxuXHRcdFx0bnVsbCA9PT0gdC5yZWxhdGVkVGFyZ2V0ICYmXHJcblx0XHRcdF8odCwgZSk7XHJcblx0XHR9XHJcblx0XHRmdW5jdGlvbiBZKHQsIGUpIHtcclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdC0xID09PSBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKFwiTVNJRSA5XCIpICYmXHJcblx0XHRcdFx0MCA9PT0gdC5idXR0b25zICYmXHJcblx0XHRcdFx0MCAhPT0gZS5idXR0b25zUHJvcGVydHlcclxuXHRcdFx0KVxyXG5cdFx0XHRcdHJldHVybiBfKHQsIGUpO1xyXG5cdFx0XHR2YXIgciA9IChiLmRpciA/IC0xIDogMSkgKiAodC5jYWxjUG9pbnQgLSBlLnN0YXJ0Q2FsY1BvaW50KTtcclxuXHRcdFx0WigwIDwgciwgKDEwMCAqIHIpIC8gZS5iYXNlU2l6ZSwgZS5sb2NhdGlvbnMsIGUuaGFuZGxlTnVtYmVycyk7XHJcblx0XHR9XHJcblx0XHRmdW5jdGlvbiBfKHQsIGUpIHtcclxuXHRcdFx0ZS5oYW5kbGUgJiYgKG10KGUuaGFuZGxlLCBiLmNzc0NsYXNzZXMuYWN0aXZlKSwgKGcgLT0gMSkpLFxyXG5cdFx0XHRcdGUubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcclxuXHRcdFx0XHRcdEUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0WzBdLCB0WzFdKTtcclxuXHRcdFx0XHR9KSxcclxuXHRcdFx0MCA9PT0gZyAmJlxyXG5cdFx0XHQobXQoaCwgYi5jc3NDbGFzc2VzLmRyYWcpLFxyXG5cdFx0XHRcdGV0KCksXHJcblx0XHRcdHQuY3Vyc29yICYmXHJcblx0XHRcdCgoQy5zdHlsZS5jdXJzb3IgPSBcIlwiKSwgQy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0c3RhcnRcIiwgY3QpKSksXHJcblx0XHRcdFx0ZS5oYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcclxuXHRcdFx0XHRcdEooXCJjaGFuZ2VcIiwgdCksIEooXCJzZXRcIiwgdCksIEooXCJlbmRcIiwgdCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9XHJcblx0XHRmdW5jdGlvbiBJKHQsIGUpIHtcclxuXHRcdFx0aWYgKGUuaGFuZGxlTnVtYmVycy5zb21lKEwpKSByZXR1cm4gITE7XHJcblx0XHRcdHZhciByO1xyXG5cdFx0XHQxID09PSBlLmhhbmRsZU51bWJlcnMubGVuZ3RoICYmXHJcblx0XHRcdCgociA9IHVbZS5oYW5kbGVOdW1iZXJzWzBdXS5jaGlsZHJlblswXSksXHJcblx0XHRcdFx0KGcgKz0gMSksXHJcblx0XHRcdFx0aHQociwgYi5jc3NDbGFzc2VzLmFjdGl2ZSkpO1xyXG5cdFx0XHR0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHR2YXIgbiA9IFtdLFxyXG5cdFx0XHRcdGkgPSBCKGYubW92ZSwgRSwgWSwge1xyXG5cdFx0XHRcdFx0dGFyZ2V0OiB0LnRhcmdldCxcclxuXHRcdFx0XHRcdGhhbmRsZTogcixcclxuXHRcdFx0XHRcdGxpc3RlbmVyczogbixcclxuXHRcdFx0XHRcdHN0YXJ0Q2FsY1BvaW50OiB0LmNhbGNQb2ludCxcclxuXHRcdFx0XHRcdGJhc2VTaXplOiBUKCksXHJcblx0XHRcdFx0XHRwYWdlT2Zmc2V0OiB0LnBhZ2VPZmZzZXQsXHJcblx0XHRcdFx0XHRoYW5kbGVOdW1iZXJzOiBlLmhhbmRsZU51bWJlcnMsXHJcblx0XHRcdFx0XHRidXR0b25zUHJvcGVydHk6IHQuYnV0dG9ucyxcclxuXHRcdFx0XHRcdGxvY2F0aW9uczogUy5zbGljZSgpLFxyXG5cdFx0XHRcdH0pLFxyXG5cdFx0XHRcdG8gPSBCKGYuZW5kLCBFLCBfLCB7XHJcblx0XHRcdFx0XHR0YXJnZXQ6IHQudGFyZ2V0LFxyXG5cdFx0XHRcdFx0aGFuZGxlOiByLFxyXG5cdFx0XHRcdFx0bGlzdGVuZXJzOiBuLFxyXG5cdFx0XHRcdFx0ZG9Ob3RSZWplY3Q6ICEwLFxyXG5cdFx0XHRcdFx0aGFuZGxlTnVtYmVyczogZS5oYW5kbGVOdW1iZXJzLFxyXG5cdFx0XHRcdH0pLFxyXG5cdFx0XHRcdHMgPSBCKFwibW91c2VvdXRcIiwgRSwgWCwge1xyXG5cdFx0XHRcdFx0dGFyZ2V0OiB0LnRhcmdldCxcclxuXHRcdFx0XHRcdGhhbmRsZTogcixcclxuXHRcdFx0XHRcdGxpc3RlbmVyczogbixcclxuXHRcdFx0XHRcdGRvTm90UmVqZWN0OiAhMCxcclxuXHRcdFx0XHRcdGhhbmRsZU51bWJlcnM6IGUuaGFuZGxlTnVtYmVycyxcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0bi5wdXNoLmFwcGx5KG4sIGkuY29uY2F0KG8sIHMpKSxcclxuXHRcdFx0dC5jdXJzb3IgJiZcclxuXHRcdFx0KChDLnN0eWxlLmN1cnNvciA9IGdldENvbXB1dGVkU3R5bGUodC50YXJnZXQpLmN1cnNvciksXHJcblx0XHRcdDEgPCB1Lmxlbmd0aCAmJiBodChoLCBiLmNzc0NsYXNzZXMuZHJhZyksXHJcblx0XHRcdFx0Qy5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0c3RhcnRcIiwgY3QsICExKSksXHJcblx0XHRcdFx0ZS5oYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcclxuXHRcdFx0XHRcdEooXCJzdGFydFwiLCB0KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdGZ1bmN0aW9uIG4odCkge1xyXG5cdFx0XHR0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHR2YXIgaSxcclxuXHRcdFx0XHRvLFxyXG5cdFx0XHRcdHMsXHJcblx0XHRcdFx0ZSA9IHEodC5jYWxjUG9pbnQpLFxyXG5cdFx0XHRcdHIgPVxyXG5cdFx0XHRcdFx0KChpID0gZSksXHJcblx0XHRcdFx0XHRcdChzID0gIShvID0gMTAwKSksXHJcblx0XHRcdFx0XHRcdHUuZm9yRWFjaChmdW5jdGlvbiAodCwgZSkge1xyXG5cdFx0XHRcdFx0XHRcdGlmICghTChlKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHIgPSBTW2VdLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRuID0gTWF0aC5hYnMociAtIGkpO1xyXG5cdFx0XHRcdFx0XHRcdFx0KG4gPCBvIHx8IChuIDw9IG8gJiYgciA8IGkpIHx8ICgxMDAgPT09IG4gJiYgMTAwID09PSBvKSkgJiZcclxuXHRcdFx0XHRcdFx0XHRcdCgocyA9IGUpLCAobyA9IG4pKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0pLFxyXG5cdFx0XHRcdFx0XHRzKTtcclxuXHRcdFx0aWYgKCExID09PSByKSByZXR1cm4gITE7XHJcblx0XHRcdGIuZXZlbnRzLnNuYXAgfHwgcHQoaCwgYi5jc3NDbGFzc2VzLnRhcCwgYi5hbmltYXRpb25EdXJhdGlvbiksXHJcblx0XHRcdFx0cnQociwgZSwgITAsICEwKSxcclxuXHRcdFx0XHRldCgpLFxyXG5cdFx0XHRcdEooXCJzbGlkZVwiLCByLCAhMCksXHJcblx0XHRcdFx0SihcInVwZGF0ZVwiLCByLCAhMCksXHJcblx0XHRcdFx0SihcImNoYW5nZVwiLCByLCAhMCksXHJcblx0XHRcdFx0SihcInNldFwiLCByLCAhMCksXHJcblx0XHRcdGIuZXZlbnRzLnNuYXAgJiYgSSh0LCB7IGhhbmRsZU51bWJlcnM6IFtyXSB9KTtcclxuXHRcdH1cclxuXHRcdGZ1bmN0aW9uIFcodCkge1xyXG5cdFx0XHR2YXIgZSA9IHEodC5jYWxjUG9pbnQpLFxyXG5cdFx0XHRcdHIgPSB5LmdldFN0ZXAoZSksXHJcblx0XHRcdFx0biA9IHkuZnJvbVN0ZXBwaW5nKHIpO1xyXG5cdFx0XHRPYmplY3Qua2V5cyh2KS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdFx0XCJob3ZlclwiID09PSB0LnNwbGl0KFwiLlwiKVswXSAmJlxyXG5cdFx0XHRcdHZbdF0uZm9yRWFjaChmdW5jdGlvbiAodCkge1xyXG5cdFx0XHRcdFx0dC5jYWxsKGEsIG4pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdGZ1bmN0aW9uICQodCwgZSkge1xyXG5cdFx0XHQodlt0XSA9IHZbdF0gfHwgW10pLFxyXG5cdFx0XHRcdHZbdF0ucHVzaChlKSxcclxuXHRcdFx0XCJ1cGRhdGVcIiA9PT0gdC5zcGxpdChcIi5cIilbMF0gJiZcclxuXHRcdFx0dS5mb3JFYWNoKGZ1bmN0aW9uICh0LCBlKSB7XHJcblx0XHRcdFx0SihcInVwZGF0ZVwiLCBlKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0XHRmdW5jdGlvbiBHKHQpIHtcclxuXHRcdFx0dmFyIG4gPSB0ICYmIHQuc3BsaXQoXCIuXCIpWzBdLFxyXG5cdFx0XHRcdGkgPSBuICYmIHQuc3Vic3RyaW5nKG4ubGVuZ3RoKTtcclxuXHRcdFx0T2JqZWN0LmtleXModikuZm9yRWFjaChmdW5jdGlvbiAodCkge1xyXG5cdFx0XHRcdHZhciBlID0gdC5zcGxpdChcIi5cIilbMF0sXHJcblx0XHRcdFx0XHRyID0gdC5zdWJzdHJpbmcoZS5sZW5ndGgpO1xyXG5cdFx0XHRcdChuICYmIG4gIT09IGUpIHx8IChpICYmIGkgIT09IHIpIHx8IGRlbGV0ZSB2W3RdO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdGZ1bmN0aW9uIEoociwgbiwgaSkge1xyXG5cdFx0XHRPYmplY3Qua2V5cyh2KS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdFx0dmFyIGUgPSB0LnNwbGl0KFwiLlwiKVswXTtcclxuXHRcdFx0XHRyID09PSBlICYmXHJcblx0XHRcdFx0dlt0XS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdFx0XHR0LmNhbGwoYSwgeC5tYXAoYi5mb3JtYXQudG8pLCBuLCB4LnNsaWNlKCksIGkgfHwgITEsIFMuc2xpY2UoKSwgYSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0ZnVuY3Rpb24gSyh0LCBlLCByLCBuLCBpLCBvKSB7XHJcblx0XHRcdHZhciBzO1xyXG5cdFx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcdDEgPCB1Lmxlbmd0aCAmJlxyXG5cdFx0XHRcdCFiLmV2ZW50cy51bmNvbnN0cmFpbmVkICYmXHJcblx0XHRcdFx0KG4gJiZcclxuXHRcdFx0XHQwIDwgZSAmJlxyXG5cdFx0XHRcdCgocyA9IHkuZ2V0QWJzb2x1dGVEaXN0YW5jZSh0W2UgLSAxXSwgYi5tYXJnaW4sIDApKSxcclxuXHRcdFx0XHRcdChyID0gTWF0aC5tYXgociwgcykpKSxcclxuXHRcdFx0XHRpICYmXHJcblx0XHRcdFx0ZSA8IHUubGVuZ3RoIC0gMSAmJlxyXG5cdFx0XHRcdCgocyA9IHkuZ2V0QWJzb2x1dGVEaXN0YW5jZSh0W2UgKyAxXSwgYi5tYXJnaW4sIDEpKSxcclxuXHRcdFx0XHRcdChyID0gTWF0aC5taW4ociwgcykpKSksXHJcblx0XHRcdFx0MSA8IHUubGVuZ3RoICYmXHJcblx0XHRcdFx0Yi5saW1pdCAmJlxyXG5cdFx0XHRcdChuICYmXHJcblx0XHRcdFx0MCA8IGUgJiZcclxuXHRcdFx0XHQoKHMgPSB5LmdldEFic29sdXRlRGlzdGFuY2UodFtlIC0gMV0sIGIubGltaXQsIDApKSxcclxuXHRcdFx0XHRcdChyID0gTWF0aC5taW4ociwgcykpKSxcclxuXHRcdFx0XHRpICYmXHJcblx0XHRcdFx0ZSA8IHUubGVuZ3RoIC0gMSAmJlxyXG5cdFx0XHRcdCgocyA9IHkuZ2V0QWJzb2x1dGVEaXN0YW5jZSh0W2UgKyAxXSwgYi5saW1pdCwgMSkpLFxyXG5cdFx0XHRcdFx0KHIgPSBNYXRoLm1heChyLCBzKSkpKSxcclxuXHRcdFx0XHRiLnBhZGRpbmcgJiZcclxuXHRcdFx0XHQoMCA9PT0gZSAmJlxyXG5cdFx0XHRcdCgocyA9IHkuZ2V0QWJzb2x1dGVEaXN0YW5jZSgwLCBiLnBhZGRpbmdbMF0sIDApKSxcclxuXHRcdFx0XHRcdChyID0gTWF0aC5tYXgociwgcykpKSxcclxuXHRcdFx0XHRlID09PSB1Lmxlbmd0aCAtIDEgJiZcclxuXHRcdFx0XHQoKHMgPSB5LmdldEFic29sdXRlRGlzdGFuY2UoMTAwLCBiLnBhZGRpbmdbMV0sIDEpKSxcclxuXHRcdFx0XHRcdChyID0gTWF0aC5taW4ociwgcykpKSksXHJcblx0XHRcdFx0ISgociA9IGZ0KChyID0geS5nZXRTdGVwKHIpKSkpID09PSB0W2VdICYmICFvKSAmJiByXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblx0XHRmdW5jdGlvbiBRKHQsIGUpIHtcclxuXHRcdFx0dmFyIHIgPSBiLm9ydDtcclxuXHRcdFx0cmV0dXJuIChyID8gZSA6IHQpICsgXCIsIFwiICsgKHIgPyB0IDogZSk7XHJcblx0XHR9XHJcblx0XHRmdW5jdGlvbiBaKHQsIG4sIHIsIGUpIHtcclxuXHRcdFx0dmFyIGkgPSByLnNsaWNlKCksXHJcblx0XHRcdFx0byA9IFshdCwgdF0sXHJcblx0XHRcdFx0cyA9IFt0LCAhdF07XHJcblx0XHRcdChlID0gZS5zbGljZSgpKSxcclxuXHRcdFx0dCAmJiBlLnJldmVyc2UoKSxcclxuXHRcdFx0XHQxIDwgZS5sZW5ndGhcclxuXHRcdFx0XHRcdD8gZS5mb3JFYWNoKGZ1bmN0aW9uICh0LCBlKSB7XHJcblx0XHRcdFx0XHRcdHZhciByID0gSyhpLCB0LCBpW3RdICsgbiwgb1tlXSwgc1tlXSwgITEpO1xyXG5cdFx0XHRcdFx0XHQhMSA9PT0gciA/IChuID0gMCkgOiAoKG4gPSByIC0gaVt0XSksIChpW3RdID0gcikpO1xyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0XHRcdDogKG8gPSBzID0gWyEwXSk7XHJcblx0XHRcdHZhciBhID0gITE7XHJcblx0XHRcdGUuZm9yRWFjaChmdW5jdGlvbiAodCwgZSkge1xyXG5cdFx0XHRcdGEgPSBydCh0LCByW3RdICsgbiwgb1tlXSwgc1tlXSkgfHwgYTtcclxuXHRcdFx0fSksXHJcblx0XHRcdGEgJiZcclxuXHRcdFx0ZS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdFx0SihcInVwZGF0ZVwiLCB0KSwgSihcInNsaWRlXCIsIHQpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdGZ1bmN0aW9uIHR0KHQsIGUpIHtcclxuXHRcdFx0cmV0dXJuIGIuZGlyID8gMTAwIC0gdCAtIGUgOiB0O1xyXG5cdFx0fVxyXG5cdFx0ZnVuY3Rpb24gZXQoKSB7XHJcblx0XHRcdG0uZm9yRWFjaChmdW5jdGlvbiAodCkge1xyXG5cdFx0XHRcdHZhciBlID0gNTAgPCBTW3RdID8gLTEgOiAxLFxyXG5cdFx0XHRcdFx0ciA9IDMgKyAodS5sZW5ndGggKyBlICogdCk7XHJcblx0XHRcdFx0dVt0XS5zdHlsZS56SW5kZXggPSByO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdGZ1bmN0aW9uIHJ0KHQsIGUsIHIsIG4sIGkpIHtcclxuXHRcdFx0cmV0dXJuIChcclxuXHRcdFx0XHRpIHx8IChlID0gSyhTLCB0LCBlLCByLCBuLCAhMSkpLFxyXG5cdFx0XHRcdCExICE9PSBlICYmXHJcblx0XHRcdFx0KChmdW5jdGlvbiAodCwgZSkge1xyXG5cdFx0XHRcdFx0KFNbdF0gPSBlKSwgKHhbdF0gPSB5LmZyb21TdGVwcGluZyhlKSk7XHJcblx0XHRcdFx0XHR2YXIgciA9IFwidHJhbnNsYXRlKFwiICsgUSgxMCAqICh0dChlLCAwKSAtIEEpICsgXCIlXCIsIFwiMFwiKSArIFwiKVwiO1xyXG5cdFx0XHRcdFx0KHVbdF0uc3R5bGVbYi50cmFuc2Zvcm1SdWxlXSA9IHIpLCBudCh0KSwgbnQodCArIDEpO1xyXG5cdFx0XHRcdH0pKHQsIGUpLFxyXG5cdFx0XHRcdFx0ITApXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblx0XHRmdW5jdGlvbiBudCh0KSB7XHJcblx0XHRcdGlmIChzW3RdKSB7XHJcblx0XHRcdFx0dmFyIGUgPSAwLFxyXG5cdFx0XHRcdFx0ciA9IDEwMDtcclxuXHRcdFx0XHQwICE9PSB0ICYmIChlID0gU1t0IC0gMV0pLCB0ICE9PSBzLmxlbmd0aCAtIDEgJiYgKHIgPSBTW3RdKTtcclxuXHRcdFx0XHR2YXIgbiA9IHIgLSBlLFxyXG5cdFx0XHRcdFx0aSA9IFwidHJhbnNsYXRlKFwiICsgUSh0dChlLCBuKSArIFwiJVwiLCBcIjBcIikgKyBcIilcIixcclxuXHRcdFx0XHRcdG8gPSBcInNjYWxlKFwiICsgUShuIC8gMTAwLCBcIjFcIikgKyBcIilcIjtcclxuXHRcdFx0XHRzW3RdLnN0eWxlW2IudHJhbnNmb3JtUnVsZV0gPSBpICsgXCIgXCIgKyBvO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmdW5jdGlvbiBpdCh0LCBlKSB7XHJcblx0XHRcdHJldHVybiBudWxsID09PSB0IHx8ICExID09PSB0IHx8IHZvaWQgMCA9PT0gdFxyXG5cdFx0XHRcdD8gU1tlXVxyXG5cdFx0XHRcdDogKFwibnVtYmVyXCIgPT0gdHlwZW9mIHQgJiYgKHQgPSBTdHJpbmcodCkpLFxyXG5cdFx0XHRcdFx0KHQgPSBiLmZvcm1hdC5mcm9tKHQpKSxcclxuXHRcdFx0XHRcdCExID09PSAodCA9IHkudG9TdGVwcGluZyh0KSkgfHwgaXNOYU4odCkgPyBTW2VdIDogdCk7XHJcblx0XHR9XHJcblx0XHRmdW5jdGlvbiBvdCh0LCBlLCByKSB7XHJcblx0XHRcdHZhciBuID0gZHQodCksXHJcblx0XHRcdFx0aSA9IHZvaWQgMCA9PT0gU1swXTtcclxuXHRcdFx0KGUgPSB2b2lkIDAgPT09IGUgfHwgISFlKSxcclxuXHRcdFx0Yi5hbmltYXRlICYmICFpICYmIHB0KGgsIGIuY3NzQ2xhc3Nlcy50YXAsIGIuYW5pbWF0aW9uRHVyYXRpb24pLFxyXG5cdFx0XHRcdG0uZm9yRWFjaChmdW5jdGlvbiAodCkge1xyXG5cdFx0XHRcdFx0cnQodCwgaXQoblt0XSwgdCksICEwLCAhMSwgcik7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdGZvciAodmFyIG8gPSAxID09PSBtLmxlbmd0aCA/IDAgOiAxOyBvIDwgbS5sZW5ndGg7ICsrbylcclxuXHRcdFx0XHRtLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcclxuXHRcdFx0XHRcdHJ0KHQsIFNbdF0sICEwLCAhMCwgcik7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdGV0KCksXHJcblx0XHRcdFx0bS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdFx0XHRKKFwidXBkYXRlXCIsIHQpLCBudWxsICE9PSBuW3RdICYmIGUgJiYgSihcInNldFwiLCB0KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdGZ1bmN0aW9uIHN0KCkge1xyXG5cdFx0XHR2YXIgdCA9IHgubWFwKGIuZm9ybWF0LnRvKTtcclxuXHRcdFx0cmV0dXJuIDEgPT09IHQubGVuZ3RoID8gdFswXSA6IHQ7XHJcblx0XHR9XHJcblx0XHRmdW5jdGlvbiBhdCh0KSB7XHJcblx0XHRcdHZhciBlID0gU1t0XSxcclxuXHRcdFx0XHRyID0geS5nZXROZWFyYnlTdGVwcyhlKSxcclxuXHRcdFx0XHRuID0geFt0XSxcclxuXHRcdFx0XHRpID0gci50aGlzU3RlcC5zdGVwLFxyXG5cdFx0XHRcdG8gPSBudWxsO1xyXG5cdFx0XHRpZiAoYi5zbmFwKVxyXG5cdFx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0XHRuIC0gci5zdGVwQmVmb3JlLnN0YXJ0VmFsdWUgfHwgbnVsbCxcclxuXHRcdFx0XHRcdHIuc3RlcEFmdGVyLnN0YXJ0VmFsdWUgLSBuIHx8IG51bGwsXHJcblx0XHRcdFx0XTtcclxuXHRcdFx0ITEgIT09IGkgJiZcclxuXHRcdFx0biArIGkgPiByLnN0ZXBBZnRlci5zdGFydFZhbHVlICYmXHJcblx0XHRcdChpID0gci5zdGVwQWZ0ZXIuc3RhcnRWYWx1ZSAtIG4pLFxyXG5cdFx0XHRcdChvID1cclxuXHRcdFx0XHRcdG4gPiByLnRoaXNTdGVwLnN0YXJ0VmFsdWVcclxuXHRcdFx0XHRcdFx0PyByLnRoaXNTdGVwLnN0ZXBcclxuXHRcdFx0XHRcdFx0OiAhMSAhPT0gci5zdGVwQmVmb3JlLnN0ZXAgJiYgbiAtIHIuc3RlcEJlZm9yZS5oaWdoZXN0U3RlcCksXHJcblx0XHRcdFx0MTAwID09PSBlID8gKGkgPSBudWxsKSA6IDAgPT09IGUgJiYgKG8gPSBudWxsKTtcclxuXHRcdFx0dmFyIHMgPSB5LmNvdW50U3RlcERlY2ltYWxzKCk7XHJcblx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0bnVsbCAhPT0gaSAmJiAhMSAhPT0gaSAmJiAoaSA9IE51bWJlcihpLnRvRml4ZWQocykpKSxcclxuXHRcdFx0XHRudWxsICE9PSBvICYmICExICE9PSBvICYmIChvID0gTnVtYmVyKG8udG9GaXhlZChzKSkpLFxyXG5cdFx0XHRcdFx0W28sIGldXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKFxyXG5cdFx0XHRodCgoZSA9IGgpLCBiLmNzc0NsYXNzZXMudGFyZ2V0KSxcclxuXHRcdFx0XHQwID09PSBiLmRpciA/IGh0KGUsIGIuY3NzQ2xhc3Nlcy5sdHIpIDogaHQoZSwgYi5jc3NDbGFzc2VzLnJ0bCksXHJcblx0XHRcdFx0MCA9PT0gYi5vcnRcclxuXHRcdFx0XHRcdD8gaHQoZSwgYi5jc3NDbGFzc2VzLmhvcml6b250YWwpXHJcblx0XHRcdFx0XHQ6IGh0KGUsIGIuY3NzQ2xhc3Nlcy52ZXJ0aWNhbCksXHJcblx0XHRcdFx0aHQoXHJcblx0XHRcdFx0XHRlLFxyXG5cdFx0XHRcdFx0XCJydGxcIiA9PT0gZ2V0Q29tcHV0ZWRTdHlsZShlKS5kaXJlY3Rpb25cclxuXHRcdFx0XHRcdFx0PyBiLmNzc0NsYXNzZXMudGV4dERpcmVjdGlvblJ0bFxyXG5cdFx0XHRcdFx0XHQ6IGIuY3NzQ2xhc3Nlcy50ZXh0RGlyZWN0aW9uTHRyXHJcblx0XHRcdFx0KSxcclxuXHRcdFx0XHQobCA9IFYoZSwgYi5jc3NDbGFzc2VzLmJhc2UpKSxcclxuXHRcdFx0XHQoZnVuY3Rpb24gKHQsIGUpIHtcclxuXHRcdFx0XHRcdHZhciByID0gVihlLCBiLmNzc0NsYXNzZXMuY29ubmVjdHMpO1xyXG5cdFx0XHRcdFx0KHUgPSBbXSksIChzID0gW10pLnB1c2goTShyLCB0WzBdKSk7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBuID0gMDsgbiA8IGIuaGFuZGxlczsgbisrKVxyXG5cdFx0XHRcdFx0XHR1LnB1c2goRChlLCBuKSksIChtW25dID0gbiksIHMucHVzaChNKHIsIHRbbiArIDFdKSk7XHJcblx0XHRcdFx0fSkoYi5jb25uZWN0LCBsKSxcclxuXHRcdFx0KHAgPSBiLmV2ZW50cykuZml4ZWQgfHxcclxuXHRcdFx0dS5mb3JFYWNoKGZ1bmN0aW9uICh0LCBlKSB7XHJcblx0XHRcdFx0QihmLnN0YXJ0LCB0LmNoaWxkcmVuWzBdLCBJLCB7IGhhbmRsZU51bWJlcnM6IFtlXSB9KTtcclxuXHRcdFx0fSksXHJcblx0XHRcdHAudGFwICYmIEIoZi5zdGFydCwgbCwgbiwge30pLFxyXG5cdFx0XHRwLmhvdmVyICYmIEIoZi5tb3ZlLCBsLCBXLCB7IGhvdmVyOiAhMCB9KSxcclxuXHRcdFx0cC5kcmFnICYmXHJcblx0XHRcdHMuZm9yRWFjaChmdW5jdGlvbiAodCwgZSkge1xyXG5cdFx0XHRcdGlmICghMSAhPT0gdCAmJiAwICE9PSBlICYmIGUgIT09IHMubGVuZ3RoIC0gMSkge1xyXG5cdFx0XHRcdFx0dmFyIHIgPSB1W2UgLSAxXSxcclxuXHRcdFx0XHRcdFx0biA9IHVbZV0sXHJcblx0XHRcdFx0XHRcdGkgPSBbdF07XHJcblx0XHRcdFx0XHRodCh0LCBiLmNzc0NsYXNzZXMuZHJhZ2dhYmxlKSxcclxuXHRcdFx0XHRcdHAuZml4ZWQgJiYgKGkucHVzaChyLmNoaWxkcmVuWzBdKSwgaS5wdXNoKG4uY2hpbGRyZW5bMF0pKSxcclxuXHRcdFx0XHRcdFx0aS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdFx0XHRcdFx0QihmLnN0YXJ0LCB0LCBJLCB7XHJcblx0XHRcdFx0XHRcdFx0XHRoYW5kbGVzOiBbciwgbl0sXHJcblx0XHRcdFx0XHRcdFx0XHRoYW5kbGVOdW1iZXJzOiBbZSAtIDEsIGVdLFxyXG5cdFx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pLFxyXG5cdFx0XHRcdG90KGIuc3RhcnQpLFxyXG5cdFx0XHRiLnBpcHMgJiYgUihiLnBpcHMpLFxyXG5cdFx0XHRiLnRvb2x0aXBzICYmIEgoKSxcclxuXHRcdFx0XHQkKFwidXBkYXRlXCIsIGZ1bmN0aW9uICh0LCBlLCBzLCByLCBhKSB7XHJcblx0XHRcdFx0XHRtLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcclxuXHRcdFx0XHRcdFx0dmFyIGUgPSB1W3RdLFxyXG5cdFx0XHRcdFx0XHRcdHIgPSBLKFMsIHQsIDAsICEwLCAhMCwgITApLFxyXG5cdFx0XHRcdFx0XHRcdG4gPSBLKFMsIHQsIDEwMCwgITAsICEwLCAhMCksXHJcblx0XHRcdFx0XHRcdFx0aSA9IGFbdF0sXHJcblx0XHRcdFx0XHRcdFx0byA9IGIuYXJpYUZvcm1hdC50byhzW3RdKTtcclxuXHRcdFx0XHRcdFx0KHIgPSB5LmZyb21TdGVwcGluZyhyKS50b0ZpeGVkKDEpKSxcclxuXHRcdFx0XHRcdFx0XHQobiA9IHkuZnJvbVN0ZXBwaW5nKG4pLnRvRml4ZWQoMSkpLFxyXG5cdFx0XHRcdFx0XHRcdChpID0geS5mcm9tU3RlcHBpbmcoaSkudG9GaXhlZCgxKSksXHJcblx0XHRcdFx0XHRcdFx0ZS5jaGlsZHJlblswXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXZhbHVlbWluXCIsIHIpLFxyXG5cdFx0XHRcdFx0XHRcdGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW1heFwiLCBuKSxcclxuXHRcdFx0XHRcdFx0XHRlLmNoaWxkcmVuWzBdLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWVub3dcIiwgaSksXHJcblx0XHRcdFx0XHRcdFx0ZS5jaGlsZHJlblswXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXZhbHVldGV4dFwiLCBvKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pLFxyXG5cdFx0XHRcdChhID0ge1xyXG5cdFx0XHRcdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0XHRmb3IgKHZhciB0IGluIGIuY3NzQ2xhc3NlcylcclxuXHRcdFx0XHRcdFx0XHRiLmNzc0NsYXNzZXMuaGFzT3duUHJvcGVydHkodCkgJiYgbXQoaCwgYi5jc3NDbGFzc2VzW3RdKTtcclxuXHRcdFx0XHRcdFx0Zm9yICg7IGguZmlyc3RDaGlsZDsgKSBoLnJlbW92ZUNoaWxkKGguZmlyc3RDaGlsZCk7XHJcblx0XHRcdFx0XHRcdGRlbGV0ZSBoLm5vVWlTbGlkZXI7XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0c3RlcHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIG0ubWFwKGF0KTtcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRvbjogJCxcclxuXHRcdFx0XHRcdG9mZjogRyxcclxuXHRcdFx0XHRcdGdldDogc3QsXHJcblx0XHRcdFx0XHRzZXQ6IG90LFxyXG5cdFx0XHRcdFx0c2V0SGFuZGxlOiBmdW5jdGlvbiAodCwgZSwgciwgbikge1xyXG5cdFx0XHRcdFx0XHRpZiAoISgwIDw9ICh0ID0gTnVtYmVyKHQpKSAmJiB0IDwgbS5sZW5ndGgpKVxyXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcclxuXHRcdFx0XHRcdFx0XHRcdFwibm9VaVNsaWRlciAoXCIgKyBsdCArIFwiKTogaW52YWxpZCBoYW5kbGUgbnVtYmVyLCBnb3Q6IFwiICsgdFxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdHJ0KHQsIGl0KGUsIHQpLCAhMCwgITAsIG4pLCBKKFwidXBkYXRlXCIsIHQpLCByICYmIEooXCJzZXRcIiwgdCk7XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0cmVzZXQ6IGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdFx0XHRcdG90KGIuc3RhcnQsIHQpO1xyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdF9fbW92ZUhhbmRsZXM6IGZ1bmN0aW9uICh0LCBlLCByKSB7XHJcblx0XHRcdFx0XHRcdFoodCwgZSwgUywgcik7XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0b3B0aW9uczogbyxcclxuXHRcdFx0XHRcdHVwZGF0ZU9wdGlvbnM6IGZ1bmN0aW9uIChlLCB0KSB7XHJcblx0XHRcdFx0XHRcdHZhciByID0gc3QoKSxcclxuXHRcdFx0XHRcdFx0XHRuID0gW1xyXG5cdFx0XHRcdFx0XHRcdFx0XCJtYXJnaW5cIixcclxuXHRcdFx0XHRcdFx0XHRcdFwibGltaXRcIixcclxuXHRcdFx0XHRcdFx0XHRcdFwicGFkZGluZ1wiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XCJyYW5nZVwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XCJhbmltYXRlXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcInNuYXBcIixcclxuXHRcdFx0XHRcdFx0XHRcdFwic3RlcFwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XCJmb3JtYXRcIixcclxuXHRcdFx0XHRcdFx0XHRcdFwicGlwc1wiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XCJ0b29sdGlwc1wiLFxyXG5cdFx0XHRcdFx0XHRcdF07XHJcblx0XHRcdFx0XHRcdG4uZm9yRWFjaChmdW5jdGlvbiAodCkge1xyXG5cdFx0XHRcdFx0XHRcdHZvaWQgMCAhPT0gZVt0XSAmJiAob1t0XSA9IGVbdF0pO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0dmFyIGkgPSB2dChvKTtcclxuXHRcdFx0XHRcdFx0bi5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcblx0XHRcdFx0XHRcdFx0dm9pZCAwICE9PSBlW3RdICYmIChiW3RdID0gaVt0XSk7XHJcblx0XHRcdFx0XHRcdH0pLFxyXG5cdFx0XHRcdFx0XHRcdCh5ID0gaS5zcGVjdHJ1bSksXHJcblx0XHRcdFx0XHRcdFx0KGIubWFyZ2luID0gaS5tYXJnaW4pLFxyXG5cdFx0XHRcdFx0XHRcdChiLmxpbWl0ID0gaS5saW1pdCksXHJcblx0XHRcdFx0XHRcdFx0KGIucGFkZGluZyA9IGkucGFkZGluZyksXHJcblx0XHRcdFx0XHRcdFx0Yi5waXBzID8gUihiLnBpcHMpIDogRigpLFxyXG5cdFx0XHRcdFx0XHRcdGIudG9vbHRpcHMgPyBIKCkgOiB6KCksXHJcblx0XHRcdFx0XHRcdFx0KFMgPSBbXSksXHJcblx0XHRcdFx0XHRcdFx0b3QoZS5zdGFydCB8fCByLCB0KTtcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHR0YXJnZXQ6IGgsXHJcblx0XHRcdFx0XHRyZW1vdmVQaXBzOiBGLFxyXG5cdFx0XHRcdFx0cmVtb3ZlVG9vbHRpcHM6IHosXHJcblx0XHRcdFx0XHRnZXRUb29sdGlwczogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gaTtcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRnZXRPcmlnaW5zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB1O1xyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdHBpcHM6IFIsXHJcblx0XHRcdFx0fSlcclxuXHRcdCk7XHJcblx0fVxyXG5cdHJldHVybiB7XHJcblx0XHRfX3NwZWN0cnVtOiBpLFxyXG5cdFx0dmVyc2lvbjogbHQsXHJcblx0XHRjc3NDbGFzc2VzOiBkLFxyXG5cdFx0Y3JlYXRlOiBmdW5jdGlvbiAodCwgZSkge1xyXG5cdFx0XHRpZiAoIXQgfHwgIXQubm9kZU5hbWUpXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcdFx0XCJub1VpU2xpZGVyIChcIiArIGx0ICsgXCIpOiBjcmVhdGUgcmVxdWlyZXMgYSBzaW5nbGUgZWxlbWVudCwgZ290OiBcIiArIHRcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRpZiAodC5ub1VpU2xpZGVyKVxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcclxuXHRcdFx0XHRcdFwibm9VaVNsaWRlciAoXCIgKyBsdCArIFwiKTogU2xpZGVyIHdhcyBhbHJlYWR5IGluaXRpYWxpemVkLlwiXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0dmFyIHIgPSBqKHQsIHZ0KGUpLCBlKTtcclxuXHRcdFx0cmV0dXJuICh0Lm5vVWlTbGlkZXIgPSByKTtcclxuXHRcdH0sXHJcblx0fTtcclxuXHJcbn0pO1xyXG5cclxuXHJcbmNvbnN0IHJhbmdlU2xpZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JhbmdlLXNsaWRlcicpO1xyXG5cclxuaWYgKHJhbmdlU2xpZGVyKSB7XHJcblx0bm9VaVNsaWRlci5jcmVhdGUocmFuZ2VTbGlkZXIsIHtcclxuXHRcdHN0YXJ0OiBbNTAwLCA5OTk5OTldLFxyXG5cdFx0Y29ubmVjdDogdHJ1ZSxcclxuXHRcdHN0ZXA6IDEsXHJcblx0XHRyYW5nZToge1xyXG5cdFx0XHQnbWluJzogWzUwMF0sXHJcblx0XHRcdCdtYXgnOiBbMTAwMDBdXHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGNvbnN0IGlucHV0MCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbnB1dC0wJyk7XHJcblx0Y29uc3QgaW5wdXQxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lucHV0LTEnKTtcclxuXHRjb25zdCBpbnB1dHMgPSBbaW5wdXQwLCBpbnB1dDFdO1xyXG5cclxuXHRyYW5nZVNsaWRlci5ub1VpU2xpZGVyLm9uKCd1cGRhdGUnLCBmdW5jdGlvbih2YWx1ZXMsIGhhbmRsZSl7XHJcblx0XHRpbnB1dHNbaGFuZGxlXS52YWx1ZSA9IE1hdGgucm91bmQodmFsdWVzW2hhbmRsZV0pO1xyXG5cdH0pO1xyXG5cclxuXHRjb25zdCBzZXRSYW5nZVNsaWRlciA9IChpLCB2YWx1ZSkgPT4ge1xyXG5cdFx0bGV0IGFyciA9IFtudWxsLCBudWxsXTtcclxuXHRcdGFycltpXSA9IHZhbHVlO1xyXG5cclxuXHRcdHJhbmdlU2xpZGVyLm5vVWlTbGlkZXIuc2V0KGFycik7XHJcblx0fTtcclxuXHJcblx0aW5wdXRzLmZvckVhY2goKGVsLCBpbmRleCkgPT4ge1xyXG5cdFx0ZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcclxuXHRcdFx0Y29uc29sZS5sb2coaW5kZXgpO1xyXG5cdFx0XHRzZXRSYW5nZVNsaWRlcihpbmRleCwgZS5jdXJyZW50VGFyZ2V0LnZhbHVlKTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59XHJcblxuZnVuY3Rpb24gZ2V0VGltZVJlbWFpbmluZyhlbmR0aW1lKSB7XG4gIGNvbnN0IHRvdGFsID0gRGF0ZS5wYXJzZShlbmR0aW1lKSAtIERhdGUucGFyc2UobmV3IERhdGUoKSk7XG4gIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKCh0b3RhbCAvIDEwMDApICUgNjApO1xuICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcigodG90YWwgLyAxMDAwIC8gNjApICUgNjApO1xuICBjb25zdCBob3VycyA9IE1hdGguZmxvb3IoKHRvdGFsIC8gKDEwMDAgKiA2MCAqIDYwKSkgJSAyNCk7XG4gIGNvbnN0IGRheXMgPSBNYXRoLmZsb29yKHRvdGFsIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKTtcblxuICByZXR1cm4ge1xuICAgIHRvdGFsLFxuICAgIGRheXMsXG4gICAgaG91cnMsXG4gICAgbWludXRlcyxcbiAgICBzZWNvbmRzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVDbG9jayhpZCwgZW5kdGltZSkge1xuICBjb25zdCBjbG9jayA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wcm9tb19fY2xvY2snKTtcbiAgY29uc3QgZGF5c1NwYW4gPSBjbG9jay5xdWVyeVNlbGVjdG9yKCcucHJvbW9fX2RheXMnKTtcbiAgY29uc3QgaG91cnNTcGFuID0gY2xvY2sucXVlcnlTZWxlY3RvcignLnByb21vX19ob3VycycpO1xuICBjb25zdCBtaW51dGVzU3BhbiA9IGNsb2NrLnF1ZXJ5U2VsZWN0b3IoJy5wcm9tb19fbWludXRlcycpO1xuICBjb25zdCBzZWNvbmRzU3BhbiA9IGNsb2NrLnF1ZXJ5U2VsZWN0b3IoJy5wcm9tb19fc2Vjb25kcycpO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNsb2NrKCkge1xuICAgIGNvbnN0IHQgPSBnZXRUaW1lUmVtYWluaW5nKGVuZHRpbWUpO1xuXG4gICAgZGF5c1NwYW4uaW5uZXJIVE1MID0gdC5kYXlzO1xuICAgIGhvdXJzU3Bhbi5pbm5lckhUTUwgPSAoJzAnICsgdC5ob3Vycykuc2xpY2UoLTIpO1xuICAgIG1pbnV0ZXNTcGFuLmlubmVySFRNTCA9ICgnMCcgKyB0Lm1pbnV0ZXMpLnNsaWNlKC0yKTtcbiAgICBzZWNvbmRzU3Bhbi5pbm5lckhUTUwgPSAoJzAnICsgdC5zZWNvbmRzKS5zbGljZSgtMik7XG5cbiAgICBpZiAodC50b3RhbCA8PSAwKSB7XG4gICAgICBjbGVhckludGVydmFsKHRpbWVpbnRlcnZhbCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ2xvY2soKTtcbiAgY29uc3QgdGltZWludGVydmFsID0gc2V0SW50ZXJ2YWwodXBkYXRlQ2xvY2ssIDEwMDApO1xufVxuXG5jb25zdCBwcm9tb19fY2xvY2sgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucHJvbW9fX2Nsb2NrJylcblxuaWYgKHByb21vX19jbG9jaykge1xuICBjb25zdCBkZWFkbGluZSA9IG5ldyBEYXRlKERhdGUucGFyc2UobmV3IERhdGUoKSkgKyAxNSAqIDI0ICogNjAgKiA2MCAqIDEwMDApO1xuICBpbml0aWFsaXplQ2xvY2soJ3Byb21vX19jbG9jaycsIGRlYWRsaW5lKTtcbn1cblxuXG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcblx0ZWxlbWVudCA9IGUudGFyZ2V0O1xuXG4gIFxuXG5pZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3RhYl9fbGluaycpKSB7XG5cdGUucHJldmVudERlZmF1bHQoKVxuXG5cdGxldCB0YWJzID0gKGVsZW1lbnQpID0+IHtcblx0XHRsZXQgcGFyZW50VGFicyA9IGVsZW1lbnQuY2xvc2VzdCgnLnRhYicpXG5cblx0XHRsZXQgJHRhYkxpbmtBY3RpdiA9IHBhcmVudFRhYnMucXVlcnlTZWxlY3RvcignLnRhYl9fbGluay0tYWN0aXZlJylcblx0XHRsZXQgJHRhYkNvbnRlbnRBY3RpdiA9IHBhcmVudFRhYnMucXVlcnlTZWxlY3RvcignLnRhYl9fY29udGVudC1pdGVtLS1hY3RpdmUnKVxuXG5cdFx0bGV0ICR0YWJMaW5rID0gcGFyZW50VGFicy5xdWVyeVNlbGVjdG9yQWxsKCcudGFiX19saW5rJylcblx0XHRsZXQgJHRhYnNDb250ZW50ID0gcGFyZW50VGFicy5xdWVyeVNlbGVjdG9yQWxsKCcudGFiX19jb250ZW50LWl0ZW0nKVxuXG5cblx0XHQkdGFiTGlua0FjdGl2LmNsYXNzTGlzdC5yZW1vdmUoJ3RhYl9fbGluay0tYWN0aXZlJylcblx0XHQkdGFiQ29udGVudEFjdGl2LmNsYXNzTGlzdC5yZW1vdmUoJ3RhYl9fY29udGVudC1pdGVtLS1hY3RpdmUnKVxuXG5cdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKCd0YWJfX2xpbmstLWFjdGl2ZScpXG5cblx0XHQkdGFiTGluay5mb3JFYWNoKChpdGVtLCBrZXkpID0+IHtcblx0XHRcdGxldCB0YWJDbGFzcyA9IGl0ZW0uY2xhc3NOYW1lLmluZGV4T2YoJ3RhYl9fbGluay0tYWN0aXZlJylcblxuXHRcdFx0aWYodGFiQ2xhc3MgPj0gMSlcblx0XHRcdHtcblx0XHRcdFx0bGV0IGFycmF5ID0gWy4uLiR0YWJzQ29udGVudF1cblx0XHRcdFx0YXJyYXlba2V5XS5jbGFzc0xpc3QuYWRkKCd0YWJfX2NvbnRlbnQtaXRlbS0tYWN0aXZlJylcblx0XHRcdH1cblx0XHR9KVxuXG5cdH1cblxuXHR0YWJzKGVsZW1lbnQpXG5cbn1cblxuXG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnc2VsZWN0X19pbnB1dCcpKSB7XHJcbiAgICBjb25zdCAkc2VsZWN0ID0gZWxlbWVudC5jbG9zZXN0KCcuc2VsZWN0JylcclxuICAgICRzZWxlY3QuY2xhc3NMaXN0LnRvZ2dsZSgnb3BlbicpXHJcbn1cclxuaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWxlY3RfX2l0ZW0nKSkge1xyXG4gICAgY29uc3QgJHNlbGVjdCA9IGVsZW1lbnQuY2xvc2VzdCgnLnNlbGVjdCcpXHJcbiAgICAkc2VsZWN0LmNsYXNzTGlzdC5yZW1vdmUoJ29wZW4nKVxyXG5cclxuXHJcbiAgICBjb25zdCAkc2VsZWN0SW5wdXQgPSAkc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJy5zZWxlY3RfX2lucHV0JylcclxuICAgICRzZWxlY3RJbnB1dC50ZXh0Q29udGVudCA9IGVsZW1lbnQudGV4dENvbnRlbnRcclxufVxuXG4gIGxldCAkZ3JpZCA9IGVsZW1lbnQuY2xvc2VzdCgnLnNob3AtY29udGVudF9fZmlsdGVyLWJ0bicpXG5cbiAgaWYgKCRncmlkKSB7XG4gICAgJGFjdGl2ZUdyaWQgPSAkZ3JpZC5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zaG9wLWNvbnRlbnRfX2ZpbHRlci1idG4tLWFjdGl2ZScpXG4gICAgJHByb2R1Y3RJdGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wcm9kdWN0LWl0ZW0nKVxuXG4gICAgJGFjdGl2ZUdyaWQuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3AtY29udGVudF9fZmlsdGVyLWJ0bi0tYWN0aXZlJylcbiAgICB9KVxuXG4gICAgJHByb2R1Y3RJdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGl0ZW0uY2xhc3NMaXN0LnRvZ2dsZSgncHJvZHVjdC1pdGVtLS1saXN0JylcbiAgICB9KVxuXG4gICAgJGdyaWQuY2xhc3NMaXN0LmFkZCgnc2hvcC1jb250ZW50X19maWx0ZXItYnRuLS1hY3RpdmUnKVxuICB9XG5cblxuXG59KTtcblxuIl0sImZpbGUiOiJzY3JpcHQuanMifQ==
